
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserDIYHomes
 * 
 */
export type UserDIYHomes = $Result.DefaultSelection<Prisma.$UserDIYHomesPayload>
/**
 * Model PostDIYHomes
 * 
 */
export type PostDIYHomes = $Result.DefaultSelection<Prisma.$PostDIYHomesPayload>
/**
 * Model ReviewDIYHomes
 * 
 */
export type ReviewDIYHomes = $Result.DefaultSelection<Prisma.$ReviewDIYHomesPayload>
/**
 * Model LikeDIYHomes
 * 
 */
export type LikeDIYHomes = $Result.DefaultSelection<Prisma.$LikeDIYHomesPayload>
/**
 * Model BookmarkDIYHomes
 * 
 */
export type BookmarkDIYHomes = $Result.DefaultSelection<Prisma.$BookmarkDIYHomesPayload>
/**
 * Model ReportDIYHomes
 * 
 */
export type ReportDIYHomes = $Result.DefaultSelection<Prisma.$ReportDIYHomesPayload>
/**
 * Model UserUrbanExplorer
 * 
 */
export type UserUrbanExplorer = $Result.DefaultSelection<Prisma.$UserUrbanExplorerPayload>
/**
 * Model PlaceUrbanExplorer
 * 
 */
export type PlaceUrbanExplorer = $Result.DefaultSelection<Prisma.$PlaceUrbanExplorerPayload>
/**
 * Model ReviewUrbanExplorer
 * 
 */
export type ReviewUrbanExplorer = $Result.DefaultSelection<Prisma.$ReviewUrbanExplorerPayload>
/**
 * Model LikeUrbanExplorer
 * 
 */
export type LikeUrbanExplorer = $Result.DefaultSelection<Prisma.$LikeUrbanExplorerPayload>
/**
 * Model BookmarkUrbanExplorer
 * 
 */
export type BookmarkUrbanExplorer = $Result.DefaultSelection<Prisma.$BookmarkUrbanExplorerPayload>
/**
 * Model ReportUrbanExplorer
 * 
 */
export type ReportUrbanExplorer = $Result.DefaultSelection<Prisma.$ReportUrbanExplorerPayload>
/**
 * Model UserFoodie
 * 
 */
export type UserFoodie = $Result.DefaultSelection<Prisma.$UserFoodiePayload>
/**
 * Model FoodieFood
 * 
 */
export type FoodieFood = $Result.DefaultSelection<Prisma.$FoodieFoodPayload>
/**
 * Model FoodieLocation
 * 
 */
export type FoodieLocation = $Result.DefaultSelection<Prisma.$FoodieLocationPayload>
/**
 * Model FoodieReview
 * 
 */
export type FoodieReview = $Result.DefaultSelection<Prisma.$FoodieReviewPayload>
/**
 * Model FoodieLike
 * 
 */
export type FoodieLike = $Result.DefaultSelection<Prisma.$FoodieLikePayload>
/**
 * Model UserPetLover
 * 
 */
export type UserPetLover = $Result.DefaultSelection<Prisma.$UserPetLoverPayload>
/**
 * Model PetPetLover
 * 
 */
export type PetPetLover = $Result.DefaultSelection<Prisma.$PetPetLoverPayload>
/**
 * Model AppointmentPetLover
 * 
 */
export type AppointmentPetLover = $Result.DefaultSelection<Prisma.$AppointmentPetLoverPayload>
/**
 * Model VaccinationPetLover
 * 
 */
export type VaccinationPetLover = $Result.DefaultSelection<Prisma.$VaccinationPetLoverPayload>
/**
 * Model ClinicPetLover
 * 
 */
export type ClinicPetLover = $Result.DefaultSelection<Prisma.$ClinicPetLoverPayload>
/**
 * Model StorePetLover
 * 
 */
export type StorePetLover = $Result.DefaultSelection<Prisma.$StorePetLoverPayload>
/**
 * Model UserElderlyCareCompanion
 * 
 */
export type UserElderlyCareCompanion = $Result.DefaultSelection<Prisma.$UserElderlyCareCompanionPayload>
/**
 * Model ElderlyCareCompanionAppointment
 * 
 */
export type ElderlyCareCompanionAppointment = $Result.DefaultSelection<Prisma.$ElderlyCareCompanionAppointmentPayload>
/**
 * Model ElderlyCareCompanionClinic
 * 
 */
export type ElderlyCareCompanionClinic = $Result.DefaultSelection<Prisma.$ElderlyCareCompanionClinicPayload>
/**
 * Model ElderlyCareCompanionStore
 * 
 */
export type ElderlyCareCompanionStore = $Result.DefaultSelection<Prisma.$ElderlyCareCompanionStorePayload>
/**
 * Model ElderlyCareCompanionRecord
 * 
 */
export type ElderlyCareCompanionRecord = $Result.DefaultSelection<Prisma.$ElderlyCareCompanionRecordPayload>
/**
 * Model ElderlyCareCompanionMedicationTracking
 * 
 */
export type ElderlyCareCompanionMedicationTracking = $Result.DefaultSelection<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
/**
 * Model UserEduSeeker
 * 
 */
export type UserEduSeeker = $Result.DefaultSelection<Prisma.$UserEduSeekerPayload>
/**
 * Model PlatformEduSeeker
 * 
 */
export type PlatformEduSeeker = $Result.DefaultSelection<Prisma.$PlatformEduSeekerPayload>
/**
 * Model ReviewEduSeeker
 * 
 */
export type ReviewEduSeeker = $Result.DefaultSelection<Prisma.$ReviewEduSeekerPayload>
/**
 * Model UserFinanceManager
 * 
 */
export type UserFinanceManager = $Result.DefaultSelection<Prisma.$UserFinanceManagerPayload>
/**
 * Model TransactionFinanceManager
 * 
 */
export type TransactionFinanceManager = $Result.DefaultSelection<Prisma.$TransactionFinanceManagerPayload>
/**
 * Model GoalFinanceManager
 * 
 */
export type GoalFinanceManager = $Result.DefaultSelection<Prisma.$GoalFinanceManagerPayload>
/**
 * Model UserMentalWellness
 * 
 */
export type UserMentalWellness = $Result.DefaultSelection<Prisma.$UserMentalWellnessPayload>
/**
 * Model JournalMentalWellness
 * 
 */
export type JournalMentalWellness = $Result.DefaultSelection<Prisma.$JournalMentalWellnessPayload>
/**
 * Model AssessmentMentalWellness
 * 
 */
export type AssessmentMentalWellness = $Result.DefaultSelection<Prisma.$AssessmentMentalWellnessPayload>
/**
 * Model Meditation
 * 
 */
export type Meditation = $Result.DefaultSelection<Prisma.$MeditationPayload>
/**
 * Model MeditationFeedback
 * 
 */
export type MeditationFeedback = $Result.DefaultSelection<Prisma.$MeditationFeedbackPayload>
/**
 * Model HospitalMentalWellness
 * 
 */
export type HospitalMentalWellness = $Result.DefaultSelection<Prisma.$HospitalMentalWellnessPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserDIYHomes
 * const userDIYHomes = await prisma.userDIYHomes.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserDIYHomes
   * const userDIYHomes = await prisma.userDIYHomes.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.userDIYHomes`: Exposes CRUD operations for the **UserDIYHomes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDIYHomes
    * const userDIYHomes = await prisma.userDIYHomes.findMany()
    * ```
    */
  get userDIYHomes(): Prisma.UserDIYHomesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postDIYHomes`: Exposes CRUD operations for the **PostDIYHomes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostDIYHomes
    * const postDIYHomes = await prisma.postDIYHomes.findMany()
    * ```
    */
  get postDIYHomes(): Prisma.PostDIYHomesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewDIYHomes`: Exposes CRUD operations for the **ReviewDIYHomes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewDIYHomes
    * const reviewDIYHomes = await prisma.reviewDIYHomes.findMany()
    * ```
    */
  get reviewDIYHomes(): Prisma.ReviewDIYHomesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likeDIYHomes`: Exposes CRUD operations for the **LikeDIYHomes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikeDIYHomes
    * const likeDIYHomes = await prisma.likeDIYHomes.findMany()
    * ```
    */
  get likeDIYHomes(): Prisma.LikeDIYHomesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmarkDIYHomes`: Exposes CRUD operations for the **BookmarkDIYHomes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookmarkDIYHomes
    * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findMany()
    * ```
    */
  get bookmarkDIYHomes(): Prisma.BookmarkDIYHomesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportDIYHomes`: Exposes CRUD operations for the **ReportDIYHomes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportDIYHomes
    * const reportDIYHomes = await prisma.reportDIYHomes.findMany()
    * ```
    */
  get reportDIYHomes(): Prisma.ReportDIYHomesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userUrbanExplorer`: Exposes CRUD operations for the **UserUrbanExplorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserUrbanExplorers
    * const userUrbanExplorers = await prisma.userUrbanExplorer.findMany()
    * ```
    */
  get userUrbanExplorer(): Prisma.UserUrbanExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeUrbanExplorer`: Exposes CRUD operations for the **PlaceUrbanExplorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceUrbanExplorers
    * const placeUrbanExplorers = await prisma.placeUrbanExplorer.findMany()
    * ```
    */
  get placeUrbanExplorer(): Prisma.PlaceUrbanExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewUrbanExplorer`: Exposes CRUD operations for the **ReviewUrbanExplorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewUrbanExplorers
    * const reviewUrbanExplorers = await prisma.reviewUrbanExplorer.findMany()
    * ```
    */
  get reviewUrbanExplorer(): Prisma.ReviewUrbanExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.likeUrbanExplorer`: Exposes CRUD operations for the **LikeUrbanExplorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LikeUrbanExplorers
    * const likeUrbanExplorers = await prisma.likeUrbanExplorer.findMany()
    * ```
    */
  get likeUrbanExplorer(): Prisma.LikeUrbanExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmarkUrbanExplorer`: Exposes CRUD operations for the **BookmarkUrbanExplorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookmarkUrbanExplorers
    * const bookmarkUrbanExplorers = await prisma.bookmarkUrbanExplorer.findMany()
    * ```
    */
  get bookmarkUrbanExplorer(): Prisma.BookmarkUrbanExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportUrbanExplorer`: Exposes CRUD operations for the **ReportUrbanExplorer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportUrbanExplorers
    * const reportUrbanExplorers = await prisma.reportUrbanExplorer.findMany()
    * ```
    */
  get reportUrbanExplorer(): Prisma.ReportUrbanExplorerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFoodie`: Exposes CRUD operations for the **UserFoodie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFoodies
    * const userFoodies = await prisma.userFoodie.findMany()
    * ```
    */
  get userFoodie(): Prisma.UserFoodieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodieFood`: Exposes CRUD operations for the **FoodieFood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodieFoods
    * const foodieFoods = await prisma.foodieFood.findMany()
    * ```
    */
  get foodieFood(): Prisma.FoodieFoodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodieLocation`: Exposes CRUD operations for the **FoodieLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodieLocations
    * const foodieLocations = await prisma.foodieLocation.findMany()
    * ```
    */
  get foodieLocation(): Prisma.FoodieLocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodieReview`: Exposes CRUD operations for the **FoodieReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodieReviews
    * const foodieReviews = await prisma.foodieReview.findMany()
    * ```
    */
  get foodieReview(): Prisma.FoodieReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodieLike`: Exposes CRUD operations for the **FoodieLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodieLikes
    * const foodieLikes = await prisma.foodieLike.findMany()
    * ```
    */
  get foodieLike(): Prisma.FoodieLikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPetLover`: Exposes CRUD operations for the **UserPetLover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPetLovers
    * const userPetLovers = await prisma.userPetLover.findMany()
    * ```
    */
  get userPetLover(): Prisma.UserPetLoverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.petPetLover`: Exposes CRUD operations for the **PetPetLover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PetPetLovers
    * const petPetLovers = await prisma.petPetLover.findMany()
    * ```
    */
  get petPetLover(): Prisma.PetPetLoverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointmentPetLover`: Exposes CRUD operations for the **AppointmentPetLover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppointmentPetLovers
    * const appointmentPetLovers = await prisma.appointmentPetLover.findMany()
    * ```
    */
  get appointmentPetLover(): Prisma.AppointmentPetLoverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccinationPetLover`: Exposes CRUD operations for the **VaccinationPetLover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccinationPetLovers
    * const vaccinationPetLovers = await prisma.vaccinationPetLover.findMany()
    * ```
    */
  get vaccinationPetLover(): Prisma.VaccinationPetLoverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicPetLover`: Exposes CRUD operations for the **ClinicPetLover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicPetLovers
    * const clinicPetLovers = await prisma.clinicPetLover.findMany()
    * ```
    */
  get clinicPetLover(): Prisma.ClinicPetLoverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storePetLover`: Exposes CRUD operations for the **StorePetLover** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorePetLovers
    * const storePetLovers = await prisma.storePetLover.findMany()
    * ```
    */
  get storePetLover(): Prisma.StorePetLoverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userElderlyCareCompanion`: Exposes CRUD operations for the **UserElderlyCareCompanion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserElderlyCareCompanions
    * const userElderlyCareCompanions = await prisma.userElderlyCareCompanion.findMany()
    * ```
    */
  get userElderlyCareCompanion(): Prisma.UserElderlyCareCompanionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elderlyCareCompanionAppointment`: Exposes CRUD operations for the **ElderlyCareCompanionAppointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElderlyCareCompanionAppointments
    * const elderlyCareCompanionAppointments = await prisma.elderlyCareCompanionAppointment.findMany()
    * ```
    */
  get elderlyCareCompanionAppointment(): Prisma.ElderlyCareCompanionAppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elderlyCareCompanionClinic`: Exposes CRUD operations for the **ElderlyCareCompanionClinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElderlyCareCompanionClinics
    * const elderlyCareCompanionClinics = await prisma.elderlyCareCompanionClinic.findMany()
    * ```
    */
  get elderlyCareCompanionClinic(): Prisma.ElderlyCareCompanionClinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elderlyCareCompanionStore`: Exposes CRUD operations for the **ElderlyCareCompanionStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElderlyCareCompanionStores
    * const elderlyCareCompanionStores = await prisma.elderlyCareCompanionStore.findMany()
    * ```
    */
  get elderlyCareCompanionStore(): Prisma.ElderlyCareCompanionStoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elderlyCareCompanionRecord`: Exposes CRUD operations for the **ElderlyCareCompanionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElderlyCareCompanionRecords
    * const elderlyCareCompanionRecords = await prisma.elderlyCareCompanionRecord.findMany()
    * ```
    */
  get elderlyCareCompanionRecord(): Prisma.ElderlyCareCompanionRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elderlyCareCompanionMedicationTracking`: Exposes CRUD operations for the **ElderlyCareCompanionMedicationTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElderlyCareCompanionMedicationTrackings
    * const elderlyCareCompanionMedicationTrackings = await prisma.elderlyCareCompanionMedicationTracking.findMany()
    * ```
    */
  get elderlyCareCompanionMedicationTracking(): Prisma.ElderlyCareCompanionMedicationTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userEduSeeker`: Exposes CRUD operations for the **UserEduSeeker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEduSeekers
    * const userEduSeekers = await prisma.userEduSeeker.findMany()
    * ```
    */
  get userEduSeeker(): Prisma.UserEduSeekerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformEduSeeker`: Exposes CRUD operations for the **PlatformEduSeeker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformEduSeekers
    * const platformEduSeekers = await prisma.platformEduSeeker.findMany()
    * ```
    */
  get platformEduSeeker(): Prisma.PlatformEduSeekerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewEduSeeker`: Exposes CRUD operations for the **ReviewEduSeeker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewEduSeekers
    * const reviewEduSeekers = await prisma.reviewEduSeeker.findMany()
    * ```
    */
  get reviewEduSeeker(): Prisma.ReviewEduSeekerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFinanceManager`: Exposes CRUD operations for the **UserFinanceManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFinanceManagers
    * const userFinanceManagers = await prisma.userFinanceManager.findMany()
    * ```
    */
  get userFinanceManager(): Prisma.UserFinanceManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionFinanceManager`: Exposes CRUD operations for the **TransactionFinanceManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionFinanceManagers
    * const transactionFinanceManagers = await prisma.transactionFinanceManager.findMany()
    * ```
    */
  get transactionFinanceManager(): Prisma.TransactionFinanceManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goalFinanceManager`: Exposes CRUD operations for the **GoalFinanceManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoalFinanceManagers
    * const goalFinanceManagers = await prisma.goalFinanceManager.findMany()
    * ```
    */
  get goalFinanceManager(): Prisma.GoalFinanceManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMentalWellness`: Exposes CRUD operations for the **UserMentalWellness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMentalWellnesses
    * const userMentalWellnesses = await prisma.userMentalWellness.findMany()
    * ```
    */
  get userMentalWellness(): Prisma.UserMentalWellnessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalMentalWellness`: Exposes CRUD operations for the **JournalMentalWellness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalMentalWellnesses
    * const journalMentalWellnesses = await prisma.journalMentalWellness.findMany()
    * ```
    */
  get journalMentalWellness(): Prisma.JournalMentalWellnessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessmentMentalWellness`: Exposes CRUD operations for the **AssessmentMentalWellness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentMentalWellnesses
    * const assessmentMentalWellnesses = await prisma.assessmentMentalWellness.findMany()
    * ```
    */
  get assessmentMentalWellness(): Prisma.AssessmentMentalWellnessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meditation`: Exposes CRUD operations for the **Meditation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meditations
    * const meditations = await prisma.meditation.findMany()
    * ```
    */
  get meditation(): Prisma.MeditationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meditationFeedback`: Exposes CRUD operations for the **MeditationFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeditationFeedbacks
    * const meditationFeedbacks = await prisma.meditationFeedback.findMany()
    * ```
    */
  get meditationFeedback(): Prisma.MeditationFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hospitalMentalWellness`: Exposes CRUD operations for the **HospitalMentalWellness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HospitalMentalWellnesses
    * const hospitalMentalWellnesses = await prisma.hospitalMentalWellness.findMany()
    * ```
    */
  get hospitalMentalWellness(): Prisma.HospitalMentalWellnessDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserDIYHomes: 'UserDIYHomes',
    PostDIYHomes: 'PostDIYHomes',
    ReviewDIYHomes: 'ReviewDIYHomes',
    LikeDIYHomes: 'LikeDIYHomes',
    BookmarkDIYHomes: 'BookmarkDIYHomes',
    ReportDIYHomes: 'ReportDIYHomes',
    UserUrbanExplorer: 'UserUrbanExplorer',
    PlaceUrbanExplorer: 'PlaceUrbanExplorer',
    ReviewUrbanExplorer: 'ReviewUrbanExplorer',
    LikeUrbanExplorer: 'LikeUrbanExplorer',
    BookmarkUrbanExplorer: 'BookmarkUrbanExplorer',
    ReportUrbanExplorer: 'ReportUrbanExplorer',
    UserFoodie: 'UserFoodie',
    FoodieFood: 'FoodieFood',
    FoodieLocation: 'FoodieLocation',
    FoodieReview: 'FoodieReview',
    FoodieLike: 'FoodieLike',
    UserPetLover: 'UserPetLover',
    PetPetLover: 'PetPetLover',
    AppointmentPetLover: 'AppointmentPetLover',
    VaccinationPetLover: 'VaccinationPetLover',
    ClinicPetLover: 'ClinicPetLover',
    StorePetLover: 'StorePetLover',
    UserElderlyCareCompanion: 'UserElderlyCareCompanion',
    ElderlyCareCompanionAppointment: 'ElderlyCareCompanionAppointment',
    ElderlyCareCompanionClinic: 'ElderlyCareCompanionClinic',
    ElderlyCareCompanionStore: 'ElderlyCareCompanionStore',
    ElderlyCareCompanionRecord: 'ElderlyCareCompanionRecord',
    ElderlyCareCompanionMedicationTracking: 'ElderlyCareCompanionMedicationTracking',
    UserEduSeeker: 'UserEduSeeker',
    PlatformEduSeeker: 'PlatformEduSeeker',
    ReviewEduSeeker: 'ReviewEduSeeker',
    UserFinanceManager: 'UserFinanceManager',
    TransactionFinanceManager: 'TransactionFinanceManager',
    GoalFinanceManager: 'GoalFinanceManager',
    UserMentalWellness: 'UserMentalWellness',
    JournalMentalWellness: 'JournalMentalWellness',
    AssessmentMentalWellness: 'AssessmentMentalWellness',
    Meditation: 'Meditation',
    MeditationFeedback: 'MeditationFeedback',
    HospitalMentalWellness: 'HospitalMentalWellness'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    neon?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "userDIYHomes" | "postDIYHomes" | "reviewDIYHomes" | "likeDIYHomes" | "bookmarkDIYHomes" | "reportDIYHomes" | "userUrbanExplorer" | "placeUrbanExplorer" | "reviewUrbanExplorer" | "likeUrbanExplorer" | "bookmarkUrbanExplorer" | "reportUrbanExplorer" | "userFoodie" | "foodieFood" | "foodieLocation" | "foodieReview" | "foodieLike" | "userPetLover" | "petPetLover" | "appointmentPetLover" | "vaccinationPetLover" | "clinicPetLover" | "storePetLover" | "userElderlyCareCompanion" | "elderlyCareCompanionAppointment" | "elderlyCareCompanionClinic" | "elderlyCareCompanionStore" | "elderlyCareCompanionRecord" | "elderlyCareCompanionMedicationTracking" | "userEduSeeker" | "platformEduSeeker" | "reviewEduSeeker" | "userFinanceManager" | "transactionFinanceManager" | "goalFinanceManager" | "userMentalWellness" | "journalMentalWellness" | "assessmentMentalWellness" | "meditation" | "meditationFeedback" | "hospitalMentalWellness"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserDIYHomes: {
        payload: Prisma.$UserDIYHomesPayload<ExtArgs>
        fields: Prisma.UserDIYHomesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDIYHomesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDIYHomesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>
          }
          findFirst: {
            args: Prisma.UserDIYHomesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDIYHomesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>
          }
          findMany: {
            args: Prisma.UserDIYHomesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>[]
          }
          create: {
            args: Prisma.UserDIYHomesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>
          }
          createMany: {
            args: Prisma.UserDIYHomesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDIYHomesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>[]
          }
          delete: {
            args: Prisma.UserDIYHomesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>
          }
          update: {
            args: Prisma.UserDIYHomesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>
          }
          deleteMany: {
            args: Prisma.UserDIYHomesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDIYHomesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDIYHomesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>[]
          }
          upsert: {
            args: Prisma.UserDIYHomesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDIYHomesPayload>
          }
          aggregate: {
            args: Prisma.UserDIYHomesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDIYHomes>
          }
          groupBy: {
            args: Prisma.UserDIYHomesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDIYHomesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDIYHomesCountArgs<ExtArgs>
            result: $Utils.Optional<UserDIYHomesCountAggregateOutputType> | number
          }
        }
      }
      PostDIYHomes: {
        payload: Prisma.$PostDIYHomesPayload<ExtArgs>
        fields: Prisma.PostDIYHomesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostDIYHomesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostDIYHomesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>
          }
          findFirst: {
            args: Prisma.PostDIYHomesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostDIYHomesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>
          }
          findMany: {
            args: Prisma.PostDIYHomesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>[]
          }
          create: {
            args: Prisma.PostDIYHomesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>
          }
          createMany: {
            args: Prisma.PostDIYHomesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostDIYHomesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>[]
          }
          delete: {
            args: Prisma.PostDIYHomesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>
          }
          update: {
            args: Prisma.PostDIYHomesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>
          }
          deleteMany: {
            args: Prisma.PostDIYHomesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostDIYHomesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostDIYHomesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>[]
          }
          upsert: {
            args: Prisma.PostDIYHomesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostDIYHomesPayload>
          }
          aggregate: {
            args: Prisma.PostDIYHomesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostDIYHomes>
          }
          groupBy: {
            args: Prisma.PostDIYHomesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostDIYHomesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostDIYHomesCountArgs<ExtArgs>
            result: $Utils.Optional<PostDIYHomesCountAggregateOutputType> | number
          }
        }
      }
      ReviewDIYHomes: {
        payload: Prisma.$ReviewDIYHomesPayload<ExtArgs>
        fields: Prisma.ReviewDIYHomesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewDIYHomesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewDIYHomesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>
          }
          findFirst: {
            args: Prisma.ReviewDIYHomesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewDIYHomesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>
          }
          findMany: {
            args: Prisma.ReviewDIYHomesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>[]
          }
          create: {
            args: Prisma.ReviewDIYHomesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>
          }
          createMany: {
            args: Prisma.ReviewDIYHomesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewDIYHomesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>[]
          }
          delete: {
            args: Prisma.ReviewDIYHomesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>
          }
          update: {
            args: Prisma.ReviewDIYHomesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDIYHomesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewDIYHomesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewDIYHomesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>[]
          }
          upsert: {
            args: Prisma.ReviewDIYHomesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewDIYHomesPayload>
          }
          aggregate: {
            args: Prisma.ReviewDIYHomesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewDIYHomes>
          }
          groupBy: {
            args: Prisma.ReviewDIYHomesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewDIYHomesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewDIYHomesCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewDIYHomesCountAggregateOutputType> | number
          }
        }
      }
      LikeDIYHomes: {
        payload: Prisma.$LikeDIYHomesPayload<ExtArgs>
        fields: Prisma.LikeDIYHomesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeDIYHomesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeDIYHomesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>
          }
          findFirst: {
            args: Prisma.LikeDIYHomesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeDIYHomesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>
          }
          findMany: {
            args: Prisma.LikeDIYHomesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>[]
          }
          create: {
            args: Prisma.LikeDIYHomesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>
          }
          createMany: {
            args: Prisma.LikeDIYHomesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeDIYHomesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>[]
          }
          delete: {
            args: Prisma.LikeDIYHomesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>
          }
          update: {
            args: Prisma.LikeDIYHomesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>
          }
          deleteMany: {
            args: Prisma.LikeDIYHomesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeDIYHomesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeDIYHomesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>[]
          }
          upsert: {
            args: Prisma.LikeDIYHomesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeDIYHomesPayload>
          }
          aggregate: {
            args: Prisma.LikeDIYHomesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikeDIYHomes>
          }
          groupBy: {
            args: Prisma.LikeDIYHomesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeDIYHomesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeDIYHomesCountArgs<ExtArgs>
            result: $Utils.Optional<LikeDIYHomesCountAggregateOutputType> | number
          }
        }
      }
      BookmarkDIYHomes: {
        payload: Prisma.$BookmarkDIYHomesPayload<ExtArgs>
        fields: Prisma.BookmarkDIYHomesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkDIYHomesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkDIYHomesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>
          }
          findFirst: {
            args: Prisma.BookmarkDIYHomesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkDIYHomesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>
          }
          findMany: {
            args: Prisma.BookmarkDIYHomesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>[]
          }
          create: {
            args: Prisma.BookmarkDIYHomesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>
          }
          createMany: {
            args: Prisma.BookmarkDIYHomesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarkDIYHomesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>[]
          }
          delete: {
            args: Prisma.BookmarkDIYHomesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>
          }
          update: {
            args: Prisma.BookmarkDIYHomesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkDIYHomesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkDIYHomesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookmarkDIYHomesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>[]
          }
          upsert: {
            args: Prisma.BookmarkDIYHomesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkDIYHomesPayload>
          }
          aggregate: {
            args: Prisma.BookmarkDIYHomesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmarkDIYHomes>
          }
          groupBy: {
            args: Prisma.BookmarkDIYHomesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkDIYHomesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkDIYHomesCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkDIYHomesCountAggregateOutputType> | number
          }
        }
      }
      ReportDIYHomes: {
        payload: Prisma.$ReportDIYHomesPayload<ExtArgs>
        fields: Prisma.ReportDIYHomesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportDIYHomesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportDIYHomesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>
          }
          findFirst: {
            args: Prisma.ReportDIYHomesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportDIYHomesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>
          }
          findMany: {
            args: Prisma.ReportDIYHomesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>[]
          }
          create: {
            args: Prisma.ReportDIYHomesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>
          }
          createMany: {
            args: Prisma.ReportDIYHomesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportDIYHomesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>[]
          }
          delete: {
            args: Prisma.ReportDIYHomesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>
          }
          update: {
            args: Prisma.ReportDIYHomesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>
          }
          deleteMany: {
            args: Prisma.ReportDIYHomesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportDIYHomesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportDIYHomesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>[]
          }
          upsert: {
            args: Prisma.ReportDIYHomesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDIYHomesPayload>
          }
          aggregate: {
            args: Prisma.ReportDIYHomesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportDIYHomes>
          }
          groupBy: {
            args: Prisma.ReportDIYHomesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportDIYHomesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportDIYHomesCountArgs<ExtArgs>
            result: $Utils.Optional<ReportDIYHomesCountAggregateOutputType> | number
          }
        }
      }
      UserUrbanExplorer: {
        payload: Prisma.$UserUrbanExplorerPayload<ExtArgs>
        fields: Prisma.UserUrbanExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserUrbanExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>
          }
          findFirst: {
            args: Prisma.UserUrbanExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserUrbanExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>
          }
          findMany: {
            args: Prisma.UserUrbanExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>[]
          }
          create: {
            args: Prisma.UserUrbanExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>
          }
          createMany: {
            args: Prisma.UserUrbanExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserUrbanExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>[]
          }
          delete: {
            args: Prisma.UserUrbanExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>
          }
          update: {
            args: Prisma.UserUrbanExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>
          }
          deleteMany: {
            args: Prisma.UserUrbanExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUrbanExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>[]
          }
          upsert: {
            args: Prisma.UserUrbanExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserUrbanExplorerPayload>
          }
          aggregate: {
            args: Prisma.UserUrbanExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserUrbanExplorer>
          }
          groupBy: {
            args: Prisma.UserUrbanExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserUrbanExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserUrbanExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<UserUrbanExplorerCountAggregateOutputType> | number
          }
        }
      }
      PlaceUrbanExplorer: {
        payload: Prisma.$PlaceUrbanExplorerPayload<ExtArgs>
        fields: Prisma.PlaceUrbanExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceUrbanExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>
          }
          findFirst: {
            args: Prisma.PlaceUrbanExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceUrbanExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>
          }
          findMany: {
            args: Prisma.PlaceUrbanExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>[]
          }
          create: {
            args: Prisma.PlaceUrbanExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>
          }
          createMany: {
            args: Prisma.PlaceUrbanExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceUrbanExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>[]
          }
          delete: {
            args: Prisma.PlaceUrbanExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>
          }
          update: {
            args: Prisma.PlaceUrbanExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>
          }
          deleteMany: {
            args: Prisma.PlaceUrbanExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceUrbanExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>[]
          }
          upsert: {
            args: Prisma.PlaceUrbanExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceUrbanExplorerPayload>
          }
          aggregate: {
            args: Prisma.PlaceUrbanExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceUrbanExplorer>
          }
          groupBy: {
            args: Prisma.PlaceUrbanExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceUrbanExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceUrbanExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceUrbanExplorerCountAggregateOutputType> | number
          }
        }
      }
      ReviewUrbanExplorer: {
        payload: Prisma.$ReviewUrbanExplorerPayload<ExtArgs>
        fields: Prisma.ReviewUrbanExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewUrbanExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>
          }
          findFirst: {
            args: Prisma.ReviewUrbanExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewUrbanExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>
          }
          findMany: {
            args: Prisma.ReviewUrbanExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>[]
          }
          create: {
            args: Prisma.ReviewUrbanExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>
          }
          createMany: {
            args: Prisma.ReviewUrbanExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewUrbanExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>[]
          }
          delete: {
            args: Prisma.ReviewUrbanExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>
          }
          update: {
            args: Prisma.ReviewUrbanExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>
          }
          deleteMany: {
            args: Prisma.ReviewUrbanExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUrbanExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUrbanExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewUrbanExplorerPayload>
          }
          aggregate: {
            args: Prisma.ReviewUrbanExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewUrbanExplorer>
          }
          groupBy: {
            args: Prisma.ReviewUrbanExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewUrbanExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewUrbanExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewUrbanExplorerCountAggregateOutputType> | number
          }
        }
      }
      LikeUrbanExplorer: {
        payload: Prisma.$LikeUrbanExplorerPayload<ExtArgs>
        fields: Prisma.LikeUrbanExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeUrbanExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>
          }
          findFirst: {
            args: Prisma.LikeUrbanExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeUrbanExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>
          }
          findMany: {
            args: Prisma.LikeUrbanExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>[]
          }
          create: {
            args: Prisma.LikeUrbanExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>
          }
          createMany: {
            args: Prisma.LikeUrbanExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeUrbanExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>[]
          }
          delete: {
            args: Prisma.LikeUrbanExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>
          }
          update: {
            args: Prisma.LikeUrbanExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>
          }
          deleteMany: {
            args: Prisma.LikeUrbanExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUrbanExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>[]
          }
          upsert: {
            args: Prisma.LikeUrbanExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikeUrbanExplorerPayload>
          }
          aggregate: {
            args: Prisma.LikeUrbanExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLikeUrbanExplorer>
          }
          groupBy: {
            args: Prisma.LikeUrbanExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeUrbanExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeUrbanExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<LikeUrbanExplorerCountAggregateOutputType> | number
          }
        }
      }
      BookmarkUrbanExplorer: {
        payload: Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>
        fields: Prisma.BookmarkUrbanExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkUrbanExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>
          }
          findFirst: {
            args: Prisma.BookmarkUrbanExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkUrbanExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>
          }
          findMany: {
            args: Prisma.BookmarkUrbanExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>[]
          }
          create: {
            args: Prisma.BookmarkUrbanExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>
          }
          createMany: {
            args: Prisma.BookmarkUrbanExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarkUrbanExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>[]
          }
          delete: {
            args: Prisma.BookmarkUrbanExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>
          }
          update: {
            args: Prisma.BookmarkUrbanExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkUrbanExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkUrbanExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookmarkUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>[]
          }
          upsert: {
            args: Prisma.BookmarkUrbanExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkUrbanExplorerPayload>
          }
          aggregate: {
            args: Prisma.BookmarkUrbanExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmarkUrbanExplorer>
          }
          groupBy: {
            args: Prisma.BookmarkUrbanExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkUrbanExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkUrbanExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkUrbanExplorerCountAggregateOutputType> | number
          }
        }
      }
      ReportUrbanExplorer: {
        payload: Prisma.$ReportUrbanExplorerPayload<ExtArgs>
        fields: Prisma.ReportUrbanExplorerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportUrbanExplorerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>
          }
          findFirst: {
            args: Prisma.ReportUrbanExplorerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportUrbanExplorerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>
          }
          findMany: {
            args: Prisma.ReportUrbanExplorerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>[]
          }
          create: {
            args: Prisma.ReportUrbanExplorerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>
          }
          createMany: {
            args: Prisma.ReportUrbanExplorerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportUrbanExplorerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>[]
          }
          delete: {
            args: Prisma.ReportUrbanExplorerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>
          }
          update: {
            args: Prisma.ReportUrbanExplorerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>
          }
          deleteMany: {
            args: Prisma.ReportUrbanExplorerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUrbanExplorerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>[]
          }
          upsert: {
            args: Prisma.ReportUrbanExplorerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportUrbanExplorerPayload>
          }
          aggregate: {
            args: Prisma.ReportUrbanExplorerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportUrbanExplorer>
          }
          groupBy: {
            args: Prisma.ReportUrbanExplorerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportUrbanExplorerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportUrbanExplorerCountArgs<ExtArgs>
            result: $Utils.Optional<ReportUrbanExplorerCountAggregateOutputType> | number
          }
        }
      }
      UserFoodie: {
        payload: Prisma.$UserFoodiePayload<ExtArgs>
        fields: Prisma.UserFoodieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFoodieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFoodieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>
          }
          findFirst: {
            args: Prisma.UserFoodieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFoodieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>
          }
          findMany: {
            args: Prisma.UserFoodieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>[]
          }
          create: {
            args: Prisma.UserFoodieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>
          }
          createMany: {
            args: Prisma.UserFoodieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFoodieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>[]
          }
          delete: {
            args: Prisma.UserFoodieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>
          }
          update: {
            args: Prisma.UserFoodieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>
          }
          deleteMany: {
            args: Prisma.UserFoodieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFoodieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFoodieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>[]
          }
          upsert: {
            args: Prisma.UserFoodieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFoodiePayload>
          }
          aggregate: {
            args: Prisma.UserFoodieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFoodie>
          }
          groupBy: {
            args: Prisma.UserFoodieGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFoodieGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFoodieCountArgs<ExtArgs>
            result: $Utils.Optional<UserFoodieCountAggregateOutputType> | number
          }
        }
      }
      FoodieFood: {
        payload: Prisma.$FoodieFoodPayload<ExtArgs>
        fields: Prisma.FoodieFoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodieFoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodieFoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>
          }
          findFirst: {
            args: Prisma.FoodieFoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodieFoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>
          }
          findMany: {
            args: Prisma.FoodieFoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>[]
          }
          create: {
            args: Prisma.FoodieFoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>
          }
          createMany: {
            args: Prisma.FoodieFoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodieFoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>[]
          }
          delete: {
            args: Prisma.FoodieFoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>
          }
          update: {
            args: Prisma.FoodieFoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>
          }
          deleteMany: {
            args: Prisma.FoodieFoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodieFoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodieFoodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>[]
          }
          upsert: {
            args: Prisma.FoodieFoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieFoodPayload>
          }
          aggregate: {
            args: Prisma.FoodieFoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodieFood>
          }
          groupBy: {
            args: Prisma.FoodieFoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodieFoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodieFoodCountArgs<ExtArgs>
            result: $Utils.Optional<FoodieFoodCountAggregateOutputType> | number
          }
        }
      }
      FoodieLocation: {
        payload: Prisma.$FoodieLocationPayload<ExtArgs>
        fields: Prisma.FoodieLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodieLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodieLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>
          }
          findFirst: {
            args: Prisma.FoodieLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodieLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>
          }
          findMany: {
            args: Prisma.FoodieLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>[]
          }
          create: {
            args: Prisma.FoodieLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>
          }
          createMany: {
            args: Prisma.FoodieLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodieLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>[]
          }
          delete: {
            args: Prisma.FoodieLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>
          }
          update: {
            args: Prisma.FoodieLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>
          }
          deleteMany: {
            args: Prisma.FoodieLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodieLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodieLocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>[]
          }
          upsert: {
            args: Prisma.FoodieLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLocationPayload>
          }
          aggregate: {
            args: Prisma.FoodieLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodieLocation>
          }
          groupBy: {
            args: Prisma.FoodieLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodieLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodieLocationCountArgs<ExtArgs>
            result: $Utils.Optional<FoodieLocationCountAggregateOutputType> | number
          }
        }
      }
      FoodieReview: {
        payload: Prisma.$FoodieReviewPayload<ExtArgs>
        fields: Prisma.FoodieReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodieReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodieReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>
          }
          findFirst: {
            args: Prisma.FoodieReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodieReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>
          }
          findMany: {
            args: Prisma.FoodieReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>[]
          }
          create: {
            args: Prisma.FoodieReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>
          }
          createMany: {
            args: Prisma.FoodieReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodieReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>[]
          }
          delete: {
            args: Prisma.FoodieReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>
          }
          update: {
            args: Prisma.FoodieReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>
          }
          deleteMany: {
            args: Prisma.FoodieReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodieReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodieReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>[]
          }
          upsert: {
            args: Prisma.FoodieReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieReviewPayload>
          }
          aggregate: {
            args: Prisma.FoodieReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodieReview>
          }
          groupBy: {
            args: Prisma.FoodieReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodieReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodieReviewCountArgs<ExtArgs>
            result: $Utils.Optional<FoodieReviewCountAggregateOutputType> | number
          }
        }
      }
      FoodieLike: {
        payload: Prisma.$FoodieLikePayload<ExtArgs>
        fields: Prisma.FoodieLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodieLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodieLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>
          }
          findFirst: {
            args: Prisma.FoodieLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodieLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>
          }
          findMany: {
            args: Prisma.FoodieLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>[]
          }
          create: {
            args: Prisma.FoodieLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>
          }
          createMany: {
            args: Prisma.FoodieLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodieLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>[]
          }
          delete: {
            args: Prisma.FoodieLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>
          }
          update: {
            args: Prisma.FoodieLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>
          }
          deleteMany: {
            args: Prisma.FoodieLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodieLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FoodieLikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>[]
          }
          upsert: {
            args: Prisma.FoodieLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodieLikePayload>
          }
          aggregate: {
            args: Prisma.FoodieLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodieLike>
          }
          groupBy: {
            args: Prisma.FoodieLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodieLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodieLikeCountArgs<ExtArgs>
            result: $Utils.Optional<FoodieLikeCountAggregateOutputType> | number
          }
        }
      }
      UserPetLover: {
        payload: Prisma.$UserPetLoverPayload<ExtArgs>
        fields: Prisma.UserPetLoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPetLoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPetLoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>
          }
          findFirst: {
            args: Prisma.UserPetLoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPetLoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>
          }
          findMany: {
            args: Prisma.UserPetLoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>[]
          }
          create: {
            args: Prisma.UserPetLoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>
          }
          createMany: {
            args: Prisma.UserPetLoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPetLoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>[]
          }
          delete: {
            args: Prisma.UserPetLoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>
          }
          update: {
            args: Prisma.UserPetLoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>
          }
          deleteMany: {
            args: Prisma.UserPetLoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPetLoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPetLoverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>[]
          }
          upsert: {
            args: Prisma.UserPetLoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPetLoverPayload>
          }
          aggregate: {
            args: Prisma.UserPetLoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPetLover>
          }
          groupBy: {
            args: Prisma.UserPetLoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPetLoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPetLoverCountArgs<ExtArgs>
            result: $Utils.Optional<UserPetLoverCountAggregateOutputType> | number
          }
        }
      }
      PetPetLover: {
        payload: Prisma.$PetPetLoverPayload<ExtArgs>
        fields: Prisma.PetPetLoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PetPetLoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PetPetLoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>
          }
          findFirst: {
            args: Prisma.PetPetLoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PetPetLoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>
          }
          findMany: {
            args: Prisma.PetPetLoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>[]
          }
          create: {
            args: Prisma.PetPetLoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>
          }
          createMany: {
            args: Prisma.PetPetLoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PetPetLoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>[]
          }
          delete: {
            args: Prisma.PetPetLoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>
          }
          update: {
            args: Prisma.PetPetLoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>
          }
          deleteMany: {
            args: Prisma.PetPetLoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PetPetLoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PetPetLoverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>[]
          }
          upsert: {
            args: Prisma.PetPetLoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PetPetLoverPayload>
          }
          aggregate: {
            args: Prisma.PetPetLoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePetPetLover>
          }
          groupBy: {
            args: Prisma.PetPetLoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<PetPetLoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.PetPetLoverCountArgs<ExtArgs>
            result: $Utils.Optional<PetPetLoverCountAggregateOutputType> | number
          }
        }
      }
      AppointmentPetLover: {
        payload: Prisma.$AppointmentPetLoverPayload<ExtArgs>
        fields: Prisma.AppointmentPetLoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentPetLoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentPetLoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>
          }
          findFirst: {
            args: Prisma.AppointmentPetLoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentPetLoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>
          }
          findMany: {
            args: Prisma.AppointmentPetLoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>[]
          }
          create: {
            args: Prisma.AppointmentPetLoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>
          }
          createMany: {
            args: Prisma.AppointmentPetLoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentPetLoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>[]
          }
          delete: {
            args: Prisma.AppointmentPetLoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>
          }
          update: {
            args: Prisma.AppointmentPetLoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentPetLoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentPetLoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentPetLoverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentPetLoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPetLoverPayload>
          }
          aggregate: {
            args: Prisma.AppointmentPetLoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointmentPetLover>
          }
          groupBy: {
            args: Prisma.AppointmentPetLoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentPetLoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentPetLoverCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentPetLoverCountAggregateOutputType> | number
          }
        }
      }
      VaccinationPetLover: {
        payload: Prisma.$VaccinationPetLoverPayload<ExtArgs>
        fields: Prisma.VaccinationPetLoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccinationPetLoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccinationPetLoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>
          }
          findFirst: {
            args: Prisma.VaccinationPetLoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccinationPetLoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>
          }
          findMany: {
            args: Prisma.VaccinationPetLoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>[]
          }
          create: {
            args: Prisma.VaccinationPetLoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>
          }
          createMany: {
            args: Prisma.VaccinationPetLoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VaccinationPetLoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>[]
          }
          delete: {
            args: Prisma.VaccinationPetLoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>
          }
          update: {
            args: Prisma.VaccinationPetLoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>
          }
          deleteMany: {
            args: Prisma.VaccinationPetLoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccinationPetLoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VaccinationPetLoverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>[]
          }
          upsert: {
            args: Prisma.VaccinationPetLoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPetLoverPayload>
          }
          aggregate: {
            args: Prisma.VaccinationPetLoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccinationPetLover>
          }
          groupBy: {
            args: Prisma.VaccinationPetLoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccinationPetLoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccinationPetLoverCountArgs<ExtArgs>
            result: $Utils.Optional<VaccinationPetLoverCountAggregateOutputType> | number
          }
        }
      }
      ClinicPetLover: {
        payload: Prisma.$ClinicPetLoverPayload<ExtArgs>
        fields: Prisma.ClinicPetLoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicPetLoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicPetLoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>
          }
          findFirst: {
            args: Prisma.ClinicPetLoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicPetLoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>
          }
          findMany: {
            args: Prisma.ClinicPetLoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>[]
          }
          create: {
            args: Prisma.ClinicPetLoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>
          }
          createMany: {
            args: Prisma.ClinicPetLoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicPetLoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>[]
          }
          delete: {
            args: Prisma.ClinicPetLoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>
          }
          update: {
            args: Prisma.ClinicPetLoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>
          }
          deleteMany: {
            args: Prisma.ClinicPetLoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicPetLoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicPetLoverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>[]
          }
          upsert: {
            args: Prisma.ClinicPetLoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPetLoverPayload>
          }
          aggregate: {
            args: Prisma.ClinicPetLoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicPetLover>
          }
          groupBy: {
            args: Prisma.ClinicPetLoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicPetLoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicPetLoverCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicPetLoverCountAggregateOutputType> | number
          }
        }
      }
      StorePetLover: {
        payload: Prisma.$StorePetLoverPayload<ExtArgs>
        fields: Prisma.StorePetLoverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorePetLoverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorePetLoverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>
          }
          findFirst: {
            args: Prisma.StorePetLoverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorePetLoverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>
          }
          findMany: {
            args: Prisma.StorePetLoverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>[]
          }
          create: {
            args: Prisma.StorePetLoverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>
          }
          createMany: {
            args: Prisma.StorePetLoverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorePetLoverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>[]
          }
          delete: {
            args: Prisma.StorePetLoverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>
          }
          update: {
            args: Prisma.StorePetLoverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>
          }
          deleteMany: {
            args: Prisma.StorePetLoverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorePetLoverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StorePetLoverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>[]
          }
          upsert: {
            args: Prisma.StorePetLoverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePetLoverPayload>
          }
          aggregate: {
            args: Prisma.StorePetLoverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorePetLover>
          }
          groupBy: {
            args: Prisma.StorePetLoverGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorePetLoverGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorePetLoverCountArgs<ExtArgs>
            result: $Utils.Optional<StorePetLoverCountAggregateOutputType> | number
          }
        }
      }
      UserElderlyCareCompanion: {
        payload: Prisma.$UserElderlyCareCompanionPayload<ExtArgs>
        fields: Prisma.UserElderlyCareCompanionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserElderlyCareCompanionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserElderlyCareCompanionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>
          }
          findFirst: {
            args: Prisma.UserElderlyCareCompanionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserElderlyCareCompanionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>
          }
          findMany: {
            args: Prisma.UserElderlyCareCompanionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>[]
          }
          create: {
            args: Prisma.UserElderlyCareCompanionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>
          }
          createMany: {
            args: Prisma.UserElderlyCareCompanionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserElderlyCareCompanionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>[]
          }
          delete: {
            args: Prisma.UserElderlyCareCompanionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>
          }
          update: {
            args: Prisma.UserElderlyCareCompanionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>
          }
          deleteMany: {
            args: Prisma.UserElderlyCareCompanionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserElderlyCareCompanionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserElderlyCareCompanionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>[]
          }
          upsert: {
            args: Prisma.UserElderlyCareCompanionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserElderlyCareCompanionPayload>
          }
          aggregate: {
            args: Prisma.UserElderlyCareCompanionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserElderlyCareCompanion>
          }
          groupBy: {
            args: Prisma.UserElderlyCareCompanionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserElderlyCareCompanionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserElderlyCareCompanionCountArgs<ExtArgs>
            result: $Utils.Optional<UserElderlyCareCompanionCountAggregateOutputType> | number
          }
        }
      }
      ElderlyCareCompanionAppointment: {
        payload: Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>
        fields: Prisma.ElderlyCareCompanionAppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElderlyCareCompanionAppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElderlyCareCompanionAppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>
          }
          findFirst: {
            args: Prisma.ElderlyCareCompanionAppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElderlyCareCompanionAppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>
          }
          findMany: {
            args: Prisma.ElderlyCareCompanionAppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>[]
          }
          create: {
            args: Prisma.ElderlyCareCompanionAppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>
          }
          createMany: {
            args: Prisma.ElderlyCareCompanionAppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElderlyCareCompanionAppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>[]
          }
          delete: {
            args: Prisma.ElderlyCareCompanionAppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>
          }
          update: {
            args: Prisma.ElderlyCareCompanionAppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>
          }
          deleteMany: {
            args: Prisma.ElderlyCareCompanionAppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElderlyCareCompanionAppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElderlyCareCompanionAppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>[]
          }
          upsert: {
            args: Prisma.ElderlyCareCompanionAppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionAppointmentPayload>
          }
          aggregate: {
            args: Prisma.ElderlyCareCompanionAppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElderlyCareCompanionAppointment>
          }
          groupBy: {
            args: Prisma.ElderlyCareCompanionAppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionAppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElderlyCareCompanionAppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionAppointmentCountAggregateOutputType> | number
          }
        }
      }
      ElderlyCareCompanionClinic: {
        payload: Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>
        fields: Prisma.ElderlyCareCompanionClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElderlyCareCompanionClinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElderlyCareCompanionClinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>
          }
          findFirst: {
            args: Prisma.ElderlyCareCompanionClinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElderlyCareCompanionClinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>
          }
          findMany: {
            args: Prisma.ElderlyCareCompanionClinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>[]
          }
          create: {
            args: Prisma.ElderlyCareCompanionClinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>
          }
          createMany: {
            args: Prisma.ElderlyCareCompanionClinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElderlyCareCompanionClinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>[]
          }
          delete: {
            args: Prisma.ElderlyCareCompanionClinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>
          }
          update: {
            args: Prisma.ElderlyCareCompanionClinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>
          }
          deleteMany: {
            args: Prisma.ElderlyCareCompanionClinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElderlyCareCompanionClinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElderlyCareCompanionClinicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>[]
          }
          upsert: {
            args: Prisma.ElderlyCareCompanionClinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionClinicPayload>
          }
          aggregate: {
            args: Prisma.ElderlyCareCompanionClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElderlyCareCompanionClinic>
          }
          groupBy: {
            args: Prisma.ElderlyCareCompanionClinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElderlyCareCompanionClinicCountArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionClinicCountAggregateOutputType> | number
          }
        }
      }
      ElderlyCareCompanionStore: {
        payload: Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>
        fields: Prisma.ElderlyCareCompanionStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElderlyCareCompanionStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElderlyCareCompanionStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>
          }
          findFirst: {
            args: Prisma.ElderlyCareCompanionStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElderlyCareCompanionStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>
          }
          findMany: {
            args: Prisma.ElderlyCareCompanionStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>[]
          }
          create: {
            args: Prisma.ElderlyCareCompanionStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>
          }
          createMany: {
            args: Prisma.ElderlyCareCompanionStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElderlyCareCompanionStoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>[]
          }
          delete: {
            args: Prisma.ElderlyCareCompanionStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>
          }
          update: {
            args: Prisma.ElderlyCareCompanionStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>
          }
          deleteMany: {
            args: Prisma.ElderlyCareCompanionStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElderlyCareCompanionStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElderlyCareCompanionStoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>[]
          }
          upsert: {
            args: Prisma.ElderlyCareCompanionStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionStorePayload>
          }
          aggregate: {
            args: Prisma.ElderlyCareCompanionStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElderlyCareCompanionStore>
          }
          groupBy: {
            args: Prisma.ElderlyCareCompanionStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionStoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElderlyCareCompanionStoreCountArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionStoreCountAggregateOutputType> | number
          }
        }
      }
      ElderlyCareCompanionRecord: {
        payload: Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>
        fields: Prisma.ElderlyCareCompanionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElderlyCareCompanionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElderlyCareCompanionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>
          }
          findFirst: {
            args: Prisma.ElderlyCareCompanionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElderlyCareCompanionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>
          }
          findMany: {
            args: Prisma.ElderlyCareCompanionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>[]
          }
          create: {
            args: Prisma.ElderlyCareCompanionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>
          }
          createMany: {
            args: Prisma.ElderlyCareCompanionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElderlyCareCompanionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>[]
          }
          delete: {
            args: Prisma.ElderlyCareCompanionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>
          }
          update: {
            args: Prisma.ElderlyCareCompanionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>
          }
          deleteMany: {
            args: Prisma.ElderlyCareCompanionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElderlyCareCompanionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElderlyCareCompanionRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>[]
          }
          upsert: {
            args: Prisma.ElderlyCareCompanionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionRecordPayload>
          }
          aggregate: {
            args: Prisma.ElderlyCareCompanionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElderlyCareCompanionRecord>
          }
          groupBy: {
            args: Prisma.ElderlyCareCompanionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElderlyCareCompanionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionRecordCountAggregateOutputType> | number
          }
        }
      }
      ElderlyCareCompanionMedicationTracking: {
        payload: Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>
        fields: Prisma.ElderlyCareCompanionMedicationTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
          }
          findFirst: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
          }
          findMany: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>[]
          }
          create: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
          }
          createMany: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>[]
          }
          delete: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
          }
          update: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
          }
          deleteMany: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>[]
          }
          upsert: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload>
          }
          aggregate: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElderlyCareCompanionMedicationTracking>
          }
          groupBy: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionMedicationTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElderlyCareCompanionMedicationTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<ElderlyCareCompanionMedicationTrackingCountAggregateOutputType> | number
          }
        }
      }
      UserEduSeeker: {
        payload: Prisma.$UserEduSeekerPayload<ExtArgs>
        fields: Prisma.UserEduSeekerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserEduSeekerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserEduSeekerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>
          }
          findFirst: {
            args: Prisma.UserEduSeekerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserEduSeekerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>
          }
          findMany: {
            args: Prisma.UserEduSeekerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>[]
          }
          create: {
            args: Prisma.UserEduSeekerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>
          }
          createMany: {
            args: Prisma.UserEduSeekerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserEduSeekerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>[]
          }
          delete: {
            args: Prisma.UserEduSeekerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>
          }
          update: {
            args: Prisma.UserEduSeekerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>
          }
          deleteMany: {
            args: Prisma.UserEduSeekerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserEduSeekerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserEduSeekerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>[]
          }
          upsert: {
            args: Prisma.UserEduSeekerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserEduSeekerPayload>
          }
          aggregate: {
            args: Prisma.UserEduSeekerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserEduSeeker>
          }
          groupBy: {
            args: Prisma.UserEduSeekerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserEduSeekerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserEduSeekerCountArgs<ExtArgs>
            result: $Utils.Optional<UserEduSeekerCountAggregateOutputType> | number
          }
        }
      }
      PlatformEduSeeker: {
        payload: Prisma.$PlatformEduSeekerPayload<ExtArgs>
        fields: Prisma.PlatformEduSeekerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformEduSeekerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformEduSeekerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>
          }
          findFirst: {
            args: Prisma.PlatformEduSeekerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformEduSeekerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>
          }
          findMany: {
            args: Prisma.PlatformEduSeekerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>[]
          }
          create: {
            args: Prisma.PlatformEduSeekerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>
          }
          createMany: {
            args: Prisma.PlatformEduSeekerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformEduSeekerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>[]
          }
          delete: {
            args: Prisma.PlatformEduSeekerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>
          }
          update: {
            args: Prisma.PlatformEduSeekerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>
          }
          deleteMany: {
            args: Prisma.PlatformEduSeekerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformEduSeekerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformEduSeekerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>[]
          }
          upsert: {
            args: Prisma.PlatformEduSeekerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformEduSeekerPayload>
          }
          aggregate: {
            args: Prisma.PlatformEduSeekerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformEduSeeker>
          }
          groupBy: {
            args: Prisma.PlatformEduSeekerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformEduSeekerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformEduSeekerCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformEduSeekerCountAggregateOutputType> | number
          }
        }
      }
      ReviewEduSeeker: {
        payload: Prisma.$ReviewEduSeekerPayload<ExtArgs>
        fields: Prisma.ReviewEduSeekerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewEduSeekerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewEduSeekerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>
          }
          findFirst: {
            args: Prisma.ReviewEduSeekerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewEduSeekerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>
          }
          findMany: {
            args: Prisma.ReviewEduSeekerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>[]
          }
          create: {
            args: Prisma.ReviewEduSeekerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>
          }
          createMany: {
            args: Prisma.ReviewEduSeekerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewEduSeekerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>[]
          }
          delete: {
            args: Prisma.ReviewEduSeekerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>
          }
          update: {
            args: Prisma.ReviewEduSeekerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>
          }
          deleteMany: {
            args: Prisma.ReviewEduSeekerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewEduSeekerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewEduSeekerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>[]
          }
          upsert: {
            args: Prisma.ReviewEduSeekerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewEduSeekerPayload>
          }
          aggregate: {
            args: Prisma.ReviewEduSeekerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewEduSeeker>
          }
          groupBy: {
            args: Prisma.ReviewEduSeekerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewEduSeekerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewEduSeekerCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewEduSeekerCountAggregateOutputType> | number
          }
        }
      }
      UserFinanceManager: {
        payload: Prisma.$UserFinanceManagerPayload<ExtArgs>
        fields: Prisma.UserFinanceManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFinanceManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFinanceManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>
          }
          findFirst: {
            args: Prisma.UserFinanceManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFinanceManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>
          }
          findMany: {
            args: Prisma.UserFinanceManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>[]
          }
          create: {
            args: Prisma.UserFinanceManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>
          }
          createMany: {
            args: Prisma.UserFinanceManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFinanceManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>[]
          }
          delete: {
            args: Prisma.UserFinanceManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>
          }
          update: {
            args: Prisma.UserFinanceManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>
          }
          deleteMany: {
            args: Prisma.UserFinanceManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFinanceManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFinanceManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>[]
          }
          upsert: {
            args: Prisma.UserFinanceManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFinanceManagerPayload>
          }
          aggregate: {
            args: Prisma.UserFinanceManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFinanceManager>
          }
          groupBy: {
            args: Prisma.UserFinanceManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFinanceManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFinanceManagerCountArgs<ExtArgs>
            result: $Utils.Optional<UserFinanceManagerCountAggregateOutputType> | number
          }
        }
      }
      TransactionFinanceManager: {
        payload: Prisma.$TransactionFinanceManagerPayload<ExtArgs>
        fields: Prisma.TransactionFinanceManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFinanceManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFinanceManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>
          }
          findFirst: {
            args: Prisma.TransactionFinanceManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFinanceManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>
          }
          findMany: {
            args: Prisma.TransactionFinanceManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>[]
          }
          create: {
            args: Prisma.TransactionFinanceManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>
          }
          createMany: {
            args: Prisma.TransactionFinanceManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionFinanceManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>[]
          }
          delete: {
            args: Prisma.TransactionFinanceManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>
          }
          update: {
            args: Prisma.TransactionFinanceManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>
          }
          deleteMany: {
            args: Prisma.TransactionFinanceManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionFinanceManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionFinanceManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>[]
          }
          upsert: {
            args: Prisma.TransactionFinanceManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFinanceManagerPayload>
          }
          aggregate: {
            args: Prisma.TransactionFinanceManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionFinanceManager>
          }
          groupBy: {
            args: Prisma.TransactionFinanceManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionFinanceManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionFinanceManagerCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionFinanceManagerCountAggregateOutputType> | number
          }
        }
      }
      GoalFinanceManager: {
        payload: Prisma.$GoalFinanceManagerPayload<ExtArgs>
        fields: Prisma.GoalFinanceManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalFinanceManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalFinanceManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>
          }
          findFirst: {
            args: Prisma.GoalFinanceManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalFinanceManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>
          }
          findMany: {
            args: Prisma.GoalFinanceManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>[]
          }
          create: {
            args: Prisma.GoalFinanceManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>
          }
          createMany: {
            args: Prisma.GoalFinanceManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalFinanceManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>[]
          }
          delete: {
            args: Prisma.GoalFinanceManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>
          }
          update: {
            args: Prisma.GoalFinanceManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>
          }
          deleteMany: {
            args: Prisma.GoalFinanceManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalFinanceManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoalFinanceManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>[]
          }
          upsert: {
            args: Prisma.GoalFinanceManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalFinanceManagerPayload>
          }
          aggregate: {
            args: Prisma.GoalFinanceManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoalFinanceManager>
          }
          groupBy: {
            args: Prisma.GoalFinanceManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalFinanceManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalFinanceManagerCountArgs<ExtArgs>
            result: $Utils.Optional<GoalFinanceManagerCountAggregateOutputType> | number
          }
        }
      }
      UserMentalWellness: {
        payload: Prisma.$UserMentalWellnessPayload<ExtArgs>
        fields: Prisma.UserMentalWellnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMentalWellnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMentalWellnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>
          }
          findFirst: {
            args: Prisma.UserMentalWellnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMentalWellnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>
          }
          findMany: {
            args: Prisma.UserMentalWellnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>[]
          }
          create: {
            args: Prisma.UserMentalWellnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>
          }
          createMany: {
            args: Prisma.UserMentalWellnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMentalWellnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>[]
          }
          delete: {
            args: Prisma.UserMentalWellnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>
          }
          update: {
            args: Prisma.UserMentalWellnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>
          }
          deleteMany: {
            args: Prisma.UserMentalWellnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMentalWellnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMentalWellnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>[]
          }
          upsert: {
            args: Prisma.UserMentalWellnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMentalWellnessPayload>
          }
          aggregate: {
            args: Prisma.UserMentalWellnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMentalWellness>
          }
          groupBy: {
            args: Prisma.UserMentalWellnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMentalWellnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMentalWellnessCountArgs<ExtArgs>
            result: $Utils.Optional<UserMentalWellnessCountAggregateOutputType> | number
          }
        }
      }
      JournalMentalWellness: {
        payload: Prisma.$JournalMentalWellnessPayload<ExtArgs>
        fields: Prisma.JournalMentalWellnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalMentalWellnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalMentalWellnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>
          }
          findFirst: {
            args: Prisma.JournalMentalWellnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalMentalWellnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>
          }
          findMany: {
            args: Prisma.JournalMentalWellnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>[]
          }
          create: {
            args: Prisma.JournalMentalWellnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>
          }
          createMany: {
            args: Prisma.JournalMentalWellnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalMentalWellnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>[]
          }
          delete: {
            args: Prisma.JournalMentalWellnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>
          }
          update: {
            args: Prisma.JournalMentalWellnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>
          }
          deleteMany: {
            args: Prisma.JournalMentalWellnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalMentalWellnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalMentalWellnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>[]
          }
          upsert: {
            args: Prisma.JournalMentalWellnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalMentalWellnessPayload>
          }
          aggregate: {
            args: Prisma.JournalMentalWellnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalMentalWellness>
          }
          groupBy: {
            args: Prisma.JournalMentalWellnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalMentalWellnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalMentalWellnessCountArgs<ExtArgs>
            result: $Utils.Optional<JournalMentalWellnessCountAggregateOutputType> | number
          }
        }
      }
      AssessmentMentalWellness: {
        payload: Prisma.$AssessmentMentalWellnessPayload<ExtArgs>
        fields: Prisma.AssessmentMentalWellnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentMentalWellnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentMentalWellnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>
          }
          findFirst: {
            args: Prisma.AssessmentMentalWellnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentMentalWellnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>
          }
          findMany: {
            args: Prisma.AssessmentMentalWellnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>[]
          }
          create: {
            args: Prisma.AssessmentMentalWellnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>
          }
          createMany: {
            args: Prisma.AssessmentMentalWellnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentMentalWellnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>[]
          }
          delete: {
            args: Prisma.AssessmentMentalWellnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>
          }
          update: {
            args: Prisma.AssessmentMentalWellnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentMentalWellnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentMentalWellnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssessmentMentalWellnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>[]
          }
          upsert: {
            args: Prisma.AssessmentMentalWellnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentMentalWellnessPayload>
          }
          aggregate: {
            args: Prisma.AssessmentMentalWellnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentMentalWellness>
          }
          groupBy: {
            args: Prisma.AssessmentMentalWellnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentMentalWellnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentMentalWellnessCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentMentalWellnessCountAggregateOutputType> | number
          }
        }
      }
      Meditation: {
        payload: Prisma.$MeditationPayload<ExtArgs>
        fields: Prisma.MeditationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeditationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeditationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>
          }
          findFirst: {
            args: Prisma.MeditationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeditationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>
          }
          findMany: {
            args: Prisma.MeditationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>[]
          }
          create: {
            args: Prisma.MeditationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>
          }
          createMany: {
            args: Prisma.MeditationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeditationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>[]
          }
          delete: {
            args: Prisma.MeditationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>
          }
          update: {
            args: Prisma.MeditationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>
          }
          deleteMany: {
            args: Prisma.MeditationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeditationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeditationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>[]
          }
          upsert: {
            args: Prisma.MeditationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationPayload>
          }
          aggregate: {
            args: Prisma.MeditationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeditation>
          }
          groupBy: {
            args: Prisma.MeditationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeditationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeditationCountArgs<ExtArgs>
            result: $Utils.Optional<MeditationCountAggregateOutputType> | number
          }
        }
      }
      MeditationFeedback: {
        payload: Prisma.$MeditationFeedbackPayload<ExtArgs>
        fields: Prisma.MeditationFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeditationFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeditationFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>
          }
          findFirst: {
            args: Prisma.MeditationFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeditationFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>
          }
          findMany: {
            args: Prisma.MeditationFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>[]
          }
          create: {
            args: Prisma.MeditationFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>
          }
          createMany: {
            args: Prisma.MeditationFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeditationFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>[]
          }
          delete: {
            args: Prisma.MeditationFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>
          }
          update: {
            args: Prisma.MeditationFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.MeditationFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeditationFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeditationFeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>[]
          }
          upsert: {
            args: Prisma.MeditationFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeditationFeedbackPayload>
          }
          aggregate: {
            args: Prisma.MeditationFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeditationFeedback>
          }
          groupBy: {
            args: Prisma.MeditationFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeditationFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeditationFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<MeditationFeedbackCountAggregateOutputType> | number
          }
        }
      }
      HospitalMentalWellness: {
        payload: Prisma.$HospitalMentalWellnessPayload<ExtArgs>
        fields: Prisma.HospitalMentalWellnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalMentalWellnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalMentalWellnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>
          }
          findFirst: {
            args: Prisma.HospitalMentalWellnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalMentalWellnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>
          }
          findMany: {
            args: Prisma.HospitalMentalWellnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>[]
          }
          create: {
            args: Prisma.HospitalMentalWellnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>
          }
          createMany: {
            args: Prisma.HospitalMentalWellnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospitalMentalWellnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>[]
          }
          delete: {
            args: Prisma.HospitalMentalWellnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>
          }
          update: {
            args: Prisma.HospitalMentalWellnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>
          }
          deleteMany: {
            args: Prisma.HospitalMentalWellnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalMentalWellnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HospitalMentalWellnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>[]
          }
          upsert: {
            args: Prisma.HospitalMentalWellnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalMentalWellnessPayload>
          }
          aggregate: {
            args: Prisma.HospitalMentalWellnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospitalMentalWellness>
          }
          groupBy: {
            args: Prisma.HospitalMentalWellnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalMentalWellnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalMentalWellnessCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalMentalWellnessCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    userDIYHomes?: UserDIYHomesOmit
    postDIYHomes?: PostDIYHomesOmit
    reviewDIYHomes?: ReviewDIYHomesOmit
    likeDIYHomes?: LikeDIYHomesOmit
    bookmarkDIYHomes?: BookmarkDIYHomesOmit
    reportDIYHomes?: ReportDIYHomesOmit
    userUrbanExplorer?: UserUrbanExplorerOmit
    placeUrbanExplorer?: PlaceUrbanExplorerOmit
    reviewUrbanExplorer?: ReviewUrbanExplorerOmit
    likeUrbanExplorer?: LikeUrbanExplorerOmit
    bookmarkUrbanExplorer?: BookmarkUrbanExplorerOmit
    reportUrbanExplorer?: ReportUrbanExplorerOmit
    userFoodie?: UserFoodieOmit
    foodieFood?: FoodieFoodOmit
    foodieLocation?: FoodieLocationOmit
    foodieReview?: FoodieReviewOmit
    foodieLike?: FoodieLikeOmit
    userPetLover?: UserPetLoverOmit
    petPetLover?: PetPetLoverOmit
    appointmentPetLover?: AppointmentPetLoverOmit
    vaccinationPetLover?: VaccinationPetLoverOmit
    clinicPetLover?: ClinicPetLoverOmit
    storePetLover?: StorePetLoverOmit
    userElderlyCareCompanion?: UserElderlyCareCompanionOmit
    elderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentOmit
    elderlyCareCompanionClinic?: ElderlyCareCompanionClinicOmit
    elderlyCareCompanionStore?: ElderlyCareCompanionStoreOmit
    elderlyCareCompanionRecord?: ElderlyCareCompanionRecordOmit
    elderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingOmit
    userEduSeeker?: UserEduSeekerOmit
    platformEduSeeker?: PlatformEduSeekerOmit
    reviewEduSeeker?: ReviewEduSeekerOmit
    userFinanceManager?: UserFinanceManagerOmit
    transactionFinanceManager?: TransactionFinanceManagerOmit
    goalFinanceManager?: GoalFinanceManagerOmit
    userMentalWellness?: UserMentalWellnessOmit
    journalMentalWellness?: JournalMentalWellnessOmit
    assessmentMentalWellness?: AssessmentMentalWellnessOmit
    meditation?: MeditationOmit
    meditationFeedback?: MeditationFeedbackOmit
    hospitalMentalWellness?: HospitalMentalWellnessOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserDIYHomesCountOutputType
   */

  export type UserDIYHomesCountOutputType = {
    PostDIYHomes: number
    ReviewDIYHomes: number
    LikeDIYHomes: number
    BookmarkDIYHomes: number
    ReportDIYHomes: number
  }

  export type UserDIYHomesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PostDIYHomes?: boolean | UserDIYHomesCountOutputTypeCountPostDIYHomesArgs
    ReviewDIYHomes?: boolean | UserDIYHomesCountOutputTypeCountReviewDIYHomesArgs
    LikeDIYHomes?: boolean | UserDIYHomesCountOutputTypeCountLikeDIYHomesArgs
    BookmarkDIYHomes?: boolean | UserDIYHomesCountOutputTypeCountBookmarkDIYHomesArgs
    ReportDIYHomes?: boolean | UserDIYHomesCountOutputTypeCountReportDIYHomesArgs
  }

  // Custom InputTypes
  /**
   * UserDIYHomesCountOutputType without action
   */
  export type UserDIYHomesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomesCountOutputType
     */
    select?: UserDIYHomesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserDIYHomesCountOutputType without action
   */
  export type UserDIYHomesCountOutputTypeCountPostDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostDIYHomesWhereInput
  }

  /**
   * UserDIYHomesCountOutputType without action
   */
  export type UserDIYHomesCountOutputTypeCountReviewDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewDIYHomesWhereInput
  }

  /**
   * UserDIYHomesCountOutputType without action
   */
  export type UserDIYHomesCountOutputTypeCountLikeDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeDIYHomesWhereInput
  }

  /**
   * UserDIYHomesCountOutputType without action
   */
  export type UserDIYHomesCountOutputTypeCountBookmarkDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkDIYHomesWhereInput
  }

  /**
   * UserDIYHomesCountOutputType without action
   */
  export type UserDIYHomesCountOutputTypeCountReportDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDIYHomesWhereInput
  }


  /**
   * Count Type PostDIYHomesCountOutputType
   */

  export type PostDIYHomesCountOutputType = {
    reviews: number
    bookmarks: number
    Like: number
    Report: number
  }

  export type PostDIYHomesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | PostDIYHomesCountOutputTypeCountReviewsArgs
    bookmarks?: boolean | PostDIYHomesCountOutputTypeCountBookmarksArgs
    Like?: boolean | PostDIYHomesCountOutputTypeCountLikeArgs
    Report?: boolean | PostDIYHomesCountOutputTypeCountReportArgs
  }

  // Custom InputTypes
  /**
   * PostDIYHomesCountOutputType without action
   */
  export type PostDIYHomesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomesCountOutputType
     */
    select?: PostDIYHomesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostDIYHomesCountOutputType without action
   */
  export type PostDIYHomesCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewDIYHomesWhereInput
  }

  /**
   * PostDIYHomesCountOutputType without action
   */
  export type PostDIYHomesCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkDIYHomesWhereInput
  }

  /**
   * PostDIYHomesCountOutputType without action
   */
  export type PostDIYHomesCountOutputTypeCountLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeDIYHomesWhereInput
  }

  /**
   * PostDIYHomesCountOutputType without action
   */
  export type PostDIYHomesCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDIYHomesWhereInput
  }


  /**
   * Count Type ReviewDIYHomesCountOutputType
   */

  export type ReviewDIYHomesCountOutputType = {
    Report: number
  }

  export type ReviewDIYHomesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Report?: boolean | ReviewDIYHomesCountOutputTypeCountReportArgs
  }

  // Custom InputTypes
  /**
   * ReviewDIYHomesCountOutputType without action
   */
  export type ReviewDIYHomesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomesCountOutputType
     */
    select?: ReviewDIYHomesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewDIYHomesCountOutputType without action
   */
  export type ReviewDIYHomesCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDIYHomesWhereInput
  }


  /**
   * Count Type UserUrbanExplorerCountOutputType
   */

  export type UserUrbanExplorerCountOutputType = {
    PlaceUrbanExplorer: number
    ReviewUrbanExplorer: number
    LikeUrbanExplorer: number
    BookmarkUrbanExplorer: number
    ReportUrbanExplorer: number
  }

  export type UserUrbanExplorerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PlaceUrbanExplorer?: boolean | UserUrbanExplorerCountOutputTypeCountPlaceUrbanExplorerArgs
    ReviewUrbanExplorer?: boolean | UserUrbanExplorerCountOutputTypeCountReviewUrbanExplorerArgs
    LikeUrbanExplorer?: boolean | UserUrbanExplorerCountOutputTypeCountLikeUrbanExplorerArgs
    BookmarkUrbanExplorer?: boolean | UserUrbanExplorerCountOutputTypeCountBookmarkUrbanExplorerArgs
    ReportUrbanExplorer?: boolean | UserUrbanExplorerCountOutputTypeCountReportUrbanExplorerArgs
  }

  // Custom InputTypes
  /**
   * UserUrbanExplorerCountOutputType without action
   */
  export type UserUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorerCountOutputType
     */
    select?: UserUrbanExplorerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserUrbanExplorerCountOutputType without action
   */
  export type UserUrbanExplorerCountOutputTypeCountPlaceUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceUrbanExplorerWhereInput
  }

  /**
   * UserUrbanExplorerCountOutputType without action
   */
  export type UserUrbanExplorerCountOutputTypeCountReviewUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewUrbanExplorerWhereInput
  }

  /**
   * UserUrbanExplorerCountOutputType without action
   */
  export type UserUrbanExplorerCountOutputTypeCountLikeUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeUrbanExplorerWhereInput
  }

  /**
   * UserUrbanExplorerCountOutputType without action
   */
  export type UserUrbanExplorerCountOutputTypeCountBookmarkUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkUrbanExplorerWhereInput
  }

  /**
   * UserUrbanExplorerCountOutputType without action
   */
  export type UserUrbanExplorerCountOutputTypeCountReportUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUrbanExplorerWhereInput
  }


  /**
   * Count Type PlaceUrbanExplorerCountOutputType
   */

  export type PlaceUrbanExplorerCountOutputType = {
    reviews: number
    bookmarks: number
    likes: number
    reports: number
  }

  export type PlaceUrbanExplorerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | PlaceUrbanExplorerCountOutputTypeCountReviewsArgs
    bookmarks?: boolean | PlaceUrbanExplorerCountOutputTypeCountBookmarksArgs
    likes?: boolean | PlaceUrbanExplorerCountOutputTypeCountLikesArgs
    reports?: boolean | PlaceUrbanExplorerCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * PlaceUrbanExplorerCountOutputType without action
   */
  export type PlaceUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorerCountOutputType
     */
    select?: PlaceUrbanExplorerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaceUrbanExplorerCountOutputType without action
   */
  export type PlaceUrbanExplorerCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewUrbanExplorerWhereInput
  }

  /**
   * PlaceUrbanExplorerCountOutputType without action
   */
  export type PlaceUrbanExplorerCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkUrbanExplorerWhereInput
  }

  /**
   * PlaceUrbanExplorerCountOutputType without action
   */
  export type PlaceUrbanExplorerCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeUrbanExplorerWhereInput
  }

  /**
   * PlaceUrbanExplorerCountOutputType without action
   */
  export type PlaceUrbanExplorerCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUrbanExplorerWhereInput
  }


  /**
   * Count Type ReviewUrbanExplorerCountOutputType
   */

  export type ReviewUrbanExplorerCountOutputType = {
    reports: number
  }

  export type ReviewUrbanExplorerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ReviewUrbanExplorerCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ReviewUrbanExplorerCountOutputType without action
   */
  export type ReviewUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorerCountOutputType
     */
    select?: ReviewUrbanExplorerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewUrbanExplorerCountOutputType without action
   */
  export type ReviewUrbanExplorerCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUrbanExplorerWhereInput
  }


  /**
   * Count Type UserFoodieCountOutputType
   */

  export type UserFoodieCountOutputType = {
    FoodieFood: number
    FoodieLocation: number
    FoodieReview: number
    FoodieLike: number
  }

  export type UserFoodieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodieFood?: boolean | UserFoodieCountOutputTypeCountFoodieFoodArgs
    FoodieLocation?: boolean | UserFoodieCountOutputTypeCountFoodieLocationArgs
    FoodieReview?: boolean | UserFoodieCountOutputTypeCountFoodieReviewArgs
    FoodieLike?: boolean | UserFoodieCountOutputTypeCountFoodieLikeArgs
  }

  // Custom InputTypes
  /**
   * UserFoodieCountOutputType without action
   */
  export type UserFoodieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodieCountOutputType
     */
    select?: UserFoodieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserFoodieCountOutputType without action
   */
  export type UserFoodieCountOutputTypeCountFoodieFoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieFoodWhereInput
  }

  /**
   * UserFoodieCountOutputType without action
   */
  export type UserFoodieCountOutputTypeCountFoodieLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieLocationWhereInput
  }

  /**
   * UserFoodieCountOutputType without action
   */
  export type UserFoodieCountOutputTypeCountFoodieReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieReviewWhereInput
  }

  /**
   * UserFoodieCountOutputType without action
   */
  export type UserFoodieCountOutputTypeCountFoodieLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieLikeWhereInput
  }


  /**
   * Count Type FoodieFoodCountOutputType
   */

  export type FoodieFoodCountOutputType = {
    locations: number
    reviews: number
    likes: number
  }

  export type FoodieFoodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | FoodieFoodCountOutputTypeCountLocationsArgs
    reviews?: boolean | FoodieFoodCountOutputTypeCountReviewsArgs
    likes?: boolean | FoodieFoodCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * FoodieFoodCountOutputType without action
   */
  export type FoodieFoodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFoodCountOutputType
     */
    select?: FoodieFoodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodieFoodCountOutputType without action
   */
  export type FoodieFoodCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieLocationWhereInput
  }

  /**
   * FoodieFoodCountOutputType without action
   */
  export type FoodieFoodCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieReviewWhereInput
  }

  /**
   * FoodieFoodCountOutputType without action
   */
  export type FoodieFoodCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieLikeWhereInput
  }


  /**
   * Count Type UserPetLoverCountOutputType
   */

  export type UserPetLoverCountOutputType = {
    PetPetLover: number
    AppointmentPetLover: number
  }

  export type UserPetLoverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PetPetLover?: boolean | UserPetLoverCountOutputTypeCountPetPetLoverArgs
    AppointmentPetLover?: boolean | UserPetLoverCountOutputTypeCountAppointmentPetLoverArgs
  }

  // Custom InputTypes
  /**
   * UserPetLoverCountOutputType without action
   */
  export type UserPetLoverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLoverCountOutputType
     */
    select?: UserPetLoverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPetLoverCountOutputType without action
   */
  export type UserPetLoverCountOutputTypeCountPetPetLoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetPetLoverWhereInput
  }

  /**
   * UserPetLoverCountOutputType without action
   */
  export type UserPetLoverCountOutputTypeCountAppointmentPetLoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentPetLoverWhereInput
  }


  /**
   * Count Type PetPetLoverCountOutputType
   */

  export type PetPetLoverCountOutputType = {
    vaccinations: number
    appointments: number
  }

  export type PetPetLoverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinations?: boolean | PetPetLoverCountOutputTypeCountVaccinationsArgs
    appointments?: boolean | PetPetLoverCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * PetPetLoverCountOutputType without action
   */
  export type PetPetLoverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLoverCountOutputType
     */
    select?: PetPetLoverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PetPetLoverCountOutputType without action
   */
  export type PetPetLoverCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationPetLoverWhereInput
  }

  /**
   * PetPetLoverCountOutputType without action
   */
  export type PetPetLoverCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentPetLoverWhereInput
  }


  /**
   * Count Type UserElderlyCareCompanionCountOutputType
   */

  export type UserElderlyCareCompanionCountOutputType = {
    ElderlyCareCompanionAppointment: number
    ElderlyCareCompanionRecord: number
    ElderlyCareCompanionMedicationTracking: number
  }

  export type UserElderlyCareCompanionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ElderlyCareCompanionAppointment?: boolean | UserElderlyCareCompanionCountOutputTypeCountElderlyCareCompanionAppointmentArgs
    ElderlyCareCompanionRecord?: boolean | UserElderlyCareCompanionCountOutputTypeCountElderlyCareCompanionRecordArgs
    ElderlyCareCompanionMedicationTracking?: boolean | UserElderlyCareCompanionCountOutputTypeCountElderlyCareCompanionMedicationTrackingArgs
  }

  // Custom InputTypes
  /**
   * UserElderlyCareCompanionCountOutputType without action
   */
  export type UserElderlyCareCompanionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanionCountOutputType
     */
    select?: UserElderlyCareCompanionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserElderlyCareCompanionCountOutputType without action
   */
  export type UserElderlyCareCompanionCountOutputTypeCountElderlyCareCompanionAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionAppointmentWhereInput
  }

  /**
   * UserElderlyCareCompanionCountOutputType without action
   */
  export type UserElderlyCareCompanionCountOutputTypeCountElderlyCareCompanionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionRecordWhereInput
  }

  /**
   * UserElderlyCareCompanionCountOutputType without action
   */
  export type UserElderlyCareCompanionCountOutputTypeCountElderlyCareCompanionMedicationTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
  }


  /**
   * Count Type ElderlyCareCompanionAppointmentCountOutputType
   */

  export type ElderlyCareCompanionAppointmentCountOutputType = {
    medicationLogs: number
  }

  export type ElderlyCareCompanionAppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicationLogs?: boolean | ElderlyCareCompanionAppointmentCountOutputTypeCountMedicationLogsArgs
  }

  // Custom InputTypes
  /**
   * ElderlyCareCompanionAppointmentCountOutputType without action
   */
  export type ElderlyCareCompanionAppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointmentCountOutputType
     */
    select?: ElderlyCareCompanionAppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionAppointmentCountOutputType without action
   */
  export type ElderlyCareCompanionAppointmentCountOutputTypeCountMedicationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
  }


  /**
   * Count Type UserEduSeekerCountOutputType
   */

  export type UserEduSeekerCountOutputType = {
    platforms: number
    reviews: number
  }

  export type UserEduSeekerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platforms?: boolean | UserEduSeekerCountOutputTypeCountPlatformsArgs
    reviews?: boolean | UserEduSeekerCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserEduSeekerCountOutputType without action
   */
  export type UserEduSeekerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeekerCountOutputType
     */
    select?: UserEduSeekerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserEduSeekerCountOutputType without action
   */
  export type UserEduSeekerCountOutputTypeCountPlatformsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformEduSeekerWhereInput
  }

  /**
   * UserEduSeekerCountOutputType without action
   */
  export type UserEduSeekerCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewEduSeekerWhereInput
  }


  /**
   * Count Type PlatformEduSeekerCountOutputType
   */

  export type PlatformEduSeekerCountOutputType = {
    reviews: number
  }

  export type PlatformEduSeekerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | PlatformEduSeekerCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * PlatformEduSeekerCountOutputType without action
   */
  export type PlatformEduSeekerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeekerCountOutputType
     */
    select?: PlatformEduSeekerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlatformEduSeekerCountOutputType without action
   */
  export type PlatformEduSeekerCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewEduSeekerWhereInput
  }


  /**
   * Count Type UserFinanceManagerCountOutputType
   */

  export type UserFinanceManagerCountOutputType = {
    transactions: number
    goals: number
  }

  export type UserFinanceManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | UserFinanceManagerCountOutputTypeCountTransactionsArgs
    goals?: boolean | UserFinanceManagerCountOutputTypeCountGoalsArgs
  }

  // Custom InputTypes
  /**
   * UserFinanceManagerCountOutputType without action
   */
  export type UserFinanceManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManagerCountOutputType
     */
    select?: UserFinanceManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserFinanceManagerCountOutputType without action
   */
  export type UserFinanceManagerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionFinanceManagerWhereInput
  }

  /**
   * UserFinanceManagerCountOutputType without action
   */
  export type UserFinanceManagerCountOutputTypeCountGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalFinanceManagerWhereInput
  }


  /**
   * Count Type UserMentalWellnessCountOutputType
   */

  export type UserMentalWellnessCountOutputType = {
    journals: number
    assessments: number
    feedbacks: number
  }

  export type UserMentalWellnessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journals?: boolean | UserMentalWellnessCountOutputTypeCountJournalsArgs
    assessments?: boolean | UserMentalWellnessCountOutputTypeCountAssessmentsArgs
    feedbacks?: boolean | UserMentalWellnessCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * UserMentalWellnessCountOutputType without action
   */
  export type UserMentalWellnessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellnessCountOutputType
     */
    select?: UserMentalWellnessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserMentalWellnessCountOutputType without action
   */
  export type UserMentalWellnessCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalMentalWellnessWhereInput
  }

  /**
   * UserMentalWellnessCountOutputType without action
   */
  export type UserMentalWellnessCountOutputTypeCountAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentMentalWellnessWhereInput
  }

  /**
   * UserMentalWellnessCountOutputType without action
   */
  export type UserMentalWellnessCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeditationFeedbackWhereInput
  }


  /**
   * Count Type MeditationCountOutputType
   */

  export type MeditationCountOutputType = {
    feedbacks: number
  }

  export type MeditationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | MeditationCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * MeditationCountOutputType without action
   */
  export type MeditationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationCountOutputType
     */
    select?: MeditationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeditationCountOutputType without action
   */
  export type MeditationCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeditationFeedbackWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserDIYHomes
   */

  export type AggregateUserDIYHomes = {
    _count: UserDIYHomesCountAggregateOutputType | null
    _min: UserDIYHomesMinAggregateOutputType | null
    _max: UserDIYHomesMaxAggregateOutputType | null
  }

  export type UserDIYHomesMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserDIYHomesMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserDIYHomesCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserDIYHomesMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserDIYHomesMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserDIYHomesCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserDIYHomesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDIYHomes to aggregate.
     */
    where?: UserDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDIYHomes to fetch.
     */
    orderBy?: UserDIYHomesOrderByWithRelationInput | UserDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDIYHomes
    **/
    _count?: true | UserDIYHomesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDIYHomesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDIYHomesMaxAggregateInputType
  }

  export type GetUserDIYHomesAggregateType<T extends UserDIYHomesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDIYHomes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDIYHomes[P]>
      : GetScalarType<T[P], AggregateUserDIYHomes[P]>
  }




  export type UserDIYHomesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDIYHomesWhereInput
    orderBy?: UserDIYHomesOrderByWithAggregationInput | UserDIYHomesOrderByWithAggregationInput[]
    by: UserDIYHomesScalarFieldEnum[] | UserDIYHomesScalarFieldEnum
    having?: UserDIYHomesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDIYHomesCountAggregateInputType | true
    _min?: UserDIYHomesMinAggregateInputType
    _max?: UserDIYHomesMaxAggregateInputType
  }

  export type UserDIYHomesGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserDIYHomesCountAggregateOutputType | null
    _min: UserDIYHomesMinAggregateOutputType | null
    _max: UserDIYHomesMaxAggregateOutputType | null
  }

  type GetUserDIYHomesGroupByPayload<T extends UserDIYHomesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDIYHomesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDIYHomesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDIYHomesGroupByOutputType[P]>
            : GetScalarType<T[P], UserDIYHomesGroupByOutputType[P]>
        }
      >
    >


  export type UserDIYHomesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    PostDIYHomes?: boolean | UserDIYHomes$PostDIYHomesArgs<ExtArgs>
    ReviewDIYHomes?: boolean | UserDIYHomes$ReviewDIYHomesArgs<ExtArgs>
    LikeDIYHomes?: boolean | UserDIYHomes$LikeDIYHomesArgs<ExtArgs>
    BookmarkDIYHomes?: boolean | UserDIYHomes$BookmarkDIYHomesArgs<ExtArgs>
    ReportDIYHomes?: boolean | UserDIYHomes$ReportDIYHomesArgs<ExtArgs>
    _count?: boolean | UserDIYHomesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDIYHomes"]>

  export type UserDIYHomesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userDIYHomes"]>

  export type UserDIYHomesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userDIYHomes"]>

  export type UserDIYHomesSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserDIYHomesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userDIYHomes"]>
  export type UserDIYHomesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PostDIYHomes?: boolean | UserDIYHomes$PostDIYHomesArgs<ExtArgs>
    ReviewDIYHomes?: boolean | UserDIYHomes$ReviewDIYHomesArgs<ExtArgs>
    LikeDIYHomes?: boolean | UserDIYHomes$LikeDIYHomesArgs<ExtArgs>
    BookmarkDIYHomes?: boolean | UserDIYHomes$BookmarkDIYHomesArgs<ExtArgs>
    ReportDIYHomes?: boolean | UserDIYHomes$ReportDIYHomesArgs<ExtArgs>
    _count?: boolean | UserDIYHomesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserDIYHomesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserDIYHomesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserDIYHomesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDIYHomes"
    objects: {
      PostDIYHomes: Prisma.$PostDIYHomesPayload<ExtArgs>[]
      ReviewDIYHomes: Prisma.$ReviewDIYHomesPayload<ExtArgs>[]
      LikeDIYHomes: Prisma.$LikeDIYHomesPayload<ExtArgs>[]
      BookmarkDIYHomes: Prisma.$BookmarkDIYHomesPayload<ExtArgs>[]
      ReportDIYHomes: Prisma.$ReportDIYHomesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userDIYHomes"]>
    composites: {}
  }

  type UserDIYHomesGetPayload<S extends boolean | null | undefined | UserDIYHomesDefaultArgs> = $Result.GetResult<Prisma.$UserDIYHomesPayload, S>

  type UserDIYHomesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDIYHomesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDIYHomesCountAggregateInputType | true
    }

  export interface UserDIYHomesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDIYHomes'], meta: { name: 'UserDIYHomes' } }
    /**
     * Find zero or one UserDIYHomes that matches the filter.
     * @param {UserDIYHomesFindUniqueArgs} args - Arguments to find a UserDIYHomes
     * @example
     * // Get one UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDIYHomesFindUniqueArgs>(args: SelectSubset<T, UserDIYHomesFindUniqueArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDIYHomes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDIYHomesFindUniqueOrThrowArgs} args - Arguments to find a UserDIYHomes
     * @example
     * // Get one UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDIYHomesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDIYHomesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesFindFirstArgs} args - Arguments to find a UserDIYHomes
     * @example
     * // Get one UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDIYHomesFindFirstArgs>(args?: SelectSubset<T, UserDIYHomesFindFirstArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDIYHomes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesFindFirstOrThrowArgs} args - Arguments to find a UserDIYHomes
     * @example
     * // Get one UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDIYHomesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDIYHomesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.findMany()
     * 
     * // Get first 10 UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDIYHomesWithIdOnly = await prisma.userDIYHomes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDIYHomesFindManyArgs>(args?: SelectSubset<T, UserDIYHomesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDIYHomes.
     * @param {UserDIYHomesCreateArgs} args - Arguments to create a UserDIYHomes.
     * @example
     * // Create one UserDIYHomes
     * const UserDIYHomes = await prisma.userDIYHomes.create({
     *   data: {
     *     // ... data to create a UserDIYHomes
     *   }
     * })
     * 
     */
    create<T extends UserDIYHomesCreateArgs>(args: SelectSubset<T, UserDIYHomesCreateArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDIYHomes.
     * @param {UserDIYHomesCreateManyArgs} args - Arguments to create many UserDIYHomes.
     * @example
     * // Create many UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDIYHomesCreateManyArgs>(args?: SelectSubset<T, UserDIYHomesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDIYHomes and returns the data saved in the database.
     * @param {UserDIYHomesCreateManyAndReturnArgs} args - Arguments to create many UserDIYHomes.
     * @example
     * // Create many UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDIYHomes and only return the `id`
     * const userDIYHomesWithIdOnly = await prisma.userDIYHomes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDIYHomesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDIYHomesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDIYHomes.
     * @param {UserDIYHomesDeleteArgs} args - Arguments to delete one UserDIYHomes.
     * @example
     * // Delete one UserDIYHomes
     * const UserDIYHomes = await prisma.userDIYHomes.delete({
     *   where: {
     *     // ... filter to delete one UserDIYHomes
     *   }
     * })
     * 
     */
    delete<T extends UserDIYHomesDeleteArgs>(args: SelectSubset<T, UserDIYHomesDeleteArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDIYHomes.
     * @param {UserDIYHomesUpdateArgs} args - Arguments to update one UserDIYHomes.
     * @example
     * // Update one UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDIYHomesUpdateArgs>(args: SelectSubset<T, UserDIYHomesUpdateArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDIYHomes.
     * @param {UserDIYHomesDeleteManyArgs} args - Arguments to filter UserDIYHomes to delete.
     * @example
     * // Delete a few UserDIYHomes
     * const { count } = await prisma.userDIYHomes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDIYHomesDeleteManyArgs>(args?: SelectSubset<T, UserDIYHomesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDIYHomesUpdateManyArgs>(args: SelectSubset<T, UserDIYHomesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDIYHomes and returns the data updated in the database.
     * @param {UserDIYHomesUpdateManyAndReturnArgs} args - Arguments to update many UserDIYHomes.
     * @example
     * // Update many UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDIYHomes and only return the `id`
     * const userDIYHomesWithIdOnly = await prisma.userDIYHomes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDIYHomesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDIYHomesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDIYHomes.
     * @param {UserDIYHomesUpsertArgs} args - Arguments to update or create a UserDIYHomes.
     * @example
     * // Update or create a UserDIYHomes
     * const userDIYHomes = await prisma.userDIYHomes.upsert({
     *   create: {
     *     // ... data to create a UserDIYHomes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDIYHomes we want to update
     *   }
     * })
     */
    upsert<T extends UserDIYHomesUpsertArgs>(args: SelectSubset<T, UserDIYHomesUpsertArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesCountArgs} args - Arguments to filter UserDIYHomes to count.
     * @example
     * // Count the number of UserDIYHomes
     * const count = await prisma.userDIYHomes.count({
     *   where: {
     *     // ... the filter for the UserDIYHomes we want to count
     *   }
     * })
    **/
    count<T extends UserDIYHomesCountArgs>(
      args?: Subset<T, UserDIYHomesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDIYHomesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDIYHomesAggregateArgs>(args: Subset<T, UserDIYHomesAggregateArgs>): Prisma.PrismaPromise<GetUserDIYHomesAggregateType<T>>

    /**
     * Group by UserDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDIYHomesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDIYHomesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDIYHomesGroupByArgs['orderBy'] }
        : { orderBy?: UserDIYHomesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDIYHomesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDIYHomesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDIYHomes model
   */
  readonly fields: UserDIYHomesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDIYHomes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDIYHomesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PostDIYHomes<T extends UserDIYHomes$PostDIYHomesArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomes$PostDIYHomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReviewDIYHomes<T extends UserDIYHomes$ReviewDIYHomesArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomes$ReviewDIYHomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LikeDIYHomes<T extends UserDIYHomes$LikeDIYHomesArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomes$LikeDIYHomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BookmarkDIYHomes<T extends UserDIYHomes$BookmarkDIYHomesArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomes$BookmarkDIYHomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReportDIYHomes<T extends UserDIYHomes$ReportDIYHomesArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomes$ReportDIYHomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDIYHomes model
   */ 
  interface UserDIYHomesFieldRefs {
    readonly id: FieldRef<"UserDIYHomes", 'String'>
    readonly email: FieldRef<"UserDIYHomes", 'String'>
    readonly name: FieldRef<"UserDIYHomes", 'String'>
    readonly password: FieldRef<"UserDIYHomes", 'String'>
    readonly createdAt: FieldRef<"UserDIYHomes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserDIYHomes findUnique
   */
  export type UserDIYHomesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which UserDIYHomes to fetch.
     */
    where: UserDIYHomesWhereUniqueInput
  }

  /**
   * UserDIYHomes findUniqueOrThrow
   */
  export type UserDIYHomesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which UserDIYHomes to fetch.
     */
    where: UserDIYHomesWhereUniqueInput
  }

  /**
   * UserDIYHomes findFirst
   */
  export type UserDIYHomesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which UserDIYHomes to fetch.
     */
    where?: UserDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDIYHomes to fetch.
     */
    orderBy?: UserDIYHomesOrderByWithRelationInput | UserDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDIYHomes.
     */
    cursor?: UserDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDIYHomes.
     */
    distinct?: UserDIYHomesScalarFieldEnum | UserDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes findFirstOrThrow
   */
  export type UserDIYHomesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which UserDIYHomes to fetch.
     */
    where?: UserDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDIYHomes to fetch.
     */
    orderBy?: UserDIYHomesOrderByWithRelationInput | UserDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDIYHomes.
     */
    cursor?: UserDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDIYHomes.
     */
    distinct?: UserDIYHomesScalarFieldEnum | UserDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes findMany
   */
  export type UserDIYHomesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which UserDIYHomes to fetch.
     */
    where?: UserDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDIYHomes to fetch.
     */
    orderBy?: UserDIYHomesOrderByWithRelationInput | UserDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDIYHomes.
     */
    cursor?: UserDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDIYHomes.
     */
    skip?: number
    distinct?: UserDIYHomesScalarFieldEnum | UserDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes create
   */
  export type UserDIYHomesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDIYHomes.
     */
    data: XOR<UserDIYHomesCreateInput, UserDIYHomesUncheckedCreateInput>
  }

  /**
   * UserDIYHomes createMany
   */
  export type UserDIYHomesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDIYHomes.
     */
    data: UserDIYHomesCreateManyInput | UserDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDIYHomes createManyAndReturn
   */
  export type UserDIYHomesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to create many UserDIYHomes.
     */
    data: UserDIYHomesCreateManyInput | UserDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDIYHomes update
   */
  export type UserDIYHomesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDIYHomes.
     */
    data: XOR<UserDIYHomesUpdateInput, UserDIYHomesUncheckedUpdateInput>
    /**
     * Choose, which UserDIYHomes to update.
     */
    where: UserDIYHomesWhereUniqueInput
  }

  /**
   * UserDIYHomes updateMany
   */
  export type UserDIYHomesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDIYHomes.
     */
    data: XOR<UserDIYHomesUpdateManyMutationInput, UserDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which UserDIYHomes to update
     */
    where?: UserDIYHomesWhereInput
    /**
     * Limit how many UserDIYHomes to update.
     */
    limit?: number
  }

  /**
   * UserDIYHomes updateManyAndReturn
   */
  export type UserDIYHomesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to update UserDIYHomes.
     */
    data: XOR<UserDIYHomesUpdateManyMutationInput, UserDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which UserDIYHomes to update
     */
    where?: UserDIYHomesWhereInput
    /**
     * Limit how many UserDIYHomes to update.
     */
    limit?: number
  }

  /**
   * UserDIYHomes upsert
   */
  export type UserDIYHomesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDIYHomes to update in case it exists.
     */
    where: UserDIYHomesWhereUniqueInput
    /**
     * In case the UserDIYHomes found by the `where` argument doesn't exist, create a new UserDIYHomes with this data.
     */
    create: XOR<UserDIYHomesCreateInput, UserDIYHomesUncheckedCreateInput>
    /**
     * In case the UserDIYHomes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDIYHomesUpdateInput, UserDIYHomesUncheckedUpdateInput>
  }

  /**
   * UserDIYHomes delete
   */
  export type UserDIYHomesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
    /**
     * Filter which UserDIYHomes to delete.
     */
    where: UserDIYHomesWhereUniqueInput
  }

  /**
   * UserDIYHomes deleteMany
   */
  export type UserDIYHomesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDIYHomes to delete
     */
    where?: UserDIYHomesWhereInput
    /**
     * Limit how many UserDIYHomes to delete.
     */
    limit?: number
  }

  /**
   * UserDIYHomes.PostDIYHomes
   */
  export type UserDIYHomes$PostDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    where?: PostDIYHomesWhereInput
    orderBy?: PostDIYHomesOrderByWithRelationInput | PostDIYHomesOrderByWithRelationInput[]
    cursor?: PostDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostDIYHomesScalarFieldEnum | PostDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes.ReviewDIYHomes
   */
  export type UserDIYHomes$ReviewDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    where?: ReviewDIYHomesWhereInput
    orderBy?: ReviewDIYHomesOrderByWithRelationInput | ReviewDIYHomesOrderByWithRelationInput[]
    cursor?: ReviewDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewDIYHomesScalarFieldEnum | ReviewDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes.LikeDIYHomes
   */
  export type UserDIYHomes$LikeDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    where?: LikeDIYHomesWhereInput
    orderBy?: LikeDIYHomesOrderByWithRelationInput | LikeDIYHomesOrderByWithRelationInput[]
    cursor?: LikeDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeDIYHomesScalarFieldEnum | LikeDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes.BookmarkDIYHomes
   */
  export type UserDIYHomes$BookmarkDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    where?: BookmarkDIYHomesWhereInput
    orderBy?: BookmarkDIYHomesOrderByWithRelationInput | BookmarkDIYHomesOrderByWithRelationInput[]
    cursor?: BookmarkDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkDIYHomesScalarFieldEnum | BookmarkDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes.ReportDIYHomes
   */
  export type UserDIYHomes$ReportDIYHomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    where?: ReportDIYHomesWhereInput
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    cursor?: ReportDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportDIYHomesScalarFieldEnum | ReportDIYHomesScalarFieldEnum[]
  }

  /**
   * UserDIYHomes without action
   */
  export type UserDIYHomesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDIYHomes
     */
    select?: UserDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDIYHomes
     */
    omit?: UserDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDIYHomesInclude<ExtArgs> | null
  }


  /**
   * Model PostDIYHomes
   */

  export type AggregatePostDIYHomes = {
    _count: PostDIYHomesCountAggregateOutputType | null
    _min: PostDIYHomesMinAggregateOutputType | null
    _max: PostDIYHomesMaxAggregateOutputType | null
  }

  export type PostDIYHomesMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    category: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PostDIYHomesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    category: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PostDIYHomesCountAggregateOutputType = {
    id: number
    title: number
    content: number
    category: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PostDIYHomesMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    category?: true
    userId?: true
    createdAt?: true
  }

  export type PostDIYHomesMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    category?: true
    userId?: true
    createdAt?: true
  }

  export type PostDIYHomesCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    category?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PostDIYHomesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostDIYHomes to aggregate.
     */
    where?: PostDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDIYHomes to fetch.
     */
    orderBy?: PostDIYHomesOrderByWithRelationInput | PostDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostDIYHomes
    **/
    _count?: true | PostDIYHomesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostDIYHomesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostDIYHomesMaxAggregateInputType
  }

  export type GetPostDIYHomesAggregateType<T extends PostDIYHomesAggregateArgs> = {
        [P in keyof T & keyof AggregatePostDIYHomes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostDIYHomes[P]>
      : GetScalarType<T[P], AggregatePostDIYHomes[P]>
  }




  export type PostDIYHomesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostDIYHomesWhereInput
    orderBy?: PostDIYHomesOrderByWithAggregationInput | PostDIYHomesOrderByWithAggregationInput[]
    by: PostDIYHomesScalarFieldEnum[] | PostDIYHomesScalarFieldEnum
    having?: PostDIYHomesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostDIYHomesCountAggregateInputType | true
    _min?: PostDIYHomesMinAggregateInputType
    _max?: PostDIYHomesMaxAggregateInputType
  }

  export type PostDIYHomesGroupByOutputType = {
    id: string
    title: string
    content: string
    category: string
    userId: string
    createdAt: Date
    _count: PostDIYHomesCountAggregateOutputType | null
    _min: PostDIYHomesMinAggregateOutputType | null
    _max: PostDIYHomesMaxAggregateOutputType | null
  }

  type GetPostDIYHomesGroupByPayload<T extends PostDIYHomesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostDIYHomesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostDIYHomesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostDIYHomesGroupByOutputType[P]>
            : GetScalarType<T[P], PostDIYHomesGroupByOutputType[P]>
        }
      >
    >


  export type PostDIYHomesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    reviews?: boolean | PostDIYHomes$reviewsArgs<ExtArgs>
    bookmarks?: boolean | PostDIYHomes$bookmarksArgs<ExtArgs>
    Like?: boolean | PostDIYHomes$LikeArgs<ExtArgs>
    Report?: boolean | PostDIYHomes$ReportArgs<ExtArgs>
    _count?: boolean | PostDIYHomesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postDIYHomes"]>

  export type PostDIYHomesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postDIYHomes"]>

  export type PostDIYHomesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postDIYHomes"]>

  export type PostDIYHomesSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PostDIYHomesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "category" | "userId" | "createdAt", ExtArgs["result"]["postDIYHomes"]>
  export type PostDIYHomesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    reviews?: boolean | PostDIYHomes$reviewsArgs<ExtArgs>
    bookmarks?: boolean | PostDIYHomes$bookmarksArgs<ExtArgs>
    Like?: boolean | PostDIYHomes$LikeArgs<ExtArgs>
    Report?: boolean | PostDIYHomes$ReportArgs<ExtArgs>
    _count?: boolean | PostDIYHomesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostDIYHomesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
  }
  export type PostDIYHomesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
  }

  export type $PostDIYHomesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostDIYHomes"
    objects: {
      user: Prisma.$UserDIYHomesPayload<ExtArgs>
      reviews: Prisma.$ReviewDIYHomesPayload<ExtArgs>[]
      bookmarks: Prisma.$BookmarkDIYHomesPayload<ExtArgs>[]
      Like: Prisma.$LikeDIYHomesPayload<ExtArgs>[]
      Report: Prisma.$ReportDIYHomesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      category: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["postDIYHomes"]>
    composites: {}
  }

  type PostDIYHomesGetPayload<S extends boolean | null | undefined | PostDIYHomesDefaultArgs> = $Result.GetResult<Prisma.$PostDIYHomesPayload, S>

  type PostDIYHomesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostDIYHomesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostDIYHomesCountAggregateInputType | true
    }

  export interface PostDIYHomesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostDIYHomes'], meta: { name: 'PostDIYHomes' } }
    /**
     * Find zero or one PostDIYHomes that matches the filter.
     * @param {PostDIYHomesFindUniqueArgs} args - Arguments to find a PostDIYHomes
     * @example
     * // Get one PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostDIYHomesFindUniqueArgs>(args: SelectSubset<T, PostDIYHomesFindUniqueArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostDIYHomes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostDIYHomesFindUniqueOrThrowArgs} args - Arguments to find a PostDIYHomes
     * @example
     * // Get one PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostDIYHomesFindUniqueOrThrowArgs>(args: SelectSubset<T, PostDIYHomesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesFindFirstArgs} args - Arguments to find a PostDIYHomes
     * @example
     * // Get one PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostDIYHomesFindFirstArgs>(args?: SelectSubset<T, PostDIYHomesFindFirstArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostDIYHomes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesFindFirstOrThrowArgs} args - Arguments to find a PostDIYHomes
     * @example
     * // Get one PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostDIYHomesFindFirstOrThrowArgs>(args?: SelectSubset<T, PostDIYHomesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.findMany()
     * 
     * // Get first 10 PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postDIYHomesWithIdOnly = await prisma.postDIYHomes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostDIYHomesFindManyArgs>(args?: SelectSubset<T, PostDIYHomesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostDIYHomes.
     * @param {PostDIYHomesCreateArgs} args - Arguments to create a PostDIYHomes.
     * @example
     * // Create one PostDIYHomes
     * const PostDIYHomes = await prisma.postDIYHomes.create({
     *   data: {
     *     // ... data to create a PostDIYHomes
     *   }
     * })
     * 
     */
    create<T extends PostDIYHomesCreateArgs>(args: SelectSubset<T, PostDIYHomesCreateArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostDIYHomes.
     * @param {PostDIYHomesCreateManyArgs} args - Arguments to create many PostDIYHomes.
     * @example
     * // Create many PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostDIYHomesCreateManyArgs>(args?: SelectSubset<T, PostDIYHomesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostDIYHomes and returns the data saved in the database.
     * @param {PostDIYHomesCreateManyAndReturnArgs} args - Arguments to create many PostDIYHomes.
     * @example
     * // Create many PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostDIYHomes and only return the `id`
     * const postDIYHomesWithIdOnly = await prisma.postDIYHomes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostDIYHomesCreateManyAndReturnArgs>(args?: SelectSubset<T, PostDIYHomesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostDIYHomes.
     * @param {PostDIYHomesDeleteArgs} args - Arguments to delete one PostDIYHomes.
     * @example
     * // Delete one PostDIYHomes
     * const PostDIYHomes = await prisma.postDIYHomes.delete({
     *   where: {
     *     // ... filter to delete one PostDIYHomes
     *   }
     * })
     * 
     */
    delete<T extends PostDIYHomesDeleteArgs>(args: SelectSubset<T, PostDIYHomesDeleteArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostDIYHomes.
     * @param {PostDIYHomesUpdateArgs} args - Arguments to update one PostDIYHomes.
     * @example
     * // Update one PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostDIYHomesUpdateArgs>(args: SelectSubset<T, PostDIYHomesUpdateArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostDIYHomes.
     * @param {PostDIYHomesDeleteManyArgs} args - Arguments to filter PostDIYHomes to delete.
     * @example
     * // Delete a few PostDIYHomes
     * const { count } = await prisma.postDIYHomes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDIYHomesDeleteManyArgs>(args?: SelectSubset<T, PostDIYHomesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostDIYHomesUpdateManyArgs>(args: SelectSubset<T, PostDIYHomesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostDIYHomes and returns the data updated in the database.
     * @param {PostDIYHomesUpdateManyAndReturnArgs} args - Arguments to update many PostDIYHomes.
     * @example
     * // Update many PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostDIYHomes and only return the `id`
     * const postDIYHomesWithIdOnly = await prisma.postDIYHomes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostDIYHomesUpdateManyAndReturnArgs>(args: SelectSubset<T, PostDIYHomesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostDIYHomes.
     * @param {PostDIYHomesUpsertArgs} args - Arguments to update or create a PostDIYHomes.
     * @example
     * // Update or create a PostDIYHomes
     * const postDIYHomes = await prisma.postDIYHomes.upsert({
     *   create: {
     *     // ... data to create a PostDIYHomes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostDIYHomes we want to update
     *   }
     * })
     */
    upsert<T extends PostDIYHomesUpsertArgs>(args: SelectSubset<T, PostDIYHomesUpsertArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesCountArgs} args - Arguments to filter PostDIYHomes to count.
     * @example
     * // Count the number of PostDIYHomes
     * const count = await prisma.postDIYHomes.count({
     *   where: {
     *     // ... the filter for the PostDIYHomes we want to count
     *   }
     * })
    **/
    count<T extends PostDIYHomesCountArgs>(
      args?: Subset<T, PostDIYHomesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostDIYHomesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostDIYHomesAggregateArgs>(args: Subset<T, PostDIYHomesAggregateArgs>): Prisma.PrismaPromise<GetPostDIYHomesAggregateType<T>>

    /**
     * Group by PostDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostDIYHomesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostDIYHomesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostDIYHomesGroupByArgs['orderBy'] }
        : { orderBy?: PostDIYHomesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostDIYHomesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostDIYHomesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostDIYHomes model
   */
  readonly fields: PostDIYHomesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostDIYHomes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostDIYHomesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomesDefaultArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends PostDIYHomes$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomes$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookmarks<T extends PostDIYHomes$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomes$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Like<T extends PostDIYHomes$LikeArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomes$LikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Report<T extends PostDIYHomes$ReportArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomes$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostDIYHomes model
   */ 
  interface PostDIYHomesFieldRefs {
    readonly id: FieldRef<"PostDIYHomes", 'String'>
    readonly title: FieldRef<"PostDIYHomes", 'String'>
    readonly content: FieldRef<"PostDIYHomes", 'String'>
    readonly category: FieldRef<"PostDIYHomes", 'String'>
    readonly userId: FieldRef<"PostDIYHomes", 'String'>
    readonly createdAt: FieldRef<"PostDIYHomes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostDIYHomes findUnique
   */
  export type PostDIYHomesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which PostDIYHomes to fetch.
     */
    where: PostDIYHomesWhereUniqueInput
  }

  /**
   * PostDIYHomes findUniqueOrThrow
   */
  export type PostDIYHomesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which PostDIYHomes to fetch.
     */
    where: PostDIYHomesWhereUniqueInput
  }

  /**
   * PostDIYHomes findFirst
   */
  export type PostDIYHomesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which PostDIYHomes to fetch.
     */
    where?: PostDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDIYHomes to fetch.
     */
    orderBy?: PostDIYHomesOrderByWithRelationInput | PostDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostDIYHomes.
     */
    cursor?: PostDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostDIYHomes.
     */
    distinct?: PostDIYHomesScalarFieldEnum | PostDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes findFirstOrThrow
   */
  export type PostDIYHomesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which PostDIYHomes to fetch.
     */
    where?: PostDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDIYHomes to fetch.
     */
    orderBy?: PostDIYHomesOrderByWithRelationInput | PostDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostDIYHomes.
     */
    cursor?: PostDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostDIYHomes.
     */
    distinct?: PostDIYHomesScalarFieldEnum | PostDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes findMany
   */
  export type PostDIYHomesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which PostDIYHomes to fetch.
     */
    where?: PostDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostDIYHomes to fetch.
     */
    orderBy?: PostDIYHomesOrderByWithRelationInput | PostDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostDIYHomes.
     */
    cursor?: PostDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostDIYHomes.
     */
    skip?: number
    distinct?: PostDIYHomesScalarFieldEnum | PostDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes create
   */
  export type PostDIYHomesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to create a PostDIYHomes.
     */
    data: XOR<PostDIYHomesCreateInput, PostDIYHomesUncheckedCreateInput>
  }

  /**
   * PostDIYHomes createMany
   */
  export type PostDIYHomesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostDIYHomes.
     */
    data: PostDIYHomesCreateManyInput | PostDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostDIYHomes createManyAndReturn
   */
  export type PostDIYHomesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to create many PostDIYHomes.
     */
    data: PostDIYHomesCreateManyInput | PostDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostDIYHomes update
   */
  export type PostDIYHomesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to update a PostDIYHomes.
     */
    data: XOR<PostDIYHomesUpdateInput, PostDIYHomesUncheckedUpdateInput>
    /**
     * Choose, which PostDIYHomes to update.
     */
    where: PostDIYHomesWhereUniqueInput
  }

  /**
   * PostDIYHomes updateMany
   */
  export type PostDIYHomesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostDIYHomes.
     */
    data: XOR<PostDIYHomesUpdateManyMutationInput, PostDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which PostDIYHomes to update
     */
    where?: PostDIYHomesWhereInput
    /**
     * Limit how many PostDIYHomes to update.
     */
    limit?: number
  }

  /**
   * PostDIYHomes updateManyAndReturn
   */
  export type PostDIYHomesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to update PostDIYHomes.
     */
    data: XOR<PostDIYHomesUpdateManyMutationInput, PostDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which PostDIYHomes to update
     */
    where?: PostDIYHomesWhereInput
    /**
     * Limit how many PostDIYHomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostDIYHomes upsert
   */
  export type PostDIYHomesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * The filter to search for the PostDIYHomes to update in case it exists.
     */
    where: PostDIYHomesWhereUniqueInput
    /**
     * In case the PostDIYHomes found by the `where` argument doesn't exist, create a new PostDIYHomes with this data.
     */
    create: XOR<PostDIYHomesCreateInput, PostDIYHomesUncheckedCreateInput>
    /**
     * In case the PostDIYHomes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostDIYHomesUpdateInput, PostDIYHomesUncheckedUpdateInput>
  }

  /**
   * PostDIYHomes delete
   */
  export type PostDIYHomesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    /**
     * Filter which PostDIYHomes to delete.
     */
    where: PostDIYHomesWhereUniqueInput
  }

  /**
   * PostDIYHomes deleteMany
   */
  export type PostDIYHomesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostDIYHomes to delete
     */
    where?: PostDIYHomesWhereInput
    /**
     * Limit how many PostDIYHomes to delete.
     */
    limit?: number
  }

  /**
   * PostDIYHomes.reviews
   */
  export type PostDIYHomes$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    where?: ReviewDIYHomesWhereInput
    orderBy?: ReviewDIYHomesOrderByWithRelationInput | ReviewDIYHomesOrderByWithRelationInput[]
    cursor?: ReviewDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewDIYHomesScalarFieldEnum | ReviewDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes.bookmarks
   */
  export type PostDIYHomes$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    where?: BookmarkDIYHomesWhereInput
    orderBy?: BookmarkDIYHomesOrderByWithRelationInput | BookmarkDIYHomesOrderByWithRelationInput[]
    cursor?: BookmarkDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkDIYHomesScalarFieldEnum | BookmarkDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes.Like
   */
  export type PostDIYHomes$LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    where?: LikeDIYHomesWhereInput
    orderBy?: LikeDIYHomesOrderByWithRelationInput | LikeDIYHomesOrderByWithRelationInput[]
    cursor?: LikeDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeDIYHomesScalarFieldEnum | LikeDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes.Report
   */
  export type PostDIYHomes$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    where?: ReportDIYHomesWhereInput
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    cursor?: ReportDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportDIYHomesScalarFieldEnum | ReportDIYHomesScalarFieldEnum[]
  }

  /**
   * PostDIYHomes without action
   */
  export type PostDIYHomesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
  }


  /**
   * Model ReviewDIYHomes
   */

  export type AggregateReviewDIYHomes = {
    _count: ReviewDIYHomesCountAggregateOutputType | null
    _avg: ReviewDIYHomesAvgAggregateOutputType | null
    _sum: ReviewDIYHomesSumAggregateOutputType | null
    _min: ReviewDIYHomesMinAggregateOutputType | null
    _max: ReviewDIYHomesMaxAggregateOutputType | null
  }

  export type ReviewDIYHomesAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewDIYHomesSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewDIYHomesMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewDIYHomesMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewDIYHomesCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ReviewDIYHomesAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewDIYHomesSumAggregateInputType = {
    rating?: true
  }

  export type ReviewDIYHomesMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewDIYHomesMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewDIYHomesCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewDIYHomesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewDIYHomes to aggregate.
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewDIYHomes to fetch.
     */
    orderBy?: ReviewDIYHomesOrderByWithRelationInput | ReviewDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewDIYHomes
    **/
    _count?: true | ReviewDIYHomesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewDIYHomesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewDIYHomesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewDIYHomesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewDIYHomesMaxAggregateInputType
  }

  export type GetReviewDIYHomesAggregateType<T extends ReviewDIYHomesAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewDIYHomes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewDIYHomes[P]>
      : GetScalarType<T[P], AggregateReviewDIYHomes[P]>
  }




  export type ReviewDIYHomesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewDIYHomesWhereInput
    orderBy?: ReviewDIYHomesOrderByWithAggregationInput | ReviewDIYHomesOrderByWithAggregationInput[]
    by: ReviewDIYHomesScalarFieldEnum[] | ReviewDIYHomesScalarFieldEnum
    having?: ReviewDIYHomesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewDIYHomesCountAggregateInputType | true
    _avg?: ReviewDIYHomesAvgAggregateInputType
    _sum?: ReviewDIYHomesSumAggregateInputType
    _min?: ReviewDIYHomesMinAggregateInputType
    _max?: ReviewDIYHomesMaxAggregateInputType
  }

  export type ReviewDIYHomesGroupByOutputType = {
    id: string
    postId: string
    userId: string
    rating: number
    comment: string
    createdAt: Date
    _count: ReviewDIYHomesCountAggregateOutputType | null
    _avg: ReviewDIYHomesAvgAggregateOutputType | null
    _sum: ReviewDIYHomesSumAggregateOutputType | null
    _min: ReviewDIYHomesMinAggregateOutputType | null
    _max: ReviewDIYHomesMaxAggregateOutputType | null
  }

  type GetReviewDIYHomesGroupByPayload<T extends ReviewDIYHomesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewDIYHomesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewDIYHomesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewDIYHomesGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewDIYHomesGroupByOutputType[P]>
        }
      >
    >


  export type ReviewDIYHomesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
    Report?: boolean | ReviewDIYHomes$ReportArgs<ExtArgs>
    _count?: boolean | ReviewDIYHomesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewDIYHomes"]>

  export type ReviewDIYHomesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewDIYHomes"]>

  export type ReviewDIYHomesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewDIYHomes"]>

  export type ReviewDIYHomesSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ReviewDIYHomesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["reviewDIYHomes"]>
  export type ReviewDIYHomesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
    Report?: boolean | ReviewDIYHomes$ReportArgs<ExtArgs>
    _count?: boolean | ReviewDIYHomesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewDIYHomesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }
  export type ReviewDIYHomesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }

  export type $ReviewDIYHomesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewDIYHomes"
    objects: {
      user: Prisma.$UserDIYHomesPayload<ExtArgs>
      post: Prisma.$PostDIYHomesPayload<ExtArgs>
      Report: Prisma.$ReportDIYHomesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      rating: number
      comment: string
      createdAt: Date
    }, ExtArgs["result"]["reviewDIYHomes"]>
    composites: {}
  }

  type ReviewDIYHomesGetPayload<S extends boolean | null | undefined | ReviewDIYHomesDefaultArgs> = $Result.GetResult<Prisma.$ReviewDIYHomesPayload, S>

  type ReviewDIYHomesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewDIYHomesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewDIYHomesCountAggregateInputType | true
    }

  export interface ReviewDIYHomesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewDIYHomes'], meta: { name: 'ReviewDIYHomes' } }
    /**
     * Find zero or one ReviewDIYHomes that matches the filter.
     * @param {ReviewDIYHomesFindUniqueArgs} args - Arguments to find a ReviewDIYHomes
     * @example
     * // Get one ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewDIYHomesFindUniqueArgs>(args: SelectSubset<T, ReviewDIYHomesFindUniqueArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewDIYHomes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewDIYHomesFindUniqueOrThrowArgs} args - Arguments to find a ReviewDIYHomes
     * @example
     * // Get one ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewDIYHomesFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewDIYHomesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesFindFirstArgs} args - Arguments to find a ReviewDIYHomes
     * @example
     * // Get one ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewDIYHomesFindFirstArgs>(args?: SelectSubset<T, ReviewDIYHomesFindFirstArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewDIYHomes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesFindFirstOrThrowArgs} args - Arguments to find a ReviewDIYHomes
     * @example
     * // Get one ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewDIYHomesFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewDIYHomesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.findMany()
     * 
     * // Get first 10 ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewDIYHomesWithIdOnly = await prisma.reviewDIYHomes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewDIYHomesFindManyArgs>(args?: SelectSubset<T, ReviewDIYHomesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewDIYHomes.
     * @param {ReviewDIYHomesCreateArgs} args - Arguments to create a ReviewDIYHomes.
     * @example
     * // Create one ReviewDIYHomes
     * const ReviewDIYHomes = await prisma.reviewDIYHomes.create({
     *   data: {
     *     // ... data to create a ReviewDIYHomes
     *   }
     * })
     * 
     */
    create<T extends ReviewDIYHomesCreateArgs>(args: SelectSubset<T, ReviewDIYHomesCreateArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewDIYHomes.
     * @param {ReviewDIYHomesCreateManyArgs} args - Arguments to create many ReviewDIYHomes.
     * @example
     * // Create many ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewDIYHomesCreateManyArgs>(args?: SelectSubset<T, ReviewDIYHomesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewDIYHomes and returns the data saved in the database.
     * @param {ReviewDIYHomesCreateManyAndReturnArgs} args - Arguments to create many ReviewDIYHomes.
     * @example
     * // Create many ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewDIYHomes and only return the `id`
     * const reviewDIYHomesWithIdOnly = await prisma.reviewDIYHomes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewDIYHomesCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewDIYHomesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewDIYHomes.
     * @param {ReviewDIYHomesDeleteArgs} args - Arguments to delete one ReviewDIYHomes.
     * @example
     * // Delete one ReviewDIYHomes
     * const ReviewDIYHomes = await prisma.reviewDIYHomes.delete({
     *   where: {
     *     // ... filter to delete one ReviewDIYHomes
     *   }
     * })
     * 
     */
    delete<T extends ReviewDIYHomesDeleteArgs>(args: SelectSubset<T, ReviewDIYHomesDeleteArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewDIYHomes.
     * @param {ReviewDIYHomesUpdateArgs} args - Arguments to update one ReviewDIYHomes.
     * @example
     * // Update one ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewDIYHomesUpdateArgs>(args: SelectSubset<T, ReviewDIYHomesUpdateArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewDIYHomes.
     * @param {ReviewDIYHomesDeleteManyArgs} args - Arguments to filter ReviewDIYHomes to delete.
     * @example
     * // Delete a few ReviewDIYHomes
     * const { count } = await prisma.reviewDIYHomes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDIYHomesDeleteManyArgs>(args?: SelectSubset<T, ReviewDIYHomesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewDIYHomesUpdateManyArgs>(args: SelectSubset<T, ReviewDIYHomesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewDIYHomes and returns the data updated in the database.
     * @param {ReviewDIYHomesUpdateManyAndReturnArgs} args - Arguments to update many ReviewDIYHomes.
     * @example
     * // Update many ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewDIYHomes and only return the `id`
     * const reviewDIYHomesWithIdOnly = await prisma.reviewDIYHomes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewDIYHomesUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewDIYHomesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewDIYHomes.
     * @param {ReviewDIYHomesUpsertArgs} args - Arguments to update or create a ReviewDIYHomes.
     * @example
     * // Update or create a ReviewDIYHomes
     * const reviewDIYHomes = await prisma.reviewDIYHomes.upsert({
     *   create: {
     *     // ... data to create a ReviewDIYHomes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewDIYHomes we want to update
     *   }
     * })
     */
    upsert<T extends ReviewDIYHomesUpsertArgs>(args: SelectSubset<T, ReviewDIYHomesUpsertArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesCountArgs} args - Arguments to filter ReviewDIYHomes to count.
     * @example
     * // Count the number of ReviewDIYHomes
     * const count = await prisma.reviewDIYHomes.count({
     *   where: {
     *     // ... the filter for the ReviewDIYHomes we want to count
     *   }
     * })
    **/
    count<T extends ReviewDIYHomesCountArgs>(
      args?: Subset<T, ReviewDIYHomesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewDIYHomesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewDIYHomesAggregateArgs>(args: Subset<T, ReviewDIYHomesAggregateArgs>): Prisma.PrismaPromise<GetReviewDIYHomesAggregateType<T>>

    /**
     * Group by ReviewDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewDIYHomesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewDIYHomesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewDIYHomesGroupByArgs['orderBy'] }
        : { orderBy?: ReviewDIYHomesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewDIYHomesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewDIYHomesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewDIYHomes model
   */
  readonly fields: ReviewDIYHomesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewDIYHomes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewDIYHomesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomesDefaultArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends PostDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomesDefaultArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Report<T extends ReviewDIYHomes$ReportArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDIYHomes$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewDIYHomes model
   */ 
  interface ReviewDIYHomesFieldRefs {
    readonly id: FieldRef<"ReviewDIYHomes", 'String'>
    readonly postId: FieldRef<"ReviewDIYHomes", 'String'>
    readonly userId: FieldRef<"ReviewDIYHomes", 'String'>
    readonly rating: FieldRef<"ReviewDIYHomes", 'Int'>
    readonly comment: FieldRef<"ReviewDIYHomes", 'String'>
    readonly createdAt: FieldRef<"ReviewDIYHomes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewDIYHomes findUnique
   */
  export type ReviewDIYHomesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReviewDIYHomes to fetch.
     */
    where: ReviewDIYHomesWhereUniqueInput
  }

  /**
   * ReviewDIYHomes findUniqueOrThrow
   */
  export type ReviewDIYHomesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReviewDIYHomes to fetch.
     */
    where: ReviewDIYHomesWhereUniqueInput
  }

  /**
   * ReviewDIYHomes findFirst
   */
  export type ReviewDIYHomesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReviewDIYHomes to fetch.
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewDIYHomes to fetch.
     */
    orderBy?: ReviewDIYHomesOrderByWithRelationInput | ReviewDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewDIYHomes.
     */
    cursor?: ReviewDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewDIYHomes.
     */
    distinct?: ReviewDIYHomesScalarFieldEnum | ReviewDIYHomesScalarFieldEnum[]
  }

  /**
   * ReviewDIYHomes findFirstOrThrow
   */
  export type ReviewDIYHomesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReviewDIYHomes to fetch.
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewDIYHomes to fetch.
     */
    orderBy?: ReviewDIYHomesOrderByWithRelationInput | ReviewDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewDIYHomes.
     */
    cursor?: ReviewDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewDIYHomes.
     */
    distinct?: ReviewDIYHomesScalarFieldEnum | ReviewDIYHomesScalarFieldEnum[]
  }

  /**
   * ReviewDIYHomes findMany
   */
  export type ReviewDIYHomesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReviewDIYHomes to fetch.
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewDIYHomes to fetch.
     */
    orderBy?: ReviewDIYHomesOrderByWithRelationInput | ReviewDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewDIYHomes.
     */
    cursor?: ReviewDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewDIYHomes.
     */
    skip?: number
    distinct?: ReviewDIYHomesScalarFieldEnum | ReviewDIYHomesScalarFieldEnum[]
  }

  /**
   * ReviewDIYHomes create
   */
  export type ReviewDIYHomesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewDIYHomes.
     */
    data: XOR<ReviewDIYHomesCreateInput, ReviewDIYHomesUncheckedCreateInput>
  }

  /**
   * ReviewDIYHomes createMany
   */
  export type ReviewDIYHomesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewDIYHomes.
     */
    data: ReviewDIYHomesCreateManyInput | ReviewDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewDIYHomes createManyAndReturn
   */
  export type ReviewDIYHomesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewDIYHomes.
     */
    data: ReviewDIYHomesCreateManyInput | ReviewDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewDIYHomes update
   */
  export type ReviewDIYHomesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewDIYHomes.
     */
    data: XOR<ReviewDIYHomesUpdateInput, ReviewDIYHomesUncheckedUpdateInput>
    /**
     * Choose, which ReviewDIYHomes to update.
     */
    where: ReviewDIYHomesWhereUniqueInput
  }

  /**
   * ReviewDIYHomes updateMany
   */
  export type ReviewDIYHomesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewDIYHomes.
     */
    data: XOR<ReviewDIYHomesUpdateManyMutationInput, ReviewDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which ReviewDIYHomes to update
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * Limit how many ReviewDIYHomes to update.
     */
    limit?: number
  }

  /**
   * ReviewDIYHomes updateManyAndReturn
   */
  export type ReviewDIYHomesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to update ReviewDIYHomes.
     */
    data: XOR<ReviewDIYHomesUpdateManyMutationInput, ReviewDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which ReviewDIYHomes to update
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * Limit how many ReviewDIYHomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewDIYHomes upsert
   */
  export type ReviewDIYHomesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewDIYHomes to update in case it exists.
     */
    where: ReviewDIYHomesWhereUniqueInput
    /**
     * In case the ReviewDIYHomes found by the `where` argument doesn't exist, create a new ReviewDIYHomes with this data.
     */
    create: XOR<ReviewDIYHomesCreateInput, ReviewDIYHomesUncheckedCreateInput>
    /**
     * In case the ReviewDIYHomes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewDIYHomesUpdateInput, ReviewDIYHomesUncheckedUpdateInput>
  }

  /**
   * ReviewDIYHomes delete
   */
  export type ReviewDIYHomesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    /**
     * Filter which ReviewDIYHomes to delete.
     */
    where: ReviewDIYHomesWhereUniqueInput
  }

  /**
   * ReviewDIYHomes deleteMany
   */
  export type ReviewDIYHomesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewDIYHomes to delete
     */
    where?: ReviewDIYHomesWhereInput
    /**
     * Limit how many ReviewDIYHomes to delete.
     */
    limit?: number
  }

  /**
   * ReviewDIYHomes.Report
   */
  export type ReviewDIYHomes$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    where?: ReportDIYHomesWhereInput
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    cursor?: ReportDIYHomesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportDIYHomesScalarFieldEnum | ReportDIYHomesScalarFieldEnum[]
  }

  /**
   * ReviewDIYHomes without action
   */
  export type ReviewDIYHomesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
  }


  /**
   * Model LikeDIYHomes
   */

  export type AggregateLikeDIYHomes = {
    _count: LikeDIYHomesCountAggregateOutputType | null
    _min: LikeDIYHomesMinAggregateOutputType | null
    _max: LikeDIYHomesMaxAggregateOutputType | null
  }

  export type LikeDIYHomesMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeDIYHomesMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeDIYHomesCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LikeDIYHomesMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeDIYHomesMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeDIYHomesCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeDIYHomesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeDIYHomes to aggregate.
     */
    where?: LikeDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeDIYHomes to fetch.
     */
    orderBy?: LikeDIYHomesOrderByWithRelationInput | LikeDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikeDIYHomes
    **/
    _count?: true | LikeDIYHomesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeDIYHomesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeDIYHomesMaxAggregateInputType
  }

  export type GetLikeDIYHomesAggregateType<T extends LikeDIYHomesAggregateArgs> = {
        [P in keyof T & keyof AggregateLikeDIYHomes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikeDIYHomes[P]>
      : GetScalarType<T[P], AggregateLikeDIYHomes[P]>
  }




  export type LikeDIYHomesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeDIYHomesWhereInput
    orderBy?: LikeDIYHomesOrderByWithAggregationInput | LikeDIYHomesOrderByWithAggregationInput[]
    by: LikeDIYHomesScalarFieldEnum[] | LikeDIYHomesScalarFieldEnum
    having?: LikeDIYHomesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeDIYHomesCountAggregateInputType | true
    _min?: LikeDIYHomesMinAggregateInputType
    _max?: LikeDIYHomesMaxAggregateInputType
  }

  export type LikeDIYHomesGroupByOutputType = {
    id: string
    postId: string
    userId: string
    createdAt: Date
    _count: LikeDIYHomesCountAggregateOutputType | null
    _min: LikeDIYHomesMinAggregateOutputType | null
    _max: LikeDIYHomesMaxAggregateOutputType | null
  }

  type GetLikeDIYHomesGroupByPayload<T extends LikeDIYHomesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeDIYHomesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeDIYHomesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeDIYHomesGroupByOutputType[P]>
            : GetScalarType<T[P], LikeDIYHomesGroupByOutputType[P]>
        }
      >
    >


  export type LikeDIYHomesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeDIYHomes"]>

  export type LikeDIYHomesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeDIYHomes"]>

  export type LikeDIYHomesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeDIYHomes"]>

  export type LikeDIYHomesSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LikeDIYHomesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "createdAt", ExtArgs["result"]["likeDIYHomes"]>
  export type LikeDIYHomesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }
  export type LikeDIYHomesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }
  export type LikeDIYHomesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }

  export type $LikeDIYHomesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikeDIYHomes"
    objects: {
      user: Prisma.$UserDIYHomesPayload<ExtArgs>
      post: Prisma.$PostDIYHomesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["likeDIYHomes"]>
    composites: {}
  }

  type LikeDIYHomesGetPayload<S extends boolean | null | undefined | LikeDIYHomesDefaultArgs> = $Result.GetResult<Prisma.$LikeDIYHomesPayload, S>

  type LikeDIYHomesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeDIYHomesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeDIYHomesCountAggregateInputType | true
    }

  export interface LikeDIYHomesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikeDIYHomes'], meta: { name: 'LikeDIYHomes' } }
    /**
     * Find zero or one LikeDIYHomes that matches the filter.
     * @param {LikeDIYHomesFindUniqueArgs} args - Arguments to find a LikeDIYHomes
     * @example
     * // Get one LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeDIYHomesFindUniqueArgs>(args: SelectSubset<T, LikeDIYHomesFindUniqueArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LikeDIYHomes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeDIYHomesFindUniqueOrThrowArgs} args - Arguments to find a LikeDIYHomes
     * @example
     * // Get one LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeDIYHomesFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeDIYHomesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesFindFirstArgs} args - Arguments to find a LikeDIYHomes
     * @example
     * // Get one LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeDIYHomesFindFirstArgs>(args?: SelectSubset<T, LikeDIYHomesFindFirstArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeDIYHomes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesFindFirstOrThrowArgs} args - Arguments to find a LikeDIYHomes
     * @example
     * // Get one LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeDIYHomesFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeDIYHomesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LikeDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.findMany()
     * 
     * // Get first 10 LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeDIYHomesWithIdOnly = await prisma.likeDIYHomes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeDIYHomesFindManyArgs>(args?: SelectSubset<T, LikeDIYHomesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LikeDIYHomes.
     * @param {LikeDIYHomesCreateArgs} args - Arguments to create a LikeDIYHomes.
     * @example
     * // Create one LikeDIYHomes
     * const LikeDIYHomes = await prisma.likeDIYHomes.create({
     *   data: {
     *     // ... data to create a LikeDIYHomes
     *   }
     * })
     * 
     */
    create<T extends LikeDIYHomesCreateArgs>(args: SelectSubset<T, LikeDIYHomesCreateArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LikeDIYHomes.
     * @param {LikeDIYHomesCreateManyArgs} args - Arguments to create many LikeDIYHomes.
     * @example
     * // Create many LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeDIYHomesCreateManyArgs>(args?: SelectSubset<T, LikeDIYHomesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikeDIYHomes and returns the data saved in the database.
     * @param {LikeDIYHomesCreateManyAndReturnArgs} args - Arguments to create many LikeDIYHomes.
     * @example
     * // Create many LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikeDIYHomes and only return the `id`
     * const likeDIYHomesWithIdOnly = await prisma.likeDIYHomes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeDIYHomesCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeDIYHomesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LikeDIYHomes.
     * @param {LikeDIYHomesDeleteArgs} args - Arguments to delete one LikeDIYHomes.
     * @example
     * // Delete one LikeDIYHomes
     * const LikeDIYHomes = await prisma.likeDIYHomes.delete({
     *   where: {
     *     // ... filter to delete one LikeDIYHomes
     *   }
     * })
     * 
     */
    delete<T extends LikeDIYHomesDeleteArgs>(args: SelectSubset<T, LikeDIYHomesDeleteArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LikeDIYHomes.
     * @param {LikeDIYHomesUpdateArgs} args - Arguments to update one LikeDIYHomes.
     * @example
     * // Update one LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeDIYHomesUpdateArgs>(args: SelectSubset<T, LikeDIYHomesUpdateArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LikeDIYHomes.
     * @param {LikeDIYHomesDeleteManyArgs} args - Arguments to filter LikeDIYHomes to delete.
     * @example
     * // Delete a few LikeDIYHomes
     * const { count } = await prisma.likeDIYHomes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDIYHomesDeleteManyArgs>(args?: SelectSubset<T, LikeDIYHomesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeDIYHomesUpdateManyArgs>(args: SelectSubset<T, LikeDIYHomesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeDIYHomes and returns the data updated in the database.
     * @param {LikeDIYHomesUpdateManyAndReturnArgs} args - Arguments to update many LikeDIYHomes.
     * @example
     * // Update many LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LikeDIYHomes and only return the `id`
     * const likeDIYHomesWithIdOnly = await prisma.likeDIYHomes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeDIYHomesUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeDIYHomesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LikeDIYHomes.
     * @param {LikeDIYHomesUpsertArgs} args - Arguments to update or create a LikeDIYHomes.
     * @example
     * // Update or create a LikeDIYHomes
     * const likeDIYHomes = await prisma.likeDIYHomes.upsert({
     *   create: {
     *     // ... data to create a LikeDIYHomes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikeDIYHomes we want to update
     *   }
     * })
     */
    upsert<T extends LikeDIYHomesUpsertArgs>(args: SelectSubset<T, LikeDIYHomesUpsertArgs<ExtArgs>>): Prisma__LikeDIYHomesClient<$Result.GetResult<Prisma.$LikeDIYHomesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LikeDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesCountArgs} args - Arguments to filter LikeDIYHomes to count.
     * @example
     * // Count the number of LikeDIYHomes
     * const count = await prisma.likeDIYHomes.count({
     *   where: {
     *     // ... the filter for the LikeDIYHomes we want to count
     *   }
     * })
    **/
    count<T extends LikeDIYHomesCountArgs>(
      args?: Subset<T, LikeDIYHomesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeDIYHomesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikeDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeDIYHomesAggregateArgs>(args: Subset<T, LikeDIYHomesAggregateArgs>): Prisma.PrismaPromise<GetLikeDIYHomesAggregateType<T>>

    /**
     * Group by LikeDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeDIYHomesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeDIYHomesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeDIYHomesGroupByArgs['orderBy'] }
        : { orderBy?: LikeDIYHomesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeDIYHomesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeDIYHomesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikeDIYHomes model
   */
  readonly fields: LikeDIYHomesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikeDIYHomes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeDIYHomesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomesDefaultArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends PostDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomesDefaultArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikeDIYHomes model
   */ 
  interface LikeDIYHomesFieldRefs {
    readonly id: FieldRef<"LikeDIYHomes", 'String'>
    readonly postId: FieldRef<"LikeDIYHomes", 'String'>
    readonly userId: FieldRef<"LikeDIYHomes", 'String'>
    readonly createdAt: FieldRef<"LikeDIYHomes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LikeDIYHomes findUnique
   */
  export type LikeDIYHomesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which LikeDIYHomes to fetch.
     */
    where: LikeDIYHomesWhereUniqueInput
  }

  /**
   * LikeDIYHomes findUniqueOrThrow
   */
  export type LikeDIYHomesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which LikeDIYHomes to fetch.
     */
    where: LikeDIYHomesWhereUniqueInput
  }

  /**
   * LikeDIYHomes findFirst
   */
  export type LikeDIYHomesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which LikeDIYHomes to fetch.
     */
    where?: LikeDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeDIYHomes to fetch.
     */
    orderBy?: LikeDIYHomesOrderByWithRelationInput | LikeDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeDIYHomes.
     */
    cursor?: LikeDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeDIYHomes.
     */
    distinct?: LikeDIYHomesScalarFieldEnum | LikeDIYHomesScalarFieldEnum[]
  }

  /**
   * LikeDIYHomes findFirstOrThrow
   */
  export type LikeDIYHomesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which LikeDIYHomes to fetch.
     */
    where?: LikeDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeDIYHomes to fetch.
     */
    orderBy?: LikeDIYHomesOrderByWithRelationInput | LikeDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeDIYHomes.
     */
    cursor?: LikeDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeDIYHomes.
     */
    distinct?: LikeDIYHomesScalarFieldEnum | LikeDIYHomesScalarFieldEnum[]
  }

  /**
   * LikeDIYHomes findMany
   */
  export type LikeDIYHomesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which LikeDIYHomes to fetch.
     */
    where?: LikeDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeDIYHomes to fetch.
     */
    orderBy?: LikeDIYHomesOrderByWithRelationInput | LikeDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikeDIYHomes.
     */
    cursor?: LikeDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeDIYHomes.
     */
    skip?: number
    distinct?: LikeDIYHomesScalarFieldEnum | LikeDIYHomesScalarFieldEnum[]
  }

  /**
   * LikeDIYHomes create
   */
  export type LikeDIYHomesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to create a LikeDIYHomes.
     */
    data: XOR<LikeDIYHomesCreateInput, LikeDIYHomesUncheckedCreateInput>
  }

  /**
   * LikeDIYHomes createMany
   */
  export type LikeDIYHomesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikeDIYHomes.
     */
    data: LikeDIYHomesCreateManyInput | LikeDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikeDIYHomes createManyAndReturn
   */
  export type LikeDIYHomesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to create many LikeDIYHomes.
     */
    data: LikeDIYHomesCreateManyInput | LikeDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeDIYHomes update
   */
  export type LikeDIYHomesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to update a LikeDIYHomes.
     */
    data: XOR<LikeDIYHomesUpdateInput, LikeDIYHomesUncheckedUpdateInput>
    /**
     * Choose, which LikeDIYHomes to update.
     */
    where: LikeDIYHomesWhereUniqueInput
  }

  /**
   * LikeDIYHomes updateMany
   */
  export type LikeDIYHomesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikeDIYHomes.
     */
    data: XOR<LikeDIYHomesUpdateManyMutationInput, LikeDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which LikeDIYHomes to update
     */
    where?: LikeDIYHomesWhereInput
    /**
     * Limit how many LikeDIYHomes to update.
     */
    limit?: number
  }

  /**
   * LikeDIYHomes updateManyAndReturn
   */
  export type LikeDIYHomesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to update LikeDIYHomes.
     */
    data: XOR<LikeDIYHomesUpdateManyMutationInput, LikeDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which LikeDIYHomes to update
     */
    where?: LikeDIYHomesWhereInput
    /**
     * Limit how many LikeDIYHomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeDIYHomes upsert
   */
  export type LikeDIYHomesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * The filter to search for the LikeDIYHomes to update in case it exists.
     */
    where: LikeDIYHomesWhereUniqueInput
    /**
     * In case the LikeDIYHomes found by the `where` argument doesn't exist, create a new LikeDIYHomes with this data.
     */
    create: XOR<LikeDIYHomesCreateInput, LikeDIYHomesUncheckedCreateInput>
    /**
     * In case the LikeDIYHomes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeDIYHomesUpdateInput, LikeDIYHomesUncheckedUpdateInput>
  }

  /**
   * LikeDIYHomes delete
   */
  export type LikeDIYHomesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
    /**
     * Filter which LikeDIYHomes to delete.
     */
    where: LikeDIYHomesWhereUniqueInput
  }

  /**
   * LikeDIYHomes deleteMany
   */
  export type LikeDIYHomesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeDIYHomes to delete
     */
    where?: LikeDIYHomesWhereInput
    /**
     * Limit how many LikeDIYHomes to delete.
     */
    limit?: number
  }

  /**
   * LikeDIYHomes without action
   */
  export type LikeDIYHomesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeDIYHomes
     */
    select?: LikeDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeDIYHomes
     */
    omit?: LikeDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeDIYHomesInclude<ExtArgs> | null
  }


  /**
   * Model BookmarkDIYHomes
   */

  export type AggregateBookmarkDIYHomes = {
    _count: BookmarkDIYHomesCountAggregateOutputType | null
    _min: BookmarkDIYHomesMinAggregateOutputType | null
    _max: BookmarkDIYHomesMaxAggregateOutputType | null
  }

  export type BookmarkDIYHomesMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type BookmarkDIYHomesMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type BookmarkDIYHomesCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type BookmarkDIYHomesMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type BookmarkDIYHomesMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type BookmarkDIYHomesCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkDIYHomesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookmarkDIYHomes to aggregate.
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkDIYHomes to fetch.
     */
    orderBy?: BookmarkDIYHomesOrderByWithRelationInput | BookmarkDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookmarkDIYHomes
    **/
    _count?: true | BookmarkDIYHomesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkDIYHomesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkDIYHomesMaxAggregateInputType
  }

  export type GetBookmarkDIYHomesAggregateType<T extends BookmarkDIYHomesAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmarkDIYHomes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmarkDIYHomes[P]>
      : GetScalarType<T[P], AggregateBookmarkDIYHomes[P]>
  }




  export type BookmarkDIYHomesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkDIYHomesWhereInput
    orderBy?: BookmarkDIYHomesOrderByWithAggregationInput | BookmarkDIYHomesOrderByWithAggregationInput[]
    by: BookmarkDIYHomesScalarFieldEnum[] | BookmarkDIYHomesScalarFieldEnum
    having?: BookmarkDIYHomesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkDIYHomesCountAggregateInputType | true
    _min?: BookmarkDIYHomesMinAggregateInputType
    _max?: BookmarkDIYHomesMaxAggregateInputType
  }

  export type BookmarkDIYHomesGroupByOutputType = {
    id: string
    postId: string
    userId: string
    createdAt: Date
    _count: BookmarkDIYHomesCountAggregateOutputType | null
    _min: BookmarkDIYHomesMinAggregateOutputType | null
    _max: BookmarkDIYHomesMaxAggregateOutputType | null
  }

  type GetBookmarkDIYHomesGroupByPayload<T extends BookmarkDIYHomesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkDIYHomesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkDIYHomesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkDIYHomesGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkDIYHomesGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkDIYHomesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarkDIYHomes"]>

  export type BookmarkDIYHomesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarkDIYHomes"]>

  export type BookmarkDIYHomesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarkDIYHomes"]>

  export type BookmarkDIYHomesSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type BookmarkDIYHomesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "createdAt", ExtArgs["result"]["bookmarkDIYHomes"]>
  export type BookmarkDIYHomesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }
  export type BookmarkDIYHomesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }
  export type BookmarkDIYHomesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | PostDIYHomesDefaultArgs<ExtArgs>
  }

  export type $BookmarkDIYHomesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookmarkDIYHomes"
    objects: {
      user: Prisma.$UserDIYHomesPayload<ExtArgs>
      post: Prisma.$PostDIYHomesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["bookmarkDIYHomes"]>
    composites: {}
  }

  type BookmarkDIYHomesGetPayload<S extends boolean | null | undefined | BookmarkDIYHomesDefaultArgs> = $Result.GetResult<Prisma.$BookmarkDIYHomesPayload, S>

  type BookmarkDIYHomesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarkDIYHomesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarkDIYHomesCountAggregateInputType | true
    }

  export interface BookmarkDIYHomesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookmarkDIYHomes'], meta: { name: 'BookmarkDIYHomes' } }
    /**
     * Find zero or one BookmarkDIYHomes that matches the filter.
     * @param {BookmarkDIYHomesFindUniqueArgs} args - Arguments to find a BookmarkDIYHomes
     * @example
     * // Get one BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkDIYHomesFindUniqueArgs>(args: SelectSubset<T, BookmarkDIYHomesFindUniqueArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookmarkDIYHomes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarkDIYHomesFindUniqueOrThrowArgs} args - Arguments to find a BookmarkDIYHomes
     * @example
     * // Get one BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkDIYHomesFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkDIYHomesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookmarkDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesFindFirstArgs} args - Arguments to find a BookmarkDIYHomes
     * @example
     * // Get one BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkDIYHomesFindFirstArgs>(args?: SelectSubset<T, BookmarkDIYHomesFindFirstArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookmarkDIYHomes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesFindFirstOrThrowArgs} args - Arguments to find a BookmarkDIYHomes
     * @example
     * // Get one BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkDIYHomesFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkDIYHomesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookmarkDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findMany()
     * 
     * // Get first 10 BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkDIYHomesWithIdOnly = await prisma.bookmarkDIYHomes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkDIYHomesFindManyArgs>(args?: SelectSubset<T, BookmarkDIYHomesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookmarkDIYHomes.
     * @param {BookmarkDIYHomesCreateArgs} args - Arguments to create a BookmarkDIYHomes.
     * @example
     * // Create one BookmarkDIYHomes
     * const BookmarkDIYHomes = await prisma.bookmarkDIYHomes.create({
     *   data: {
     *     // ... data to create a BookmarkDIYHomes
     *   }
     * })
     * 
     */
    create<T extends BookmarkDIYHomesCreateArgs>(args: SelectSubset<T, BookmarkDIYHomesCreateArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookmarkDIYHomes.
     * @param {BookmarkDIYHomesCreateManyArgs} args - Arguments to create many BookmarkDIYHomes.
     * @example
     * // Create many BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkDIYHomesCreateManyArgs>(args?: SelectSubset<T, BookmarkDIYHomesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookmarkDIYHomes and returns the data saved in the database.
     * @param {BookmarkDIYHomesCreateManyAndReturnArgs} args - Arguments to create many BookmarkDIYHomes.
     * @example
     * // Create many BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookmarkDIYHomes and only return the `id`
     * const bookmarkDIYHomesWithIdOnly = await prisma.bookmarkDIYHomes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarkDIYHomesCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarkDIYHomesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookmarkDIYHomes.
     * @param {BookmarkDIYHomesDeleteArgs} args - Arguments to delete one BookmarkDIYHomes.
     * @example
     * // Delete one BookmarkDIYHomes
     * const BookmarkDIYHomes = await prisma.bookmarkDIYHomes.delete({
     *   where: {
     *     // ... filter to delete one BookmarkDIYHomes
     *   }
     * })
     * 
     */
    delete<T extends BookmarkDIYHomesDeleteArgs>(args: SelectSubset<T, BookmarkDIYHomesDeleteArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookmarkDIYHomes.
     * @param {BookmarkDIYHomesUpdateArgs} args - Arguments to update one BookmarkDIYHomes.
     * @example
     * // Update one BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkDIYHomesUpdateArgs>(args: SelectSubset<T, BookmarkDIYHomesUpdateArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookmarkDIYHomes.
     * @param {BookmarkDIYHomesDeleteManyArgs} args - Arguments to filter BookmarkDIYHomes to delete.
     * @example
     * // Delete a few BookmarkDIYHomes
     * const { count } = await prisma.bookmarkDIYHomes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkDIYHomesDeleteManyArgs>(args?: SelectSubset<T, BookmarkDIYHomesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookmarkDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkDIYHomesUpdateManyArgs>(args: SelectSubset<T, BookmarkDIYHomesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookmarkDIYHomes and returns the data updated in the database.
     * @param {BookmarkDIYHomesUpdateManyAndReturnArgs} args - Arguments to update many BookmarkDIYHomes.
     * @example
     * // Update many BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookmarkDIYHomes and only return the `id`
     * const bookmarkDIYHomesWithIdOnly = await prisma.bookmarkDIYHomes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookmarkDIYHomesUpdateManyAndReturnArgs>(args: SelectSubset<T, BookmarkDIYHomesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookmarkDIYHomes.
     * @param {BookmarkDIYHomesUpsertArgs} args - Arguments to update or create a BookmarkDIYHomes.
     * @example
     * // Update or create a BookmarkDIYHomes
     * const bookmarkDIYHomes = await prisma.bookmarkDIYHomes.upsert({
     *   create: {
     *     // ... data to create a BookmarkDIYHomes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookmarkDIYHomes we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkDIYHomesUpsertArgs>(args: SelectSubset<T, BookmarkDIYHomesUpsertArgs<ExtArgs>>): Prisma__BookmarkDIYHomesClient<$Result.GetResult<Prisma.$BookmarkDIYHomesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookmarkDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesCountArgs} args - Arguments to filter BookmarkDIYHomes to count.
     * @example
     * // Count the number of BookmarkDIYHomes
     * const count = await prisma.bookmarkDIYHomes.count({
     *   where: {
     *     // ... the filter for the BookmarkDIYHomes we want to count
     *   }
     * })
    **/
    count<T extends BookmarkDIYHomesCountArgs>(
      args?: Subset<T, BookmarkDIYHomesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkDIYHomesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookmarkDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkDIYHomesAggregateArgs>(args: Subset<T, BookmarkDIYHomesAggregateArgs>): Prisma.PrismaPromise<GetBookmarkDIYHomesAggregateType<T>>

    /**
     * Group by BookmarkDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkDIYHomesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkDIYHomesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkDIYHomesGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkDIYHomesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkDIYHomesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkDIYHomesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookmarkDIYHomes model
   */
  readonly fields: BookmarkDIYHomesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookmarkDIYHomes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkDIYHomesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomesDefaultArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends PostDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDIYHomesDefaultArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookmarkDIYHomes model
   */ 
  interface BookmarkDIYHomesFieldRefs {
    readonly id: FieldRef<"BookmarkDIYHomes", 'String'>
    readonly postId: FieldRef<"BookmarkDIYHomes", 'String'>
    readonly userId: FieldRef<"BookmarkDIYHomes", 'String'>
    readonly createdAt: FieldRef<"BookmarkDIYHomes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookmarkDIYHomes findUnique
   */
  export type BookmarkDIYHomesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkDIYHomes to fetch.
     */
    where: BookmarkDIYHomesWhereUniqueInput
  }

  /**
   * BookmarkDIYHomes findUniqueOrThrow
   */
  export type BookmarkDIYHomesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkDIYHomes to fetch.
     */
    where: BookmarkDIYHomesWhereUniqueInput
  }

  /**
   * BookmarkDIYHomes findFirst
   */
  export type BookmarkDIYHomesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkDIYHomes to fetch.
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkDIYHomes to fetch.
     */
    orderBy?: BookmarkDIYHomesOrderByWithRelationInput | BookmarkDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookmarkDIYHomes.
     */
    cursor?: BookmarkDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookmarkDIYHomes.
     */
    distinct?: BookmarkDIYHomesScalarFieldEnum | BookmarkDIYHomesScalarFieldEnum[]
  }

  /**
   * BookmarkDIYHomes findFirstOrThrow
   */
  export type BookmarkDIYHomesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkDIYHomes to fetch.
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkDIYHomes to fetch.
     */
    orderBy?: BookmarkDIYHomesOrderByWithRelationInput | BookmarkDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookmarkDIYHomes.
     */
    cursor?: BookmarkDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookmarkDIYHomes.
     */
    distinct?: BookmarkDIYHomesScalarFieldEnum | BookmarkDIYHomesScalarFieldEnum[]
  }

  /**
   * BookmarkDIYHomes findMany
   */
  export type BookmarkDIYHomesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkDIYHomes to fetch.
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkDIYHomes to fetch.
     */
    orderBy?: BookmarkDIYHomesOrderByWithRelationInput | BookmarkDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookmarkDIYHomes.
     */
    cursor?: BookmarkDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkDIYHomes.
     */
    skip?: number
    distinct?: BookmarkDIYHomesScalarFieldEnum | BookmarkDIYHomesScalarFieldEnum[]
  }

  /**
   * BookmarkDIYHomes create
   */
  export type BookmarkDIYHomesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to create a BookmarkDIYHomes.
     */
    data: XOR<BookmarkDIYHomesCreateInput, BookmarkDIYHomesUncheckedCreateInput>
  }

  /**
   * BookmarkDIYHomes createMany
   */
  export type BookmarkDIYHomesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookmarkDIYHomes.
     */
    data: BookmarkDIYHomesCreateManyInput | BookmarkDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookmarkDIYHomes createManyAndReturn
   */
  export type BookmarkDIYHomesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to create many BookmarkDIYHomes.
     */
    data: BookmarkDIYHomesCreateManyInput | BookmarkDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookmarkDIYHomes update
   */
  export type BookmarkDIYHomesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to update a BookmarkDIYHomes.
     */
    data: XOR<BookmarkDIYHomesUpdateInput, BookmarkDIYHomesUncheckedUpdateInput>
    /**
     * Choose, which BookmarkDIYHomes to update.
     */
    where: BookmarkDIYHomesWhereUniqueInput
  }

  /**
   * BookmarkDIYHomes updateMany
   */
  export type BookmarkDIYHomesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookmarkDIYHomes.
     */
    data: XOR<BookmarkDIYHomesUpdateManyMutationInput, BookmarkDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which BookmarkDIYHomes to update
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * Limit how many BookmarkDIYHomes to update.
     */
    limit?: number
  }

  /**
   * BookmarkDIYHomes updateManyAndReturn
   */
  export type BookmarkDIYHomesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to update BookmarkDIYHomes.
     */
    data: XOR<BookmarkDIYHomesUpdateManyMutationInput, BookmarkDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which BookmarkDIYHomes to update
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * Limit how many BookmarkDIYHomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookmarkDIYHomes upsert
   */
  export type BookmarkDIYHomesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * The filter to search for the BookmarkDIYHomes to update in case it exists.
     */
    where: BookmarkDIYHomesWhereUniqueInput
    /**
     * In case the BookmarkDIYHomes found by the `where` argument doesn't exist, create a new BookmarkDIYHomes with this data.
     */
    create: XOR<BookmarkDIYHomesCreateInput, BookmarkDIYHomesUncheckedCreateInput>
    /**
     * In case the BookmarkDIYHomes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkDIYHomesUpdateInput, BookmarkDIYHomesUncheckedUpdateInput>
  }

  /**
   * BookmarkDIYHomes delete
   */
  export type BookmarkDIYHomesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
    /**
     * Filter which BookmarkDIYHomes to delete.
     */
    where: BookmarkDIYHomesWhereUniqueInput
  }

  /**
   * BookmarkDIYHomes deleteMany
   */
  export type BookmarkDIYHomesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookmarkDIYHomes to delete
     */
    where?: BookmarkDIYHomesWhereInput
    /**
     * Limit how many BookmarkDIYHomes to delete.
     */
    limit?: number
  }

  /**
   * BookmarkDIYHomes without action
   */
  export type BookmarkDIYHomesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkDIYHomes
     */
    select?: BookmarkDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkDIYHomes
     */
    omit?: BookmarkDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkDIYHomesInclude<ExtArgs> | null
  }


  /**
   * Model ReportDIYHomes
   */

  export type AggregateReportDIYHomes = {
    _count: ReportDIYHomesCountAggregateOutputType | null
    _min: ReportDIYHomesMinAggregateOutputType | null
    _max: ReportDIYHomesMaxAggregateOutputType | null
  }

  export type ReportDIYHomesMinAggregateOutputType = {
    id: string | null
    postId: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportDIYHomesMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportDIYHomesCountAggregateOutputType = {
    id: number
    postId: number
    reviewId: number
    userId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReportDIYHomesMinAggregateInputType = {
    id?: true
    postId?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ReportDIYHomesMaxAggregateInputType = {
    id?: true
    postId?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ReportDIYHomesCountAggregateInputType = {
    id?: true
    postId?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReportDIYHomesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDIYHomes to aggregate.
     */
    where?: ReportDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDIYHomes to fetch.
     */
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportDIYHomes
    **/
    _count?: true | ReportDIYHomesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportDIYHomesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportDIYHomesMaxAggregateInputType
  }

  export type GetReportDIYHomesAggregateType<T extends ReportDIYHomesAggregateArgs> = {
        [P in keyof T & keyof AggregateReportDIYHomes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportDIYHomes[P]>
      : GetScalarType<T[P], AggregateReportDIYHomes[P]>
  }




  export type ReportDIYHomesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDIYHomesWhereInput
    orderBy?: ReportDIYHomesOrderByWithAggregationInput | ReportDIYHomesOrderByWithAggregationInput[]
    by: ReportDIYHomesScalarFieldEnum[] | ReportDIYHomesScalarFieldEnum
    having?: ReportDIYHomesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportDIYHomesCountAggregateInputType | true
    _min?: ReportDIYHomesMinAggregateInputType
    _max?: ReportDIYHomesMaxAggregateInputType
  }

  export type ReportDIYHomesGroupByOutputType = {
    id: string
    postId: string | null
    reviewId: string | null
    userId: string
    reason: string
    createdAt: Date
    _count: ReportDIYHomesCountAggregateOutputType | null
    _min: ReportDIYHomesMinAggregateOutputType | null
    _max: ReportDIYHomesMaxAggregateOutputType | null
  }

  type GetReportDIYHomesGroupByPayload<T extends ReportDIYHomesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportDIYHomesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportDIYHomesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportDIYHomesGroupByOutputType[P]>
            : GetScalarType<T[P], ReportDIYHomesGroupByOutputType[P]>
        }
      >
    >


  export type ReportDIYHomesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | ReportDIYHomes$postArgs<ExtArgs>
    review?: boolean | ReportDIYHomes$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["reportDIYHomes"]>

  export type ReportDIYHomesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | ReportDIYHomes$postArgs<ExtArgs>
    review?: boolean | ReportDIYHomes$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["reportDIYHomes"]>

  export type ReportDIYHomesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | ReportDIYHomes$postArgs<ExtArgs>
    review?: boolean | ReportDIYHomes$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["reportDIYHomes"]>

  export type ReportDIYHomesSelectScalar = {
    id?: boolean
    postId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReportDIYHomesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "reviewId" | "userId" | "reason" | "createdAt", ExtArgs["result"]["reportDIYHomes"]>
  export type ReportDIYHomesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | ReportDIYHomes$postArgs<ExtArgs>
    review?: boolean | ReportDIYHomes$reviewArgs<ExtArgs>
  }
  export type ReportDIYHomesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | ReportDIYHomes$postArgs<ExtArgs>
    review?: boolean | ReportDIYHomes$reviewArgs<ExtArgs>
  }
  export type ReportDIYHomesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDIYHomesDefaultArgs<ExtArgs>
    post?: boolean | ReportDIYHomes$postArgs<ExtArgs>
    review?: boolean | ReportDIYHomes$reviewArgs<ExtArgs>
  }

  export type $ReportDIYHomesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportDIYHomes"
    objects: {
      user: Prisma.$UserDIYHomesPayload<ExtArgs>
      post: Prisma.$PostDIYHomesPayload<ExtArgs> | null
      review: Prisma.$ReviewDIYHomesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string | null
      reviewId: string | null
      userId: string
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["reportDIYHomes"]>
    composites: {}
  }

  type ReportDIYHomesGetPayload<S extends boolean | null | undefined | ReportDIYHomesDefaultArgs> = $Result.GetResult<Prisma.$ReportDIYHomesPayload, S>

  type ReportDIYHomesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportDIYHomesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportDIYHomesCountAggregateInputType | true
    }

  export interface ReportDIYHomesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportDIYHomes'], meta: { name: 'ReportDIYHomes' } }
    /**
     * Find zero or one ReportDIYHomes that matches the filter.
     * @param {ReportDIYHomesFindUniqueArgs} args - Arguments to find a ReportDIYHomes
     * @example
     * // Get one ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportDIYHomesFindUniqueArgs>(args: SelectSubset<T, ReportDIYHomesFindUniqueArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportDIYHomes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportDIYHomesFindUniqueOrThrowArgs} args - Arguments to find a ReportDIYHomes
     * @example
     * // Get one ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportDIYHomesFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportDIYHomesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesFindFirstArgs} args - Arguments to find a ReportDIYHomes
     * @example
     * // Get one ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportDIYHomesFindFirstArgs>(args?: SelectSubset<T, ReportDIYHomesFindFirstArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportDIYHomes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesFindFirstOrThrowArgs} args - Arguments to find a ReportDIYHomes
     * @example
     * // Get one ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportDIYHomesFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportDIYHomesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportDIYHomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.findMany()
     * 
     * // Get first 10 ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportDIYHomesWithIdOnly = await prisma.reportDIYHomes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportDIYHomesFindManyArgs>(args?: SelectSubset<T, ReportDIYHomesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportDIYHomes.
     * @param {ReportDIYHomesCreateArgs} args - Arguments to create a ReportDIYHomes.
     * @example
     * // Create one ReportDIYHomes
     * const ReportDIYHomes = await prisma.reportDIYHomes.create({
     *   data: {
     *     // ... data to create a ReportDIYHomes
     *   }
     * })
     * 
     */
    create<T extends ReportDIYHomesCreateArgs>(args: SelectSubset<T, ReportDIYHomesCreateArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportDIYHomes.
     * @param {ReportDIYHomesCreateManyArgs} args - Arguments to create many ReportDIYHomes.
     * @example
     * // Create many ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportDIYHomesCreateManyArgs>(args?: SelectSubset<T, ReportDIYHomesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportDIYHomes and returns the data saved in the database.
     * @param {ReportDIYHomesCreateManyAndReturnArgs} args - Arguments to create many ReportDIYHomes.
     * @example
     * // Create many ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportDIYHomes and only return the `id`
     * const reportDIYHomesWithIdOnly = await prisma.reportDIYHomes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportDIYHomesCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportDIYHomesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportDIYHomes.
     * @param {ReportDIYHomesDeleteArgs} args - Arguments to delete one ReportDIYHomes.
     * @example
     * // Delete one ReportDIYHomes
     * const ReportDIYHomes = await prisma.reportDIYHomes.delete({
     *   where: {
     *     // ... filter to delete one ReportDIYHomes
     *   }
     * })
     * 
     */
    delete<T extends ReportDIYHomesDeleteArgs>(args: SelectSubset<T, ReportDIYHomesDeleteArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportDIYHomes.
     * @param {ReportDIYHomesUpdateArgs} args - Arguments to update one ReportDIYHomes.
     * @example
     * // Update one ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportDIYHomesUpdateArgs>(args: SelectSubset<T, ReportDIYHomesUpdateArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportDIYHomes.
     * @param {ReportDIYHomesDeleteManyArgs} args - Arguments to filter ReportDIYHomes to delete.
     * @example
     * // Delete a few ReportDIYHomes
     * const { count } = await prisma.reportDIYHomes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDIYHomesDeleteManyArgs>(args?: SelectSubset<T, ReportDIYHomesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportDIYHomesUpdateManyArgs>(args: SelectSubset<T, ReportDIYHomesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportDIYHomes and returns the data updated in the database.
     * @param {ReportDIYHomesUpdateManyAndReturnArgs} args - Arguments to update many ReportDIYHomes.
     * @example
     * // Update many ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportDIYHomes and only return the `id`
     * const reportDIYHomesWithIdOnly = await prisma.reportDIYHomes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportDIYHomesUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportDIYHomesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportDIYHomes.
     * @param {ReportDIYHomesUpsertArgs} args - Arguments to update or create a ReportDIYHomes.
     * @example
     * // Update or create a ReportDIYHomes
     * const reportDIYHomes = await prisma.reportDIYHomes.upsert({
     *   create: {
     *     // ... data to create a ReportDIYHomes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportDIYHomes we want to update
     *   }
     * })
     */
    upsert<T extends ReportDIYHomesUpsertArgs>(args: SelectSubset<T, ReportDIYHomesUpsertArgs<ExtArgs>>): Prisma__ReportDIYHomesClient<$Result.GetResult<Prisma.$ReportDIYHomesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesCountArgs} args - Arguments to filter ReportDIYHomes to count.
     * @example
     * // Count the number of ReportDIYHomes
     * const count = await prisma.reportDIYHomes.count({
     *   where: {
     *     // ... the filter for the ReportDIYHomes we want to count
     *   }
     * })
    **/
    count<T extends ReportDIYHomesCountArgs>(
      args?: Subset<T, ReportDIYHomesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportDIYHomesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportDIYHomesAggregateArgs>(args: Subset<T, ReportDIYHomesAggregateArgs>): Prisma.PrismaPromise<GetReportDIYHomesAggregateType<T>>

    /**
     * Group by ReportDIYHomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDIYHomesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportDIYHomesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportDIYHomesGroupByArgs['orderBy'] }
        : { orderBy?: ReportDIYHomesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportDIYHomesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportDIYHomesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportDIYHomes model
   */
  readonly fields: ReportDIYHomesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportDIYHomes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportDIYHomesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDIYHomesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDIYHomesDefaultArgs<ExtArgs>>): Prisma__UserDIYHomesClient<$Result.GetResult<Prisma.$UserDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends ReportDIYHomes$postArgs<ExtArgs> = {}>(args?: Subset<T, ReportDIYHomes$postArgs<ExtArgs>>): Prisma__PostDIYHomesClient<$Result.GetResult<Prisma.$PostDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    review<T extends ReportDIYHomes$reviewArgs<ExtArgs> = {}>(args?: Subset<T, ReportDIYHomes$reviewArgs<ExtArgs>>): Prisma__ReviewDIYHomesClient<$Result.GetResult<Prisma.$ReviewDIYHomesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportDIYHomes model
   */ 
  interface ReportDIYHomesFieldRefs {
    readonly id: FieldRef<"ReportDIYHomes", 'String'>
    readonly postId: FieldRef<"ReportDIYHomes", 'String'>
    readonly reviewId: FieldRef<"ReportDIYHomes", 'String'>
    readonly userId: FieldRef<"ReportDIYHomes", 'String'>
    readonly reason: FieldRef<"ReportDIYHomes", 'String'>
    readonly createdAt: FieldRef<"ReportDIYHomes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportDIYHomes findUnique
   */
  export type ReportDIYHomesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReportDIYHomes to fetch.
     */
    where: ReportDIYHomesWhereUniqueInput
  }

  /**
   * ReportDIYHomes findUniqueOrThrow
   */
  export type ReportDIYHomesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReportDIYHomes to fetch.
     */
    where: ReportDIYHomesWhereUniqueInput
  }

  /**
   * ReportDIYHomes findFirst
   */
  export type ReportDIYHomesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReportDIYHomes to fetch.
     */
    where?: ReportDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDIYHomes to fetch.
     */
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDIYHomes.
     */
    cursor?: ReportDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDIYHomes.
     */
    distinct?: ReportDIYHomesScalarFieldEnum | ReportDIYHomesScalarFieldEnum[]
  }

  /**
   * ReportDIYHomes findFirstOrThrow
   */
  export type ReportDIYHomesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReportDIYHomes to fetch.
     */
    where?: ReportDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDIYHomes to fetch.
     */
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDIYHomes.
     */
    cursor?: ReportDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDIYHomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDIYHomes.
     */
    distinct?: ReportDIYHomesScalarFieldEnum | ReportDIYHomesScalarFieldEnum[]
  }

  /**
   * ReportDIYHomes findMany
   */
  export type ReportDIYHomesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * Filter, which ReportDIYHomes to fetch.
     */
    where?: ReportDIYHomesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDIYHomes to fetch.
     */
    orderBy?: ReportDIYHomesOrderByWithRelationInput | ReportDIYHomesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportDIYHomes.
     */
    cursor?: ReportDIYHomesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDIYHomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDIYHomes.
     */
    skip?: number
    distinct?: ReportDIYHomesScalarFieldEnum | ReportDIYHomesScalarFieldEnum[]
  }

  /**
   * ReportDIYHomes create
   */
  export type ReportDIYHomesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportDIYHomes.
     */
    data: XOR<ReportDIYHomesCreateInput, ReportDIYHomesUncheckedCreateInput>
  }

  /**
   * ReportDIYHomes createMany
   */
  export type ReportDIYHomesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportDIYHomes.
     */
    data: ReportDIYHomesCreateManyInput | ReportDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportDIYHomes createManyAndReturn
   */
  export type ReportDIYHomesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to create many ReportDIYHomes.
     */
    data: ReportDIYHomesCreateManyInput | ReportDIYHomesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportDIYHomes update
   */
  export type ReportDIYHomesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportDIYHomes.
     */
    data: XOR<ReportDIYHomesUpdateInput, ReportDIYHomesUncheckedUpdateInput>
    /**
     * Choose, which ReportDIYHomes to update.
     */
    where: ReportDIYHomesWhereUniqueInput
  }

  /**
   * ReportDIYHomes updateMany
   */
  export type ReportDIYHomesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportDIYHomes.
     */
    data: XOR<ReportDIYHomesUpdateManyMutationInput, ReportDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which ReportDIYHomes to update
     */
    where?: ReportDIYHomesWhereInput
    /**
     * Limit how many ReportDIYHomes to update.
     */
    limit?: number
  }

  /**
   * ReportDIYHomes updateManyAndReturn
   */
  export type ReportDIYHomesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * The data used to update ReportDIYHomes.
     */
    data: XOR<ReportDIYHomesUpdateManyMutationInput, ReportDIYHomesUncheckedUpdateManyInput>
    /**
     * Filter which ReportDIYHomes to update
     */
    where?: ReportDIYHomesWhereInput
    /**
     * Limit how many ReportDIYHomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportDIYHomes upsert
   */
  export type ReportDIYHomesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportDIYHomes to update in case it exists.
     */
    where: ReportDIYHomesWhereUniqueInput
    /**
     * In case the ReportDIYHomes found by the `where` argument doesn't exist, create a new ReportDIYHomes with this data.
     */
    create: XOR<ReportDIYHomesCreateInput, ReportDIYHomesUncheckedCreateInput>
    /**
     * In case the ReportDIYHomes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportDIYHomesUpdateInput, ReportDIYHomesUncheckedUpdateInput>
  }

  /**
   * ReportDIYHomes delete
   */
  export type ReportDIYHomesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
    /**
     * Filter which ReportDIYHomes to delete.
     */
    where: ReportDIYHomesWhereUniqueInput
  }

  /**
   * ReportDIYHomes deleteMany
   */
  export type ReportDIYHomesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDIYHomes to delete
     */
    where?: ReportDIYHomesWhereInput
    /**
     * Limit how many ReportDIYHomes to delete.
     */
    limit?: number
  }

  /**
   * ReportDIYHomes.post
   */
  export type ReportDIYHomes$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostDIYHomes
     */
    select?: PostDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostDIYHomes
     */
    omit?: PostDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostDIYHomesInclude<ExtArgs> | null
    where?: PostDIYHomesWhereInput
  }

  /**
   * ReportDIYHomes.review
   */
  export type ReportDIYHomes$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewDIYHomes
     */
    select?: ReviewDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewDIYHomes
     */
    omit?: ReviewDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewDIYHomesInclude<ExtArgs> | null
    where?: ReviewDIYHomesWhereInput
  }

  /**
   * ReportDIYHomes without action
   */
  export type ReportDIYHomesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDIYHomes
     */
    select?: ReportDIYHomesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportDIYHomes
     */
    omit?: ReportDIYHomesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDIYHomesInclude<ExtArgs> | null
  }


  /**
   * Model UserUrbanExplorer
   */

  export type AggregateUserUrbanExplorer = {
    _count: UserUrbanExplorerCountAggregateOutputType | null
    _min: UserUrbanExplorerMinAggregateOutputType | null
    _max: UserUrbanExplorerMaxAggregateOutputType | null
  }

  export type UserUrbanExplorerMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserUrbanExplorerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserUrbanExplorerCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserUrbanExplorerMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserUrbanExplorerMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserUrbanExplorerCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserUrbanExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserUrbanExplorer to aggregate.
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUrbanExplorers to fetch.
     */
    orderBy?: UserUrbanExplorerOrderByWithRelationInput | UserUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserUrbanExplorers
    **/
    _count?: true | UserUrbanExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserUrbanExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserUrbanExplorerMaxAggregateInputType
  }

  export type GetUserUrbanExplorerAggregateType<T extends UserUrbanExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserUrbanExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserUrbanExplorer[P]>
      : GetScalarType<T[P], AggregateUserUrbanExplorer[P]>
  }




  export type UserUrbanExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserUrbanExplorerWhereInput
    orderBy?: UserUrbanExplorerOrderByWithAggregationInput | UserUrbanExplorerOrderByWithAggregationInput[]
    by: UserUrbanExplorerScalarFieldEnum[] | UserUrbanExplorerScalarFieldEnum
    having?: UserUrbanExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserUrbanExplorerCountAggregateInputType | true
    _min?: UserUrbanExplorerMinAggregateInputType
    _max?: UserUrbanExplorerMaxAggregateInputType
  }

  export type UserUrbanExplorerGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserUrbanExplorerCountAggregateOutputType | null
    _min: UserUrbanExplorerMinAggregateOutputType | null
    _max: UserUrbanExplorerMaxAggregateOutputType | null
  }

  type GetUserUrbanExplorerGroupByPayload<T extends UserUrbanExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserUrbanExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserUrbanExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserUrbanExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], UserUrbanExplorerGroupByOutputType[P]>
        }
      >
    >


  export type UserUrbanExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    PlaceUrbanExplorer?: boolean | UserUrbanExplorer$PlaceUrbanExplorerArgs<ExtArgs>
    ReviewUrbanExplorer?: boolean | UserUrbanExplorer$ReviewUrbanExplorerArgs<ExtArgs>
    LikeUrbanExplorer?: boolean | UserUrbanExplorer$LikeUrbanExplorerArgs<ExtArgs>
    BookmarkUrbanExplorer?: boolean | UserUrbanExplorer$BookmarkUrbanExplorerArgs<ExtArgs>
    ReportUrbanExplorer?: boolean | UserUrbanExplorer$ReportUrbanExplorerArgs<ExtArgs>
    _count?: boolean | UserUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userUrbanExplorer"]>

  export type UserUrbanExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userUrbanExplorer"]>

  export type UserUrbanExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userUrbanExplorer"]>

  export type UserUrbanExplorerSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserUrbanExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userUrbanExplorer"]>
  export type UserUrbanExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PlaceUrbanExplorer?: boolean | UserUrbanExplorer$PlaceUrbanExplorerArgs<ExtArgs>
    ReviewUrbanExplorer?: boolean | UserUrbanExplorer$ReviewUrbanExplorerArgs<ExtArgs>
    LikeUrbanExplorer?: boolean | UserUrbanExplorer$LikeUrbanExplorerArgs<ExtArgs>
    BookmarkUrbanExplorer?: boolean | UserUrbanExplorer$BookmarkUrbanExplorerArgs<ExtArgs>
    ReportUrbanExplorer?: boolean | UserUrbanExplorer$ReportUrbanExplorerArgs<ExtArgs>
    _count?: boolean | UserUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserUrbanExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserUrbanExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserUrbanExplorer"
    objects: {
      PlaceUrbanExplorer: Prisma.$PlaceUrbanExplorerPayload<ExtArgs>[]
      ReviewUrbanExplorer: Prisma.$ReviewUrbanExplorerPayload<ExtArgs>[]
      LikeUrbanExplorer: Prisma.$LikeUrbanExplorerPayload<ExtArgs>[]
      BookmarkUrbanExplorer: Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>[]
      ReportUrbanExplorer: Prisma.$ReportUrbanExplorerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userUrbanExplorer"]>
    composites: {}
  }

  type UserUrbanExplorerGetPayload<S extends boolean | null | undefined | UserUrbanExplorerDefaultArgs> = $Result.GetResult<Prisma.$UserUrbanExplorerPayload, S>

  type UserUrbanExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserUrbanExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserUrbanExplorerCountAggregateInputType | true
    }

  export interface UserUrbanExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserUrbanExplorer'], meta: { name: 'UserUrbanExplorer' } }
    /**
     * Find zero or one UserUrbanExplorer that matches the filter.
     * @param {UserUrbanExplorerFindUniqueArgs} args - Arguments to find a UserUrbanExplorer
     * @example
     * // Get one UserUrbanExplorer
     * const userUrbanExplorer = await prisma.userUrbanExplorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserUrbanExplorerFindUniqueArgs>(args: SelectSubset<T, UserUrbanExplorerFindUniqueArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserUrbanExplorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserUrbanExplorerFindUniqueOrThrowArgs} args - Arguments to find a UserUrbanExplorer
     * @example
     * // Get one UserUrbanExplorer
     * const userUrbanExplorer = await prisma.userUrbanExplorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserUrbanExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserUrbanExplorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerFindFirstArgs} args - Arguments to find a UserUrbanExplorer
     * @example
     * // Get one UserUrbanExplorer
     * const userUrbanExplorer = await prisma.userUrbanExplorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserUrbanExplorerFindFirstArgs>(args?: SelectSubset<T, UserUrbanExplorerFindFirstArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserUrbanExplorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerFindFirstOrThrowArgs} args - Arguments to find a UserUrbanExplorer
     * @example
     * // Get one UserUrbanExplorer
     * const userUrbanExplorer = await prisma.userUrbanExplorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserUrbanExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserUrbanExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserUrbanExplorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserUrbanExplorers
     * const userUrbanExplorers = await prisma.userUrbanExplorer.findMany()
     * 
     * // Get first 10 UserUrbanExplorers
     * const userUrbanExplorers = await prisma.userUrbanExplorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userUrbanExplorerWithIdOnly = await prisma.userUrbanExplorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserUrbanExplorerFindManyArgs>(args?: SelectSubset<T, UserUrbanExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserUrbanExplorer.
     * @param {UserUrbanExplorerCreateArgs} args - Arguments to create a UserUrbanExplorer.
     * @example
     * // Create one UserUrbanExplorer
     * const UserUrbanExplorer = await prisma.userUrbanExplorer.create({
     *   data: {
     *     // ... data to create a UserUrbanExplorer
     *   }
     * })
     * 
     */
    create<T extends UserUrbanExplorerCreateArgs>(args: SelectSubset<T, UserUrbanExplorerCreateArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserUrbanExplorers.
     * @param {UserUrbanExplorerCreateManyArgs} args - Arguments to create many UserUrbanExplorers.
     * @example
     * // Create many UserUrbanExplorers
     * const userUrbanExplorer = await prisma.userUrbanExplorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserUrbanExplorerCreateManyArgs>(args?: SelectSubset<T, UserUrbanExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserUrbanExplorers and returns the data saved in the database.
     * @param {UserUrbanExplorerCreateManyAndReturnArgs} args - Arguments to create many UserUrbanExplorers.
     * @example
     * // Create many UserUrbanExplorers
     * const userUrbanExplorer = await prisma.userUrbanExplorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserUrbanExplorers and only return the `id`
     * const userUrbanExplorerWithIdOnly = await prisma.userUrbanExplorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserUrbanExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserUrbanExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserUrbanExplorer.
     * @param {UserUrbanExplorerDeleteArgs} args - Arguments to delete one UserUrbanExplorer.
     * @example
     * // Delete one UserUrbanExplorer
     * const UserUrbanExplorer = await prisma.userUrbanExplorer.delete({
     *   where: {
     *     // ... filter to delete one UserUrbanExplorer
     *   }
     * })
     * 
     */
    delete<T extends UserUrbanExplorerDeleteArgs>(args: SelectSubset<T, UserUrbanExplorerDeleteArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserUrbanExplorer.
     * @param {UserUrbanExplorerUpdateArgs} args - Arguments to update one UserUrbanExplorer.
     * @example
     * // Update one UserUrbanExplorer
     * const userUrbanExplorer = await prisma.userUrbanExplorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUrbanExplorerUpdateArgs>(args: SelectSubset<T, UserUrbanExplorerUpdateArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserUrbanExplorers.
     * @param {UserUrbanExplorerDeleteManyArgs} args - Arguments to filter UserUrbanExplorers to delete.
     * @example
     * // Delete a few UserUrbanExplorers
     * const { count } = await prisma.userUrbanExplorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserUrbanExplorerDeleteManyArgs>(args?: SelectSubset<T, UserUrbanExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserUrbanExplorers
     * const userUrbanExplorer = await prisma.userUrbanExplorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUrbanExplorerUpdateManyArgs>(args: SelectSubset<T, UserUrbanExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserUrbanExplorers and returns the data updated in the database.
     * @param {UserUrbanExplorerUpdateManyAndReturnArgs} args - Arguments to update many UserUrbanExplorers.
     * @example
     * // Update many UserUrbanExplorers
     * const userUrbanExplorer = await prisma.userUrbanExplorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserUrbanExplorers and only return the `id`
     * const userUrbanExplorerWithIdOnly = await prisma.userUrbanExplorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUrbanExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserUrbanExplorer.
     * @param {UserUrbanExplorerUpsertArgs} args - Arguments to update or create a UserUrbanExplorer.
     * @example
     * // Update or create a UserUrbanExplorer
     * const userUrbanExplorer = await prisma.userUrbanExplorer.upsert({
     *   create: {
     *     // ... data to create a UserUrbanExplorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserUrbanExplorer we want to update
     *   }
     * })
     */
    upsert<T extends UserUrbanExplorerUpsertArgs>(args: SelectSubset<T, UserUrbanExplorerUpsertArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerCountArgs} args - Arguments to filter UserUrbanExplorers to count.
     * @example
     * // Count the number of UserUrbanExplorers
     * const count = await prisma.userUrbanExplorer.count({
     *   where: {
     *     // ... the filter for the UserUrbanExplorers we want to count
     *   }
     * })
    **/
    count<T extends UserUrbanExplorerCountArgs>(
      args?: Subset<T, UserUrbanExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserUrbanExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserUrbanExplorerAggregateArgs>(args: Subset<T, UserUrbanExplorerAggregateArgs>): Prisma.PrismaPromise<GetUserUrbanExplorerAggregateType<T>>

    /**
     * Group by UserUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUrbanExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserUrbanExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserUrbanExplorerGroupByArgs['orderBy'] }
        : { orderBy?: UserUrbanExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserUrbanExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserUrbanExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserUrbanExplorer model
   */
  readonly fields: UserUrbanExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserUrbanExplorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserUrbanExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PlaceUrbanExplorer<T extends UserUrbanExplorer$PlaceUrbanExplorerArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorer$PlaceUrbanExplorerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReviewUrbanExplorer<T extends UserUrbanExplorer$ReviewUrbanExplorerArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorer$ReviewUrbanExplorerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LikeUrbanExplorer<T extends UserUrbanExplorer$LikeUrbanExplorerArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorer$LikeUrbanExplorerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BookmarkUrbanExplorer<T extends UserUrbanExplorer$BookmarkUrbanExplorerArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorer$BookmarkUrbanExplorerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ReportUrbanExplorer<T extends UserUrbanExplorer$ReportUrbanExplorerArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorer$ReportUrbanExplorerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserUrbanExplorer model
   */ 
  interface UserUrbanExplorerFieldRefs {
    readonly id: FieldRef<"UserUrbanExplorer", 'String'>
    readonly email: FieldRef<"UserUrbanExplorer", 'String'>
    readonly name: FieldRef<"UserUrbanExplorer", 'String'>
    readonly password: FieldRef<"UserUrbanExplorer", 'String'>
    readonly createdAt: FieldRef<"UserUrbanExplorer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserUrbanExplorer findUnique
   */
  export type UserUrbanExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which UserUrbanExplorer to fetch.
     */
    where: UserUrbanExplorerWhereUniqueInput
  }

  /**
   * UserUrbanExplorer findUniqueOrThrow
   */
  export type UserUrbanExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which UserUrbanExplorer to fetch.
     */
    where: UserUrbanExplorerWhereUniqueInput
  }

  /**
   * UserUrbanExplorer findFirst
   */
  export type UserUrbanExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which UserUrbanExplorer to fetch.
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUrbanExplorers to fetch.
     */
    orderBy?: UserUrbanExplorerOrderByWithRelationInput | UserUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserUrbanExplorers.
     */
    cursor?: UserUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserUrbanExplorers.
     */
    distinct?: UserUrbanExplorerScalarFieldEnum | UserUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer findFirstOrThrow
   */
  export type UserUrbanExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which UserUrbanExplorer to fetch.
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUrbanExplorers to fetch.
     */
    orderBy?: UserUrbanExplorerOrderByWithRelationInput | UserUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserUrbanExplorers.
     */
    cursor?: UserUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserUrbanExplorers.
     */
    distinct?: UserUrbanExplorerScalarFieldEnum | UserUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer findMany
   */
  export type UserUrbanExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which UserUrbanExplorers to fetch.
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserUrbanExplorers to fetch.
     */
    orderBy?: UserUrbanExplorerOrderByWithRelationInput | UserUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserUrbanExplorers.
     */
    cursor?: UserUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserUrbanExplorers.
     */
    skip?: number
    distinct?: UserUrbanExplorerScalarFieldEnum | UserUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer create
   */
  export type UserUrbanExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserUrbanExplorer.
     */
    data: XOR<UserUrbanExplorerCreateInput, UserUrbanExplorerUncheckedCreateInput>
  }

  /**
   * UserUrbanExplorer createMany
   */
  export type UserUrbanExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserUrbanExplorers.
     */
    data: UserUrbanExplorerCreateManyInput | UserUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserUrbanExplorer createManyAndReturn
   */
  export type UserUrbanExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many UserUrbanExplorers.
     */
    data: UserUrbanExplorerCreateManyInput | UserUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserUrbanExplorer update
   */
  export type UserUrbanExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserUrbanExplorer.
     */
    data: XOR<UserUrbanExplorerUpdateInput, UserUrbanExplorerUncheckedUpdateInput>
    /**
     * Choose, which UserUrbanExplorer to update.
     */
    where: UserUrbanExplorerWhereUniqueInput
  }

  /**
   * UserUrbanExplorer updateMany
   */
  export type UserUrbanExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserUrbanExplorers.
     */
    data: XOR<UserUrbanExplorerUpdateManyMutationInput, UserUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which UserUrbanExplorers to update
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * Limit how many UserUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * UserUrbanExplorer updateManyAndReturn
   */
  export type UserUrbanExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to update UserUrbanExplorers.
     */
    data: XOR<UserUrbanExplorerUpdateManyMutationInput, UserUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which UserUrbanExplorers to update
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * Limit how many UserUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * UserUrbanExplorer upsert
   */
  export type UserUrbanExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserUrbanExplorer to update in case it exists.
     */
    where: UserUrbanExplorerWhereUniqueInput
    /**
     * In case the UserUrbanExplorer found by the `where` argument doesn't exist, create a new UserUrbanExplorer with this data.
     */
    create: XOR<UserUrbanExplorerCreateInput, UserUrbanExplorerUncheckedCreateInput>
    /**
     * In case the UserUrbanExplorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUrbanExplorerUpdateInput, UserUrbanExplorerUncheckedUpdateInput>
  }

  /**
   * UserUrbanExplorer delete
   */
  export type UserUrbanExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter which UserUrbanExplorer to delete.
     */
    where: UserUrbanExplorerWhereUniqueInput
  }

  /**
   * UserUrbanExplorer deleteMany
   */
  export type UserUrbanExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserUrbanExplorers to delete
     */
    where?: UserUrbanExplorerWhereInput
    /**
     * Limit how many UserUrbanExplorers to delete.
     */
    limit?: number
  }

  /**
   * UserUrbanExplorer.PlaceUrbanExplorer
   */
  export type UserUrbanExplorer$PlaceUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    where?: PlaceUrbanExplorerWhereInput
    orderBy?: PlaceUrbanExplorerOrderByWithRelationInput | PlaceUrbanExplorerOrderByWithRelationInput[]
    cursor?: PlaceUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceUrbanExplorerScalarFieldEnum | PlaceUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer.ReviewUrbanExplorer
   */
  export type UserUrbanExplorer$ReviewUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    where?: ReviewUrbanExplorerWhereInput
    orderBy?: ReviewUrbanExplorerOrderByWithRelationInput | ReviewUrbanExplorerOrderByWithRelationInput[]
    cursor?: ReviewUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewUrbanExplorerScalarFieldEnum | ReviewUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer.LikeUrbanExplorer
   */
  export type UserUrbanExplorer$LikeUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    where?: LikeUrbanExplorerWhereInput
    orderBy?: LikeUrbanExplorerOrderByWithRelationInput | LikeUrbanExplorerOrderByWithRelationInput[]
    cursor?: LikeUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeUrbanExplorerScalarFieldEnum | LikeUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer.BookmarkUrbanExplorer
   */
  export type UserUrbanExplorer$BookmarkUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    where?: BookmarkUrbanExplorerWhereInput
    orderBy?: BookmarkUrbanExplorerOrderByWithRelationInput | BookmarkUrbanExplorerOrderByWithRelationInput[]
    cursor?: BookmarkUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkUrbanExplorerScalarFieldEnum | BookmarkUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer.ReportUrbanExplorer
   */
  export type UserUrbanExplorer$ReportUrbanExplorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    where?: ReportUrbanExplorerWhereInput
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    cursor?: ReportUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUrbanExplorerScalarFieldEnum | ReportUrbanExplorerScalarFieldEnum[]
  }

  /**
   * UserUrbanExplorer without action
   */
  export type UserUrbanExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserUrbanExplorer
     */
    select?: UserUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserUrbanExplorer
     */
    omit?: UserUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserUrbanExplorerInclude<ExtArgs> | null
  }


  /**
   * Model PlaceUrbanExplorer
   */

  export type AggregatePlaceUrbanExplorer = {
    _count: PlaceUrbanExplorerCountAggregateOutputType | null
    _min: PlaceUrbanExplorerMinAggregateOutputType | null
    _max: PlaceUrbanExplorerMaxAggregateOutputType | null
  }

  export type PlaceUrbanExplorerMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    location: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    validated: boolean | null
  }

  export type PlaceUrbanExplorerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    location: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    validated: boolean | null
  }

  export type PlaceUrbanExplorerCountAggregateOutputType = {
    id: number
    name: number
    category: number
    location: number
    description: number
    ownerId: number
    createdAt: number
    validated: number
    _all: number
  }


  export type PlaceUrbanExplorerMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    location?: true
    description?: true
    ownerId?: true
    createdAt?: true
    validated?: true
  }

  export type PlaceUrbanExplorerMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    location?: true
    description?: true
    ownerId?: true
    createdAt?: true
    validated?: true
  }

  export type PlaceUrbanExplorerCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    location?: true
    description?: true
    ownerId?: true
    createdAt?: true
    validated?: true
    _all?: true
  }

  export type PlaceUrbanExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceUrbanExplorer to aggregate.
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceUrbanExplorers to fetch.
     */
    orderBy?: PlaceUrbanExplorerOrderByWithRelationInput | PlaceUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceUrbanExplorers
    **/
    _count?: true | PlaceUrbanExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceUrbanExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceUrbanExplorerMaxAggregateInputType
  }

  export type GetPlaceUrbanExplorerAggregateType<T extends PlaceUrbanExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceUrbanExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceUrbanExplorer[P]>
      : GetScalarType<T[P], AggregatePlaceUrbanExplorer[P]>
  }




  export type PlaceUrbanExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceUrbanExplorerWhereInput
    orderBy?: PlaceUrbanExplorerOrderByWithAggregationInput | PlaceUrbanExplorerOrderByWithAggregationInput[]
    by: PlaceUrbanExplorerScalarFieldEnum[] | PlaceUrbanExplorerScalarFieldEnum
    having?: PlaceUrbanExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceUrbanExplorerCountAggregateInputType | true
    _min?: PlaceUrbanExplorerMinAggregateInputType
    _max?: PlaceUrbanExplorerMaxAggregateInputType
  }

  export type PlaceUrbanExplorerGroupByOutputType = {
    id: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt: Date
    validated: boolean
    _count: PlaceUrbanExplorerCountAggregateOutputType | null
    _min: PlaceUrbanExplorerMinAggregateOutputType | null
    _max: PlaceUrbanExplorerMaxAggregateOutputType | null
  }

  type GetPlaceUrbanExplorerGroupByPayload<T extends PlaceUrbanExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceUrbanExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceUrbanExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceUrbanExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceUrbanExplorerGroupByOutputType[P]>
        }
      >
    >


  export type PlaceUrbanExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    validated?: boolean
    owner?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    reviews?: boolean | PlaceUrbanExplorer$reviewsArgs<ExtArgs>
    bookmarks?: boolean | PlaceUrbanExplorer$bookmarksArgs<ExtArgs>
    likes?: boolean | PlaceUrbanExplorer$likesArgs<ExtArgs>
    reports?: boolean | PlaceUrbanExplorer$reportsArgs<ExtArgs>
    _count?: boolean | PlaceUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeUrbanExplorer"]>

  export type PlaceUrbanExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    validated?: boolean
    owner?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeUrbanExplorer"]>

  export type PlaceUrbanExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    validated?: boolean
    owner?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeUrbanExplorer"]>

  export type PlaceUrbanExplorerSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    validated?: boolean
  }

  export type PlaceUrbanExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "location" | "description" | "ownerId" | "createdAt" | "validated", ExtArgs["result"]["placeUrbanExplorer"]>
  export type PlaceUrbanExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    reviews?: boolean | PlaceUrbanExplorer$reviewsArgs<ExtArgs>
    bookmarks?: boolean | PlaceUrbanExplorer$bookmarksArgs<ExtArgs>
    likes?: boolean | PlaceUrbanExplorer$likesArgs<ExtArgs>
    reports?: boolean | PlaceUrbanExplorer$reportsArgs<ExtArgs>
    _count?: boolean | PlaceUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaceUrbanExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
  }
  export type PlaceUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
  }

  export type $PlaceUrbanExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceUrbanExplorer"
    objects: {
      owner: Prisma.$UserUrbanExplorerPayload<ExtArgs>
      reviews: Prisma.$ReviewUrbanExplorerPayload<ExtArgs>[]
      bookmarks: Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>[]
      likes: Prisma.$LikeUrbanExplorerPayload<ExtArgs>[]
      reports: Prisma.$ReportUrbanExplorerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      location: string
      description: string
      ownerId: string
      createdAt: Date
      validated: boolean
    }, ExtArgs["result"]["placeUrbanExplorer"]>
    composites: {}
  }

  type PlaceUrbanExplorerGetPayload<S extends boolean | null | undefined | PlaceUrbanExplorerDefaultArgs> = $Result.GetResult<Prisma.$PlaceUrbanExplorerPayload, S>

  type PlaceUrbanExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceUrbanExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceUrbanExplorerCountAggregateInputType | true
    }

  export interface PlaceUrbanExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceUrbanExplorer'], meta: { name: 'PlaceUrbanExplorer' } }
    /**
     * Find zero or one PlaceUrbanExplorer that matches the filter.
     * @param {PlaceUrbanExplorerFindUniqueArgs} args - Arguments to find a PlaceUrbanExplorer
     * @example
     * // Get one PlaceUrbanExplorer
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceUrbanExplorerFindUniqueArgs>(args: SelectSubset<T, PlaceUrbanExplorerFindUniqueArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceUrbanExplorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceUrbanExplorerFindUniqueOrThrowArgs} args - Arguments to find a PlaceUrbanExplorer
     * @example
     * // Get one PlaceUrbanExplorer
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceUrbanExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceUrbanExplorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerFindFirstArgs} args - Arguments to find a PlaceUrbanExplorer
     * @example
     * // Get one PlaceUrbanExplorer
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceUrbanExplorerFindFirstArgs>(args?: SelectSubset<T, PlaceUrbanExplorerFindFirstArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceUrbanExplorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerFindFirstOrThrowArgs} args - Arguments to find a PlaceUrbanExplorer
     * @example
     * // Get one PlaceUrbanExplorer
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceUrbanExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceUrbanExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceUrbanExplorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceUrbanExplorers
     * const placeUrbanExplorers = await prisma.placeUrbanExplorer.findMany()
     * 
     * // Get first 10 PlaceUrbanExplorers
     * const placeUrbanExplorers = await prisma.placeUrbanExplorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeUrbanExplorerWithIdOnly = await prisma.placeUrbanExplorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceUrbanExplorerFindManyArgs>(args?: SelectSubset<T, PlaceUrbanExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceUrbanExplorer.
     * @param {PlaceUrbanExplorerCreateArgs} args - Arguments to create a PlaceUrbanExplorer.
     * @example
     * // Create one PlaceUrbanExplorer
     * const PlaceUrbanExplorer = await prisma.placeUrbanExplorer.create({
     *   data: {
     *     // ... data to create a PlaceUrbanExplorer
     *   }
     * })
     * 
     */
    create<T extends PlaceUrbanExplorerCreateArgs>(args: SelectSubset<T, PlaceUrbanExplorerCreateArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceUrbanExplorers.
     * @param {PlaceUrbanExplorerCreateManyArgs} args - Arguments to create many PlaceUrbanExplorers.
     * @example
     * // Create many PlaceUrbanExplorers
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceUrbanExplorerCreateManyArgs>(args?: SelectSubset<T, PlaceUrbanExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaceUrbanExplorers and returns the data saved in the database.
     * @param {PlaceUrbanExplorerCreateManyAndReturnArgs} args - Arguments to create many PlaceUrbanExplorers.
     * @example
     * // Create many PlaceUrbanExplorers
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaceUrbanExplorers and only return the `id`
     * const placeUrbanExplorerWithIdOnly = await prisma.placeUrbanExplorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceUrbanExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceUrbanExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaceUrbanExplorer.
     * @param {PlaceUrbanExplorerDeleteArgs} args - Arguments to delete one PlaceUrbanExplorer.
     * @example
     * // Delete one PlaceUrbanExplorer
     * const PlaceUrbanExplorer = await prisma.placeUrbanExplorer.delete({
     *   where: {
     *     // ... filter to delete one PlaceUrbanExplorer
     *   }
     * })
     * 
     */
    delete<T extends PlaceUrbanExplorerDeleteArgs>(args: SelectSubset<T, PlaceUrbanExplorerDeleteArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceUrbanExplorer.
     * @param {PlaceUrbanExplorerUpdateArgs} args - Arguments to update one PlaceUrbanExplorer.
     * @example
     * // Update one PlaceUrbanExplorer
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceUrbanExplorerUpdateArgs>(args: SelectSubset<T, PlaceUrbanExplorerUpdateArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceUrbanExplorers.
     * @param {PlaceUrbanExplorerDeleteManyArgs} args - Arguments to filter PlaceUrbanExplorers to delete.
     * @example
     * // Delete a few PlaceUrbanExplorers
     * const { count } = await prisma.placeUrbanExplorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceUrbanExplorerDeleteManyArgs>(args?: SelectSubset<T, PlaceUrbanExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceUrbanExplorers
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceUrbanExplorerUpdateManyArgs>(args: SelectSubset<T, PlaceUrbanExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceUrbanExplorers and returns the data updated in the database.
     * @param {PlaceUrbanExplorerUpdateManyAndReturnArgs} args - Arguments to update many PlaceUrbanExplorers.
     * @example
     * // Update many PlaceUrbanExplorers
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaceUrbanExplorers and only return the `id`
     * const placeUrbanExplorerWithIdOnly = await prisma.placeUrbanExplorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceUrbanExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaceUrbanExplorer.
     * @param {PlaceUrbanExplorerUpsertArgs} args - Arguments to update or create a PlaceUrbanExplorer.
     * @example
     * // Update or create a PlaceUrbanExplorer
     * const placeUrbanExplorer = await prisma.placeUrbanExplorer.upsert({
     *   create: {
     *     // ... data to create a PlaceUrbanExplorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceUrbanExplorer we want to update
     *   }
     * })
     */
    upsert<T extends PlaceUrbanExplorerUpsertArgs>(args: SelectSubset<T, PlaceUrbanExplorerUpsertArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerCountArgs} args - Arguments to filter PlaceUrbanExplorers to count.
     * @example
     * // Count the number of PlaceUrbanExplorers
     * const count = await prisma.placeUrbanExplorer.count({
     *   where: {
     *     // ... the filter for the PlaceUrbanExplorers we want to count
     *   }
     * })
    **/
    count<T extends PlaceUrbanExplorerCountArgs>(
      args?: Subset<T, PlaceUrbanExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceUrbanExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceUrbanExplorerAggregateArgs>(args: Subset<T, PlaceUrbanExplorerAggregateArgs>): Prisma.PrismaPromise<GetPlaceUrbanExplorerAggregateType<T>>

    /**
     * Group by PlaceUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUrbanExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceUrbanExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceUrbanExplorerGroupByArgs['orderBy'] }
        : { orderBy?: PlaceUrbanExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceUrbanExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceUrbanExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceUrbanExplorer model
   */
  readonly fields: PlaceUrbanExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceUrbanExplorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceUrbanExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends PlaceUrbanExplorer$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorer$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookmarks<T extends PlaceUrbanExplorer$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorer$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends PlaceUrbanExplorer$likesArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorer$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends PlaceUrbanExplorer$reportsArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorer$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceUrbanExplorer model
   */ 
  interface PlaceUrbanExplorerFieldRefs {
    readonly id: FieldRef<"PlaceUrbanExplorer", 'String'>
    readonly name: FieldRef<"PlaceUrbanExplorer", 'String'>
    readonly category: FieldRef<"PlaceUrbanExplorer", 'String'>
    readonly location: FieldRef<"PlaceUrbanExplorer", 'String'>
    readonly description: FieldRef<"PlaceUrbanExplorer", 'String'>
    readonly ownerId: FieldRef<"PlaceUrbanExplorer", 'String'>
    readonly createdAt: FieldRef<"PlaceUrbanExplorer", 'DateTime'>
    readonly validated: FieldRef<"PlaceUrbanExplorer", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PlaceUrbanExplorer findUnique
   */
  export type PlaceUrbanExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which PlaceUrbanExplorer to fetch.
     */
    where: PlaceUrbanExplorerWhereUniqueInput
  }

  /**
   * PlaceUrbanExplorer findUniqueOrThrow
   */
  export type PlaceUrbanExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which PlaceUrbanExplorer to fetch.
     */
    where: PlaceUrbanExplorerWhereUniqueInput
  }

  /**
   * PlaceUrbanExplorer findFirst
   */
  export type PlaceUrbanExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which PlaceUrbanExplorer to fetch.
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceUrbanExplorers to fetch.
     */
    orderBy?: PlaceUrbanExplorerOrderByWithRelationInput | PlaceUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceUrbanExplorers.
     */
    cursor?: PlaceUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceUrbanExplorers.
     */
    distinct?: PlaceUrbanExplorerScalarFieldEnum | PlaceUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer findFirstOrThrow
   */
  export type PlaceUrbanExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which PlaceUrbanExplorer to fetch.
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceUrbanExplorers to fetch.
     */
    orderBy?: PlaceUrbanExplorerOrderByWithRelationInput | PlaceUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceUrbanExplorers.
     */
    cursor?: PlaceUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceUrbanExplorers.
     */
    distinct?: PlaceUrbanExplorerScalarFieldEnum | PlaceUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer findMany
   */
  export type PlaceUrbanExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which PlaceUrbanExplorers to fetch.
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceUrbanExplorers to fetch.
     */
    orderBy?: PlaceUrbanExplorerOrderByWithRelationInput | PlaceUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceUrbanExplorers.
     */
    cursor?: PlaceUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceUrbanExplorers.
     */
    skip?: number
    distinct?: PlaceUrbanExplorerScalarFieldEnum | PlaceUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer create
   */
  export type PlaceUrbanExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceUrbanExplorer.
     */
    data: XOR<PlaceUrbanExplorerCreateInput, PlaceUrbanExplorerUncheckedCreateInput>
  }

  /**
   * PlaceUrbanExplorer createMany
   */
  export type PlaceUrbanExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceUrbanExplorers.
     */
    data: PlaceUrbanExplorerCreateManyInput | PlaceUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceUrbanExplorer createManyAndReturn
   */
  export type PlaceUrbanExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many PlaceUrbanExplorers.
     */
    data: PlaceUrbanExplorerCreateManyInput | PlaceUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceUrbanExplorer update
   */
  export type PlaceUrbanExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceUrbanExplorer.
     */
    data: XOR<PlaceUrbanExplorerUpdateInput, PlaceUrbanExplorerUncheckedUpdateInput>
    /**
     * Choose, which PlaceUrbanExplorer to update.
     */
    where: PlaceUrbanExplorerWhereUniqueInput
  }

  /**
   * PlaceUrbanExplorer updateMany
   */
  export type PlaceUrbanExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceUrbanExplorers.
     */
    data: XOR<PlaceUrbanExplorerUpdateManyMutationInput, PlaceUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which PlaceUrbanExplorers to update
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * Limit how many PlaceUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * PlaceUrbanExplorer updateManyAndReturn
   */
  export type PlaceUrbanExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to update PlaceUrbanExplorers.
     */
    data: XOR<PlaceUrbanExplorerUpdateManyMutationInput, PlaceUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which PlaceUrbanExplorers to update
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * Limit how many PlaceUrbanExplorers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceUrbanExplorer upsert
   */
  export type PlaceUrbanExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceUrbanExplorer to update in case it exists.
     */
    where: PlaceUrbanExplorerWhereUniqueInput
    /**
     * In case the PlaceUrbanExplorer found by the `where` argument doesn't exist, create a new PlaceUrbanExplorer with this data.
     */
    create: XOR<PlaceUrbanExplorerCreateInput, PlaceUrbanExplorerUncheckedCreateInput>
    /**
     * In case the PlaceUrbanExplorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceUrbanExplorerUpdateInput, PlaceUrbanExplorerUncheckedUpdateInput>
  }

  /**
   * PlaceUrbanExplorer delete
   */
  export type PlaceUrbanExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter which PlaceUrbanExplorer to delete.
     */
    where: PlaceUrbanExplorerWhereUniqueInput
  }

  /**
   * PlaceUrbanExplorer deleteMany
   */
  export type PlaceUrbanExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceUrbanExplorers to delete
     */
    where?: PlaceUrbanExplorerWhereInput
    /**
     * Limit how many PlaceUrbanExplorers to delete.
     */
    limit?: number
  }

  /**
   * PlaceUrbanExplorer.reviews
   */
  export type PlaceUrbanExplorer$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    where?: ReviewUrbanExplorerWhereInput
    orderBy?: ReviewUrbanExplorerOrderByWithRelationInput | ReviewUrbanExplorerOrderByWithRelationInput[]
    cursor?: ReviewUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewUrbanExplorerScalarFieldEnum | ReviewUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer.bookmarks
   */
  export type PlaceUrbanExplorer$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    where?: BookmarkUrbanExplorerWhereInput
    orderBy?: BookmarkUrbanExplorerOrderByWithRelationInput | BookmarkUrbanExplorerOrderByWithRelationInput[]
    cursor?: BookmarkUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkUrbanExplorerScalarFieldEnum | BookmarkUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer.likes
   */
  export type PlaceUrbanExplorer$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    where?: LikeUrbanExplorerWhereInput
    orderBy?: LikeUrbanExplorerOrderByWithRelationInput | LikeUrbanExplorerOrderByWithRelationInput[]
    cursor?: LikeUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeUrbanExplorerScalarFieldEnum | LikeUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer.reports
   */
  export type PlaceUrbanExplorer$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    where?: ReportUrbanExplorerWhereInput
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    cursor?: ReportUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUrbanExplorerScalarFieldEnum | ReportUrbanExplorerScalarFieldEnum[]
  }

  /**
   * PlaceUrbanExplorer without action
   */
  export type PlaceUrbanExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
  }


  /**
   * Model ReviewUrbanExplorer
   */

  export type AggregateReviewUrbanExplorer = {
    _count: ReviewUrbanExplorerCountAggregateOutputType | null
    _avg: ReviewUrbanExplorerAvgAggregateOutputType | null
    _sum: ReviewUrbanExplorerSumAggregateOutputType | null
    _min: ReviewUrbanExplorerMinAggregateOutputType | null
    _max: ReviewUrbanExplorerMaxAggregateOutputType | null
  }

  export type ReviewUrbanExplorerAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewUrbanExplorerSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewUrbanExplorerMinAggregateOutputType = {
    id: string | null
    placeId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewUrbanExplorerMaxAggregateOutputType = {
    id: string | null
    placeId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewUrbanExplorerCountAggregateOutputType = {
    id: number
    placeId: number
    userId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ReviewUrbanExplorerAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewUrbanExplorerSumAggregateInputType = {
    rating?: true
  }

  export type ReviewUrbanExplorerMinAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewUrbanExplorerMaxAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewUrbanExplorerCountAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewUrbanExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewUrbanExplorer to aggregate.
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUrbanExplorers to fetch.
     */
    orderBy?: ReviewUrbanExplorerOrderByWithRelationInput | ReviewUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewUrbanExplorers
    **/
    _count?: true | ReviewUrbanExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewUrbanExplorerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewUrbanExplorerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewUrbanExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewUrbanExplorerMaxAggregateInputType
  }

  export type GetReviewUrbanExplorerAggregateType<T extends ReviewUrbanExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewUrbanExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewUrbanExplorer[P]>
      : GetScalarType<T[P], AggregateReviewUrbanExplorer[P]>
  }




  export type ReviewUrbanExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewUrbanExplorerWhereInput
    orderBy?: ReviewUrbanExplorerOrderByWithAggregationInput | ReviewUrbanExplorerOrderByWithAggregationInput[]
    by: ReviewUrbanExplorerScalarFieldEnum[] | ReviewUrbanExplorerScalarFieldEnum
    having?: ReviewUrbanExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewUrbanExplorerCountAggregateInputType | true
    _avg?: ReviewUrbanExplorerAvgAggregateInputType
    _sum?: ReviewUrbanExplorerSumAggregateInputType
    _min?: ReviewUrbanExplorerMinAggregateInputType
    _max?: ReviewUrbanExplorerMaxAggregateInputType
  }

  export type ReviewUrbanExplorerGroupByOutputType = {
    id: string
    placeId: string
    userId: string
    rating: number
    comment: string
    createdAt: Date
    _count: ReviewUrbanExplorerCountAggregateOutputType | null
    _avg: ReviewUrbanExplorerAvgAggregateOutputType | null
    _sum: ReviewUrbanExplorerSumAggregateOutputType | null
    _min: ReviewUrbanExplorerMinAggregateOutputType | null
    _max: ReviewUrbanExplorerMaxAggregateOutputType | null
  }

  type GetReviewUrbanExplorerGroupByPayload<T extends ReviewUrbanExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewUrbanExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewUrbanExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewUrbanExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewUrbanExplorerGroupByOutputType[P]>
        }
      >
    >


  export type ReviewUrbanExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
    reports?: boolean | ReviewUrbanExplorer$reportsArgs<ExtArgs>
    _count?: boolean | ReviewUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewUrbanExplorer"]>

  export type ReviewUrbanExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewUrbanExplorer"]>

  export type ReviewUrbanExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewUrbanExplorer"]>

  export type ReviewUrbanExplorerSelectScalar = {
    id?: boolean
    placeId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ReviewUrbanExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "userId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["reviewUrbanExplorer"]>
  export type ReviewUrbanExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
    reports?: boolean | ReviewUrbanExplorer$reportsArgs<ExtArgs>
    _count?: boolean | ReviewUrbanExplorerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewUrbanExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }
  export type ReviewUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }

  export type $ReviewUrbanExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewUrbanExplorer"
    objects: {
      user: Prisma.$UserUrbanExplorerPayload<ExtArgs>
      place: Prisma.$PlaceUrbanExplorerPayload<ExtArgs>
      reports: Prisma.$ReportUrbanExplorerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      placeId: string
      userId: string
      rating: number
      comment: string
      createdAt: Date
    }, ExtArgs["result"]["reviewUrbanExplorer"]>
    composites: {}
  }

  type ReviewUrbanExplorerGetPayload<S extends boolean | null | undefined | ReviewUrbanExplorerDefaultArgs> = $Result.GetResult<Prisma.$ReviewUrbanExplorerPayload, S>

  type ReviewUrbanExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewUrbanExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewUrbanExplorerCountAggregateInputType | true
    }

  export interface ReviewUrbanExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewUrbanExplorer'], meta: { name: 'ReviewUrbanExplorer' } }
    /**
     * Find zero or one ReviewUrbanExplorer that matches the filter.
     * @param {ReviewUrbanExplorerFindUniqueArgs} args - Arguments to find a ReviewUrbanExplorer
     * @example
     * // Get one ReviewUrbanExplorer
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewUrbanExplorerFindUniqueArgs>(args: SelectSubset<T, ReviewUrbanExplorerFindUniqueArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewUrbanExplorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewUrbanExplorerFindUniqueOrThrowArgs} args - Arguments to find a ReviewUrbanExplorer
     * @example
     * // Get one ReviewUrbanExplorer
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewUrbanExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewUrbanExplorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerFindFirstArgs} args - Arguments to find a ReviewUrbanExplorer
     * @example
     * // Get one ReviewUrbanExplorer
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewUrbanExplorerFindFirstArgs>(args?: SelectSubset<T, ReviewUrbanExplorerFindFirstArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewUrbanExplorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerFindFirstOrThrowArgs} args - Arguments to find a ReviewUrbanExplorer
     * @example
     * // Get one ReviewUrbanExplorer
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewUrbanExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewUrbanExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewUrbanExplorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewUrbanExplorers
     * const reviewUrbanExplorers = await prisma.reviewUrbanExplorer.findMany()
     * 
     * // Get first 10 ReviewUrbanExplorers
     * const reviewUrbanExplorers = await prisma.reviewUrbanExplorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewUrbanExplorerWithIdOnly = await prisma.reviewUrbanExplorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewUrbanExplorerFindManyArgs>(args?: SelectSubset<T, ReviewUrbanExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewUrbanExplorer.
     * @param {ReviewUrbanExplorerCreateArgs} args - Arguments to create a ReviewUrbanExplorer.
     * @example
     * // Create one ReviewUrbanExplorer
     * const ReviewUrbanExplorer = await prisma.reviewUrbanExplorer.create({
     *   data: {
     *     // ... data to create a ReviewUrbanExplorer
     *   }
     * })
     * 
     */
    create<T extends ReviewUrbanExplorerCreateArgs>(args: SelectSubset<T, ReviewUrbanExplorerCreateArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewUrbanExplorers.
     * @param {ReviewUrbanExplorerCreateManyArgs} args - Arguments to create many ReviewUrbanExplorers.
     * @example
     * // Create many ReviewUrbanExplorers
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewUrbanExplorerCreateManyArgs>(args?: SelectSubset<T, ReviewUrbanExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewUrbanExplorers and returns the data saved in the database.
     * @param {ReviewUrbanExplorerCreateManyAndReturnArgs} args - Arguments to create many ReviewUrbanExplorers.
     * @example
     * // Create many ReviewUrbanExplorers
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewUrbanExplorers and only return the `id`
     * const reviewUrbanExplorerWithIdOnly = await prisma.reviewUrbanExplorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewUrbanExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewUrbanExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewUrbanExplorer.
     * @param {ReviewUrbanExplorerDeleteArgs} args - Arguments to delete one ReviewUrbanExplorer.
     * @example
     * // Delete one ReviewUrbanExplorer
     * const ReviewUrbanExplorer = await prisma.reviewUrbanExplorer.delete({
     *   where: {
     *     // ... filter to delete one ReviewUrbanExplorer
     *   }
     * })
     * 
     */
    delete<T extends ReviewUrbanExplorerDeleteArgs>(args: SelectSubset<T, ReviewUrbanExplorerDeleteArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewUrbanExplorer.
     * @param {ReviewUrbanExplorerUpdateArgs} args - Arguments to update one ReviewUrbanExplorer.
     * @example
     * // Update one ReviewUrbanExplorer
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUrbanExplorerUpdateArgs>(args: SelectSubset<T, ReviewUrbanExplorerUpdateArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewUrbanExplorers.
     * @param {ReviewUrbanExplorerDeleteManyArgs} args - Arguments to filter ReviewUrbanExplorers to delete.
     * @example
     * // Delete a few ReviewUrbanExplorers
     * const { count } = await prisma.reviewUrbanExplorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewUrbanExplorerDeleteManyArgs>(args?: SelectSubset<T, ReviewUrbanExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewUrbanExplorers
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUrbanExplorerUpdateManyArgs>(args: SelectSubset<T, ReviewUrbanExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewUrbanExplorers and returns the data updated in the database.
     * @param {ReviewUrbanExplorerUpdateManyAndReturnArgs} args - Arguments to update many ReviewUrbanExplorers.
     * @example
     * // Update many ReviewUrbanExplorers
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewUrbanExplorers and only return the `id`
     * const reviewUrbanExplorerWithIdOnly = await prisma.reviewUrbanExplorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUrbanExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewUrbanExplorer.
     * @param {ReviewUrbanExplorerUpsertArgs} args - Arguments to update or create a ReviewUrbanExplorer.
     * @example
     * // Update or create a ReviewUrbanExplorer
     * const reviewUrbanExplorer = await prisma.reviewUrbanExplorer.upsert({
     *   create: {
     *     // ... data to create a ReviewUrbanExplorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewUrbanExplorer we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUrbanExplorerUpsertArgs>(args: SelectSubset<T, ReviewUrbanExplorerUpsertArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerCountArgs} args - Arguments to filter ReviewUrbanExplorers to count.
     * @example
     * // Count the number of ReviewUrbanExplorers
     * const count = await prisma.reviewUrbanExplorer.count({
     *   where: {
     *     // ... the filter for the ReviewUrbanExplorers we want to count
     *   }
     * })
    **/
    count<T extends ReviewUrbanExplorerCountArgs>(
      args?: Subset<T, ReviewUrbanExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewUrbanExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewUrbanExplorerAggregateArgs>(args: Subset<T, ReviewUrbanExplorerAggregateArgs>): Prisma.PrismaPromise<GetReviewUrbanExplorerAggregateType<T>>

    /**
     * Group by ReviewUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUrbanExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewUrbanExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewUrbanExplorerGroupByArgs['orderBy'] }
        : { orderBy?: ReviewUrbanExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewUrbanExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewUrbanExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewUrbanExplorer model
   */
  readonly fields: ReviewUrbanExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewUrbanExplorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewUrbanExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends PlaceUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reports<T extends ReviewUrbanExplorer$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ReviewUrbanExplorer$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewUrbanExplorer model
   */ 
  interface ReviewUrbanExplorerFieldRefs {
    readonly id: FieldRef<"ReviewUrbanExplorer", 'String'>
    readonly placeId: FieldRef<"ReviewUrbanExplorer", 'String'>
    readonly userId: FieldRef<"ReviewUrbanExplorer", 'String'>
    readonly rating: FieldRef<"ReviewUrbanExplorer", 'Int'>
    readonly comment: FieldRef<"ReviewUrbanExplorer", 'String'>
    readonly createdAt: FieldRef<"ReviewUrbanExplorer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewUrbanExplorer findUnique
   */
  export type ReviewUrbanExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUrbanExplorer to fetch.
     */
    where: ReviewUrbanExplorerWhereUniqueInput
  }

  /**
   * ReviewUrbanExplorer findUniqueOrThrow
   */
  export type ReviewUrbanExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUrbanExplorer to fetch.
     */
    where: ReviewUrbanExplorerWhereUniqueInput
  }

  /**
   * ReviewUrbanExplorer findFirst
   */
  export type ReviewUrbanExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUrbanExplorer to fetch.
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUrbanExplorers to fetch.
     */
    orderBy?: ReviewUrbanExplorerOrderByWithRelationInput | ReviewUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewUrbanExplorers.
     */
    cursor?: ReviewUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewUrbanExplorers.
     */
    distinct?: ReviewUrbanExplorerScalarFieldEnum | ReviewUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReviewUrbanExplorer findFirstOrThrow
   */
  export type ReviewUrbanExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUrbanExplorer to fetch.
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUrbanExplorers to fetch.
     */
    orderBy?: ReviewUrbanExplorerOrderByWithRelationInput | ReviewUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewUrbanExplorers.
     */
    cursor?: ReviewUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewUrbanExplorers.
     */
    distinct?: ReviewUrbanExplorerScalarFieldEnum | ReviewUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReviewUrbanExplorer findMany
   */
  export type ReviewUrbanExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewUrbanExplorers to fetch.
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewUrbanExplorers to fetch.
     */
    orderBy?: ReviewUrbanExplorerOrderByWithRelationInput | ReviewUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewUrbanExplorers.
     */
    cursor?: ReviewUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewUrbanExplorers.
     */
    skip?: number
    distinct?: ReviewUrbanExplorerScalarFieldEnum | ReviewUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReviewUrbanExplorer create
   */
  export type ReviewUrbanExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewUrbanExplorer.
     */
    data: XOR<ReviewUrbanExplorerCreateInput, ReviewUrbanExplorerUncheckedCreateInput>
  }

  /**
   * ReviewUrbanExplorer createMany
   */
  export type ReviewUrbanExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewUrbanExplorers.
     */
    data: ReviewUrbanExplorerCreateManyInput | ReviewUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewUrbanExplorer createManyAndReturn
   */
  export type ReviewUrbanExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewUrbanExplorers.
     */
    data: ReviewUrbanExplorerCreateManyInput | ReviewUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewUrbanExplorer update
   */
  export type ReviewUrbanExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewUrbanExplorer.
     */
    data: XOR<ReviewUrbanExplorerUpdateInput, ReviewUrbanExplorerUncheckedUpdateInput>
    /**
     * Choose, which ReviewUrbanExplorer to update.
     */
    where: ReviewUrbanExplorerWhereUniqueInput
  }

  /**
   * ReviewUrbanExplorer updateMany
   */
  export type ReviewUrbanExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewUrbanExplorers.
     */
    data: XOR<ReviewUrbanExplorerUpdateManyMutationInput, ReviewUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which ReviewUrbanExplorers to update
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * Limit how many ReviewUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * ReviewUrbanExplorer updateManyAndReturn
   */
  export type ReviewUrbanExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to update ReviewUrbanExplorers.
     */
    data: XOR<ReviewUrbanExplorerUpdateManyMutationInput, ReviewUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which ReviewUrbanExplorers to update
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * Limit how many ReviewUrbanExplorers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewUrbanExplorer upsert
   */
  export type ReviewUrbanExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewUrbanExplorer to update in case it exists.
     */
    where: ReviewUrbanExplorerWhereUniqueInput
    /**
     * In case the ReviewUrbanExplorer found by the `where` argument doesn't exist, create a new ReviewUrbanExplorer with this data.
     */
    create: XOR<ReviewUrbanExplorerCreateInput, ReviewUrbanExplorerUncheckedCreateInput>
    /**
     * In case the ReviewUrbanExplorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUrbanExplorerUpdateInput, ReviewUrbanExplorerUncheckedUpdateInput>
  }

  /**
   * ReviewUrbanExplorer delete
   */
  export type ReviewUrbanExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter which ReviewUrbanExplorer to delete.
     */
    where: ReviewUrbanExplorerWhereUniqueInput
  }

  /**
   * ReviewUrbanExplorer deleteMany
   */
  export type ReviewUrbanExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewUrbanExplorers to delete
     */
    where?: ReviewUrbanExplorerWhereInput
    /**
     * Limit how many ReviewUrbanExplorers to delete.
     */
    limit?: number
  }

  /**
   * ReviewUrbanExplorer.reports
   */
  export type ReviewUrbanExplorer$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    where?: ReportUrbanExplorerWhereInput
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    cursor?: ReportUrbanExplorerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportUrbanExplorerScalarFieldEnum | ReportUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReviewUrbanExplorer without action
   */
  export type ReviewUrbanExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
  }


  /**
   * Model LikeUrbanExplorer
   */

  export type AggregateLikeUrbanExplorer = {
    _count: LikeUrbanExplorerCountAggregateOutputType | null
    _min: LikeUrbanExplorerMinAggregateOutputType | null
    _max: LikeUrbanExplorerMaxAggregateOutputType | null
  }

  export type LikeUrbanExplorerMinAggregateOutputType = {
    id: string | null
    placeId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeUrbanExplorerMaxAggregateOutputType = {
    id: string | null
    placeId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type LikeUrbanExplorerCountAggregateOutputType = {
    id: number
    placeId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type LikeUrbanExplorerMinAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeUrbanExplorerMaxAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    createdAt?: true
  }

  export type LikeUrbanExplorerCountAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeUrbanExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeUrbanExplorer to aggregate.
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeUrbanExplorers to fetch.
     */
    orderBy?: LikeUrbanExplorerOrderByWithRelationInput | LikeUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LikeUrbanExplorers
    **/
    _count?: true | LikeUrbanExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeUrbanExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeUrbanExplorerMaxAggregateInputType
  }

  export type GetLikeUrbanExplorerAggregateType<T extends LikeUrbanExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregateLikeUrbanExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikeUrbanExplorer[P]>
      : GetScalarType<T[P], AggregateLikeUrbanExplorer[P]>
  }




  export type LikeUrbanExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeUrbanExplorerWhereInput
    orderBy?: LikeUrbanExplorerOrderByWithAggregationInput | LikeUrbanExplorerOrderByWithAggregationInput[]
    by: LikeUrbanExplorerScalarFieldEnum[] | LikeUrbanExplorerScalarFieldEnum
    having?: LikeUrbanExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeUrbanExplorerCountAggregateInputType | true
    _min?: LikeUrbanExplorerMinAggregateInputType
    _max?: LikeUrbanExplorerMaxAggregateInputType
  }

  export type LikeUrbanExplorerGroupByOutputType = {
    id: string
    placeId: string
    userId: string
    createdAt: Date
    _count: LikeUrbanExplorerCountAggregateOutputType | null
    _min: LikeUrbanExplorerMinAggregateOutputType | null
    _max: LikeUrbanExplorerMaxAggregateOutputType | null
  }

  type GetLikeUrbanExplorerGroupByPayload<T extends LikeUrbanExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeUrbanExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeUrbanExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeUrbanExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], LikeUrbanExplorerGroupByOutputType[P]>
        }
      >
    >


  export type LikeUrbanExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeUrbanExplorer"]>

  export type LikeUrbanExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeUrbanExplorer"]>

  export type LikeUrbanExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likeUrbanExplorer"]>

  export type LikeUrbanExplorerSelectScalar = {
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type LikeUrbanExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "userId" | "createdAt", ExtArgs["result"]["likeUrbanExplorer"]>
  export type LikeUrbanExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }
  export type LikeUrbanExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }
  export type LikeUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }

  export type $LikeUrbanExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LikeUrbanExplorer"
    objects: {
      user: Prisma.$UserUrbanExplorerPayload<ExtArgs>
      place: Prisma.$PlaceUrbanExplorerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      placeId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["likeUrbanExplorer"]>
    composites: {}
  }

  type LikeUrbanExplorerGetPayload<S extends boolean | null | undefined | LikeUrbanExplorerDefaultArgs> = $Result.GetResult<Prisma.$LikeUrbanExplorerPayload, S>

  type LikeUrbanExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeUrbanExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeUrbanExplorerCountAggregateInputType | true
    }

  export interface LikeUrbanExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LikeUrbanExplorer'], meta: { name: 'LikeUrbanExplorer' } }
    /**
     * Find zero or one LikeUrbanExplorer that matches the filter.
     * @param {LikeUrbanExplorerFindUniqueArgs} args - Arguments to find a LikeUrbanExplorer
     * @example
     * // Get one LikeUrbanExplorer
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeUrbanExplorerFindUniqueArgs>(args: SelectSubset<T, LikeUrbanExplorerFindUniqueArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LikeUrbanExplorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeUrbanExplorerFindUniqueOrThrowArgs} args - Arguments to find a LikeUrbanExplorer
     * @example
     * // Get one LikeUrbanExplorer
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeUrbanExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeUrbanExplorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerFindFirstArgs} args - Arguments to find a LikeUrbanExplorer
     * @example
     * // Get one LikeUrbanExplorer
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeUrbanExplorerFindFirstArgs>(args?: SelectSubset<T, LikeUrbanExplorerFindFirstArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LikeUrbanExplorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerFindFirstOrThrowArgs} args - Arguments to find a LikeUrbanExplorer
     * @example
     * // Get one LikeUrbanExplorer
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeUrbanExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeUrbanExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LikeUrbanExplorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LikeUrbanExplorers
     * const likeUrbanExplorers = await prisma.likeUrbanExplorer.findMany()
     * 
     * // Get first 10 LikeUrbanExplorers
     * const likeUrbanExplorers = await prisma.likeUrbanExplorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeUrbanExplorerWithIdOnly = await prisma.likeUrbanExplorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeUrbanExplorerFindManyArgs>(args?: SelectSubset<T, LikeUrbanExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LikeUrbanExplorer.
     * @param {LikeUrbanExplorerCreateArgs} args - Arguments to create a LikeUrbanExplorer.
     * @example
     * // Create one LikeUrbanExplorer
     * const LikeUrbanExplorer = await prisma.likeUrbanExplorer.create({
     *   data: {
     *     // ... data to create a LikeUrbanExplorer
     *   }
     * })
     * 
     */
    create<T extends LikeUrbanExplorerCreateArgs>(args: SelectSubset<T, LikeUrbanExplorerCreateArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LikeUrbanExplorers.
     * @param {LikeUrbanExplorerCreateManyArgs} args - Arguments to create many LikeUrbanExplorers.
     * @example
     * // Create many LikeUrbanExplorers
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeUrbanExplorerCreateManyArgs>(args?: SelectSubset<T, LikeUrbanExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LikeUrbanExplorers and returns the data saved in the database.
     * @param {LikeUrbanExplorerCreateManyAndReturnArgs} args - Arguments to create many LikeUrbanExplorers.
     * @example
     * // Create many LikeUrbanExplorers
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LikeUrbanExplorers and only return the `id`
     * const likeUrbanExplorerWithIdOnly = await prisma.likeUrbanExplorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeUrbanExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeUrbanExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LikeUrbanExplorer.
     * @param {LikeUrbanExplorerDeleteArgs} args - Arguments to delete one LikeUrbanExplorer.
     * @example
     * // Delete one LikeUrbanExplorer
     * const LikeUrbanExplorer = await prisma.likeUrbanExplorer.delete({
     *   where: {
     *     // ... filter to delete one LikeUrbanExplorer
     *   }
     * })
     * 
     */
    delete<T extends LikeUrbanExplorerDeleteArgs>(args: SelectSubset<T, LikeUrbanExplorerDeleteArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LikeUrbanExplorer.
     * @param {LikeUrbanExplorerUpdateArgs} args - Arguments to update one LikeUrbanExplorer.
     * @example
     * // Update one LikeUrbanExplorer
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUrbanExplorerUpdateArgs>(args: SelectSubset<T, LikeUrbanExplorerUpdateArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LikeUrbanExplorers.
     * @param {LikeUrbanExplorerDeleteManyArgs} args - Arguments to filter LikeUrbanExplorers to delete.
     * @example
     * // Delete a few LikeUrbanExplorers
     * const { count } = await prisma.likeUrbanExplorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeUrbanExplorerDeleteManyArgs>(args?: SelectSubset<T, LikeUrbanExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LikeUrbanExplorers
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUrbanExplorerUpdateManyArgs>(args: SelectSubset<T, LikeUrbanExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LikeUrbanExplorers and returns the data updated in the database.
     * @param {LikeUrbanExplorerUpdateManyAndReturnArgs} args - Arguments to update many LikeUrbanExplorers.
     * @example
     * // Update many LikeUrbanExplorers
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LikeUrbanExplorers and only return the `id`
     * const likeUrbanExplorerWithIdOnly = await prisma.likeUrbanExplorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeUrbanExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LikeUrbanExplorer.
     * @param {LikeUrbanExplorerUpsertArgs} args - Arguments to update or create a LikeUrbanExplorer.
     * @example
     * // Update or create a LikeUrbanExplorer
     * const likeUrbanExplorer = await prisma.likeUrbanExplorer.upsert({
     *   create: {
     *     // ... data to create a LikeUrbanExplorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LikeUrbanExplorer we want to update
     *   }
     * })
     */
    upsert<T extends LikeUrbanExplorerUpsertArgs>(args: SelectSubset<T, LikeUrbanExplorerUpsertArgs<ExtArgs>>): Prisma__LikeUrbanExplorerClient<$Result.GetResult<Prisma.$LikeUrbanExplorerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LikeUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerCountArgs} args - Arguments to filter LikeUrbanExplorers to count.
     * @example
     * // Count the number of LikeUrbanExplorers
     * const count = await prisma.likeUrbanExplorer.count({
     *   where: {
     *     // ... the filter for the LikeUrbanExplorers we want to count
     *   }
     * })
    **/
    count<T extends LikeUrbanExplorerCountArgs>(
      args?: Subset<T, LikeUrbanExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeUrbanExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LikeUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeUrbanExplorerAggregateArgs>(args: Subset<T, LikeUrbanExplorerAggregateArgs>): Prisma.PrismaPromise<GetLikeUrbanExplorerAggregateType<T>>

    /**
     * Group by LikeUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUrbanExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeUrbanExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeUrbanExplorerGroupByArgs['orderBy'] }
        : { orderBy?: LikeUrbanExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeUrbanExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeUrbanExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LikeUrbanExplorer model
   */
  readonly fields: LikeUrbanExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LikeUrbanExplorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeUrbanExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends PlaceUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LikeUrbanExplorer model
   */ 
  interface LikeUrbanExplorerFieldRefs {
    readonly id: FieldRef<"LikeUrbanExplorer", 'String'>
    readonly placeId: FieldRef<"LikeUrbanExplorer", 'String'>
    readonly userId: FieldRef<"LikeUrbanExplorer", 'String'>
    readonly createdAt: FieldRef<"LikeUrbanExplorer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LikeUrbanExplorer findUnique
   */
  export type LikeUrbanExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which LikeUrbanExplorer to fetch.
     */
    where: LikeUrbanExplorerWhereUniqueInput
  }

  /**
   * LikeUrbanExplorer findUniqueOrThrow
   */
  export type LikeUrbanExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which LikeUrbanExplorer to fetch.
     */
    where: LikeUrbanExplorerWhereUniqueInput
  }

  /**
   * LikeUrbanExplorer findFirst
   */
  export type LikeUrbanExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which LikeUrbanExplorer to fetch.
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeUrbanExplorers to fetch.
     */
    orderBy?: LikeUrbanExplorerOrderByWithRelationInput | LikeUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeUrbanExplorers.
     */
    cursor?: LikeUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeUrbanExplorers.
     */
    distinct?: LikeUrbanExplorerScalarFieldEnum | LikeUrbanExplorerScalarFieldEnum[]
  }

  /**
   * LikeUrbanExplorer findFirstOrThrow
   */
  export type LikeUrbanExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which LikeUrbanExplorer to fetch.
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeUrbanExplorers to fetch.
     */
    orderBy?: LikeUrbanExplorerOrderByWithRelationInput | LikeUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LikeUrbanExplorers.
     */
    cursor?: LikeUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LikeUrbanExplorers.
     */
    distinct?: LikeUrbanExplorerScalarFieldEnum | LikeUrbanExplorerScalarFieldEnum[]
  }

  /**
   * LikeUrbanExplorer findMany
   */
  export type LikeUrbanExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which LikeUrbanExplorers to fetch.
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LikeUrbanExplorers to fetch.
     */
    orderBy?: LikeUrbanExplorerOrderByWithRelationInput | LikeUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LikeUrbanExplorers.
     */
    cursor?: LikeUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LikeUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LikeUrbanExplorers.
     */
    skip?: number
    distinct?: LikeUrbanExplorerScalarFieldEnum | LikeUrbanExplorerScalarFieldEnum[]
  }

  /**
   * LikeUrbanExplorer create
   */
  export type LikeUrbanExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a LikeUrbanExplorer.
     */
    data: XOR<LikeUrbanExplorerCreateInput, LikeUrbanExplorerUncheckedCreateInput>
  }

  /**
   * LikeUrbanExplorer createMany
   */
  export type LikeUrbanExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LikeUrbanExplorers.
     */
    data: LikeUrbanExplorerCreateManyInput | LikeUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LikeUrbanExplorer createManyAndReturn
   */
  export type LikeUrbanExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many LikeUrbanExplorers.
     */
    data: LikeUrbanExplorerCreateManyInput | LikeUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeUrbanExplorer update
   */
  export type LikeUrbanExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a LikeUrbanExplorer.
     */
    data: XOR<LikeUrbanExplorerUpdateInput, LikeUrbanExplorerUncheckedUpdateInput>
    /**
     * Choose, which LikeUrbanExplorer to update.
     */
    where: LikeUrbanExplorerWhereUniqueInput
  }

  /**
   * LikeUrbanExplorer updateMany
   */
  export type LikeUrbanExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LikeUrbanExplorers.
     */
    data: XOR<LikeUrbanExplorerUpdateManyMutationInput, LikeUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which LikeUrbanExplorers to update
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * Limit how many LikeUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * LikeUrbanExplorer updateManyAndReturn
   */
  export type LikeUrbanExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to update LikeUrbanExplorers.
     */
    data: XOR<LikeUrbanExplorerUpdateManyMutationInput, LikeUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which LikeUrbanExplorers to update
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * Limit how many LikeUrbanExplorers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LikeUrbanExplorer upsert
   */
  export type LikeUrbanExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the LikeUrbanExplorer to update in case it exists.
     */
    where: LikeUrbanExplorerWhereUniqueInput
    /**
     * In case the LikeUrbanExplorer found by the `where` argument doesn't exist, create a new LikeUrbanExplorer with this data.
     */
    create: XOR<LikeUrbanExplorerCreateInput, LikeUrbanExplorerUncheckedCreateInput>
    /**
     * In case the LikeUrbanExplorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUrbanExplorerUpdateInput, LikeUrbanExplorerUncheckedUpdateInput>
  }

  /**
   * LikeUrbanExplorer delete
   */
  export type LikeUrbanExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter which LikeUrbanExplorer to delete.
     */
    where: LikeUrbanExplorerWhereUniqueInput
  }

  /**
   * LikeUrbanExplorer deleteMany
   */
  export type LikeUrbanExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LikeUrbanExplorers to delete
     */
    where?: LikeUrbanExplorerWhereInput
    /**
     * Limit how many LikeUrbanExplorers to delete.
     */
    limit?: number
  }

  /**
   * LikeUrbanExplorer without action
   */
  export type LikeUrbanExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LikeUrbanExplorer
     */
    select?: LikeUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LikeUrbanExplorer
     */
    omit?: LikeUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeUrbanExplorerInclude<ExtArgs> | null
  }


  /**
   * Model BookmarkUrbanExplorer
   */

  export type AggregateBookmarkUrbanExplorer = {
    _count: BookmarkUrbanExplorerCountAggregateOutputType | null
    _min: BookmarkUrbanExplorerMinAggregateOutputType | null
    _max: BookmarkUrbanExplorerMaxAggregateOutputType | null
  }

  export type BookmarkUrbanExplorerMinAggregateOutputType = {
    id: string | null
    placeId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type BookmarkUrbanExplorerMaxAggregateOutputType = {
    id: string | null
    placeId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type BookmarkUrbanExplorerCountAggregateOutputType = {
    id: number
    placeId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type BookmarkUrbanExplorerMinAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    createdAt?: true
  }

  export type BookmarkUrbanExplorerMaxAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    createdAt?: true
  }

  export type BookmarkUrbanExplorerCountAggregateInputType = {
    id?: true
    placeId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkUrbanExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookmarkUrbanExplorer to aggregate.
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkUrbanExplorers to fetch.
     */
    orderBy?: BookmarkUrbanExplorerOrderByWithRelationInput | BookmarkUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookmarkUrbanExplorers
    **/
    _count?: true | BookmarkUrbanExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkUrbanExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkUrbanExplorerMaxAggregateInputType
  }

  export type GetBookmarkUrbanExplorerAggregateType<T extends BookmarkUrbanExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmarkUrbanExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmarkUrbanExplorer[P]>
      : GetScalarType<T[P], AggregateBookmarkUrbanExplorer[P]>
  }




  export type BookmarkUrbanExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkUrbanExplorerWhereInput
    orderBy?: BookmarkUrbanExplorerOrderByWithAggregationInput | BookmarkUrbanExplorerOrderByWithAggregationInput[]
    by: BookmarkUrbanExplorerScalarFieldEnum[] | BookmarkUrbanExplorerScalarFieldEnum
    having?: BookmarkUrbanExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkUrbanExplorerCountAggregateInputType | true
    _min?: BookmarkUrbanExplorerMinAggregateInputType
    _max?: BookmarkUrbanExplorerMaxAggregateInputType
  }

  export type BookmarkUrbanExplorerGroupByOutputType = {
    id: string
    placeId: string
    userId: string
    createdAt: Date
    _count: BookmarkUrbanExplorerCountAggregateOutputType | null
    _min: BookmarkUrbanExplorerMinAggregateOutputType | null
    _max: BookmarkUrbanExplorerMaxAggregateOutputType | null
  }

  type GetBookmarkUrbanExplorerGroupByPayload<T extends BookmarkUrbanExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkUrbanExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkUrbanExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkUrbanExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkUrbanExplorerGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkUrbanExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarkUrbanExplorer"]>

  export type BookmarkUrbanExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarkUrbanExplorer"]>

  export type BookmarkUrbanExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmarkUrbanExplorer"]>

  export type BookmarkUrbanExplorerSelectScalar = {
    id?: boolean
    placeId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type BookmarkUrbanExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "userId" | "createdAt", ExtArgs["result"]["bookmarkUrbanExplorer"]>
  export type BookmarkUrbanExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }
  export type BookmarkUrbanExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }
  export type BookmarkUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | PlaceUrbanExplorerDefaultArgs<ExtArgs>
  }

  export type $BookmarkUrbanExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookmarkUrbanExplorer"
    objects: {
      user: Prisma.$UserUrbanExplorerPayload<ExtArgs>
      place: Prisma.$PlaceUrbanExplorerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      placeId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["bookmarkUrbanExplorer"]>
    composites: {}
  }

  type BookmarkUrbanExplorerGetPayload<S extends boolean | null | undefined | BookmarkUrbanExplorerDefaultArgs> = $Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload, S>

  type BookmarkUrbanExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarkUrbanExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarkUrbanExplorerCountAggregateInputType | true
    }

  export interface BookmarkUrbanExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookmarkUrbanExplorer'], meta: { name: 'BookmarkUrbanExplorer' } }
    /**
     * Find zero or one BookmarkUrbanExplorer that matches the filter.
     * @param {BookmarkUrbanExplorerFindUniqueArgs} args - Arguments to find a BookmarkUrbanExplorer
     * @example
     * // Get one BookmarkUrbanExplorer
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkUrbanExplorerFindUniqueArgs>(args: SelectSubset<T, BookmarkUrbanExplorerFindUniqueArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookmarkUrbanExplorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarkUrbanExplorerFindUniqueOrThrowArgs} args - Arguments to find a BookmarkUrbanExplorer
     * @example
     * // Get one BookmarkUrbanExplorer
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkUrbanExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookmarkUrbanExplorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerFindFirstArgs} args - Arguments to find a BookmarkUrbanExplorer
     * @example
     * // Get one BookmarkUrbanExplorer
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkUrbanExplorerFindFirstArgs>(args?: SelectSubset<T, BookmarkUrbanExplorerFindFirstArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookmarkUrbanExplorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerFindFirstOrThrowArgs} args - Arguments to find a BookmarkUrbanExplorer
     * @example
     * // Get one BookmarkUrbanExplorer
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkUrbanExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkUrbanExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookmarkUrbanExplorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookmarkUrbanExplorers
     * const bookmarkUrbanExplorers = await prisma.bookmarkUrbanExplorer.findMany()
     * 
     * // Get first 10 BookmarkUrbanExplorers
     * const bookmarkUrbanExplorers = await prisma.bookmarkUrbanExplorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkUrbanExplorerWithIdOnly = await prisma.bookmarkUrbanExplorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkUrbanExplorerFindManyArgs>(args?: SelectSubset<T, BookmarkUrbanExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookmarkUrbanExplorer.
     * @param {BookmarkUrbanExplorerCreateArgs} args - Arguments to create a BookmarkUrbanExplorer.
     * @example
     * // Create one BookmarkUrbanExplorer
     * const BookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.create({
     *   data: {
     *     // ... data to create a BookmarkUrbanExplorer
     *   }
     * })
     * 
     */
    create<T extends BookmarkUrbanExplorerCreateArgs>(args: SelectSubset<T, BookmarkUrbanExplorerCreateArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookmarkUrbanExplorers.
     * @param {BookmarkUrbanExplorerCreateManyArgs} args - Arguments to create many BookmarkUrbanExplorers.
     * @example
     * // Create many BookmarkUrbanExplorers
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkUrbanExplorerCreateManyArgs>(args?: SelectSubset<T, BookmarkUrbanExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookmarkUrbanExplorers and returns the data saved in the database.
     * @param {BookmarkUrbanExplorerCreateManyAndReturnArgs} args - Arguments to create many BookmarkUrbanExplorers.
     * @example
     * // Create many BookmarkUrbanExplorers
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookmarkUrbanExplorers and only return the `id`
     * const bookmarkUrbanExplorerWithIdOnly = await prisma.bookmarkUrbanExplorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarkUrbanExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarkUrbanExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookmarkUrbanExplorer.
     * @param {BookmarkUrbanExplorerDeleteArgs} args - Arguments to delete one BookmarkUrbanExplorer.
     * @example
     * // Delete one BookmarkUrbanExplorer
     * const BookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.delete({
     *   where: {
     *     // ... filter to delete one BookmarkUrbanExplorer
     *   }
     * })
     * 
     */
    delete<T extends BookmarkUrbanExplorerDeleteArgs>(args: SelectSubset<T, BookmarkUrbanExplorerDeleteArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookmarkUrbanExplorer.
     * @param {BookmarkUrbanExplorerUpdateArgs} args - Arguments to update one BookmarkUrbanExplorer.
     * @example
     * // Update one BookmarkUrbanExplorer
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkUrbanExplorerUpdateArgs>(args: SelectSubset<T, BookmarkUrbanExplorerUpdateArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookmarkUrbanExplorers.
     * @param {BookmarkUrbanExplorerDeleteManyArgs} args - Arguments to filter BookmarkUrbanExplorers to delete.
     * @example
     * // Delete a few BookmarkUrbanExplorers
     * const { count } = await prisma.bookmarkUrbanExplorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkUrbanExplorerDeleteManyArgs>(args?: SelectSubset<T, BookmarkUrbanExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookmarkUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookmarkUrbanExplorers
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkUrbanExplorerUpdateManyArgs>(args: SelectSubset<T, BookmarkUrbanExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookmarkUrbanExplorers and returns the data updated in the database.
     * @param {BookmarkUrbanExplorerUpdateManyAndReturnArgs} args - Arguments to update many BookmarkUrbanExplorers.
     * @example
     * // Update many BookmarkUrbanExplorers
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookmarkUrbanExplorers and only return the `id`
     * const bookmarkUrbanExplorerWithIdOnly = await prisma.bookmarkUrbanExplorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookmarkUrbanExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, BookmarkUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookmarkUrbanExplorer.
     * @param {BookmarkUrbanExplorerUpsertArgs} args - Arguments to update or create a BookmarkUrbanExplorer.
     * @example
     * // Update or create a BookmarkUrbanExplorer
     * const bookmarkUrbanExplorer = await prisma.bookmarkUrbanExplorer.upsert({
     *   create: {
     *     // ... data to create a BookmarkUrbanExplorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookmarkUrbanExplorer we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkUrbanExplorerUpsertArgs>(args: SelectSubset<T, BookmarkUrbanExplorerUpsertArgs<ExtArgs>>): Prisma__BookmarkUrbanExplorerClient<$Result.GetResult<Prisma.$BookmarkUrbanExplorerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookmarkUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerCountArgs} args - Arguments to filter BookmarkUrbanExplorers to count.
     * @example
     * // Count the number of BookmarkUrbanExplorers
     * const count = await prisma.bookmarkUrbanExplorer.count({
     *   where: {
     *     // ... the filter for the BookmarkUrbanExplorers we want to count
     *   }
     * })
    **/
    count<T extends BookmarkUrbanExplorerCountArgs>(
      args?: Subset<T, BookmarkUrbanExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkUrbanExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookmarkUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkUrbanExplorerAggregateArgs>(args: Subset<T, BookmarkUrbanExplorerAggregateArgs>): Prisma.PrismaPromise<GetBookmarkUrbanExplorerAggregateType<T>>

    /**
     * Group by BookmarkUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUrbanExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkUrbanExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkUrbanExplorerGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkUrbanExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkUrbanExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkUrbanExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookmarkUrbanExplorer model
   */
  readonly fields: BookmarkUrbanExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookmarkUrbanExplorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkUrbanExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends PlaceUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookmarkUrbanExplorer model
   */ 
  interface BookmarkUrbanExplorerFieldRefs {
    readonly id: FieldRef<"BookmarkUrbanExplorer", 'String'>
    readonly placeId: FieldRef<"BookmarkUrbanExplorer", 'String'>
    readonly userId: FieldRef<"BookmarkUrbanExplorer", 'String'>
    readonly createdAt: FieldRef<"BookmarkUrbanExplorer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookmarkUrbanExplorer findUnique
   */
  export type BookmarkUrbanExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkUrbanExplorer to fetch.
     */
    where: BookmarkUrbanExplorerWhereUniqueInput
  }

  /**
   * BookmarkUrbanExplorer findUniqueOrThrow
   */
  export type BookmarkUrbanExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkUrbanExplorer to fetch.
     */
    where: BookmarkUrbanExplorerWhereUniqueInput
  }

  /**
   * BookmarkUrbanExplorer findFirst
   */
  export type BookmarkUrbanExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkUrbanExplorer to fetch.
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkUrbanExplorers to fetch.
     */
    orderBy?: BookmarkUrbanExplorerOrderByWithRelationInput | BookmarkUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookmarkUrbanExplorers.
     */
    cursor?: BookmarkUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookmarkUrbanExplorers.
     */
    distinct?: BookmarkUrbanExplorerScalarFieldEnum | BookmarkUrbanExplorerScalarFieldEnum[]
  }

  /**
   * BookmarkUrbanExplorer findFirstOrThrow
   */
  export type BookmarkUrbanExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkUrbanExplorer to fetch.
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkUrbanExplorers to fetch.
     */
    orderBy?: BookmarkUrbanExplorerOrderByWithRelationInput | BookmarkUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookmarkUrbanExplorers.
     */
    cursor?: BookmarkUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookmarkUrbanExplorers.
     */
    distinct?: BookmarkUrbanExplorerScalarFieldEnum | BookmarkUrbanExplorerScalarFieldEnum[]
  }

  /**
   * BookmarkUrbanExplorer findMany
   */
  export type BookmarkUrbanExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which BookmarkUrbanExplorers to fetch.
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkUrbanExplorers to fetch.
     */
    orderBy?: BookmarkUrbanExplorerOrderByWithRelationInput | BookmarkUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookmarkUrbanExplorers.
     */
    cursor?: BookmarkUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkUrbanExplorers.
     */
    skip?: number
    distinct?: BookmarkUrbanExplorerScalarFieldEnum | BookmarkUrbanExplorerScalarFieldEnum[]
  }

  /**
   * BookmarkUrbanExplorer create
   */
  export type BookmarkUrbanExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a BookmarkUrbanExplorer.
     */
    data: XOR<BookmarkUrbanExplorerCreateInput, BookmarkUrbanExplorerUncheckedCreateInput>
  }

  /**
   * BookmarkUrbanExplorer createMany
   */
  export type BookmarkUrbanExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookmarkUrbanExplorers.
     */
    data: BookmarkUrbanExplorerCreateManyInput | BookmarkUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookmarkUrbanExplorer createManyAndReturn
   */
  export type BookmarkUrbanExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many BookmarkUrbanExplorers.
     */
    data: BookmarkUrbanExplorerCreateManyInput | BookmarkUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookmarkUrbanExplorer update
   */
  export type BookmarkUrbanExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a BookmarkUrbanExplorer.
     */
    data: XOR<BookmarkUrbanExplorerUpdateInput, BookmarkUrbanExplorerUncheckedUpdateInput>
    /**
     * Choose, which BookmarkUrbanExplorer to update.
     */
    where: BookmarkUrbanExplorerWhereUniqueInput
  }

  /**
   * BookmarkUrbanExplorer updateMany
   */
  export type BookmarkUrbanExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookmarkUrbanExplorers.
     */
    data: XOR<BookmarkUrbanExplorerUpdateManyMutationInput, BookmarkUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which BookmarkUrbanExplorers to update
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * Limit how many BookmarkUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * BookmarkUrbanExplorer updateManyAndReturn
   */
  export type BookmarkUrbanExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to update BookmarkUrbanExplorers.
     */
    data: XOR<BookmarkUrbanExplorerUpdateManyMutationInput, BookmarkUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which BookmarkUrbanExplorers to update
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * Limit how many BookmarkUrbanExplorers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookmarkUrbanExplorer upsert
   */
  export type BookmarkUrbanExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the BookmarkUrbanExplorer to update in case it exists.
     */
    where: BookmarkUrbanExplorerWhereUniqueInput
    /**
     * In case the BookmarkUrbanExplorer found by the `where` argument doesn't exist, create a new BookmarkUrbanExplorer with this data.
     */
    create: XOR<BookmarkUrbanExplorerCreateInput, BookmarkUrbanExplorerUncheckedCreateInput>
    /**
     * In case the BookmarkUrbanExplorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkUrbanExplorerUpdateInput, BookmarkUrbanExplorerUncheckedUpdateInput>
  }

  /**
   * BookmarkUrbanExplorer delete
   */
  export type BookmarkUrbanExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter which BookmarkUrbanExplorer to delete.
     */
    where: BookmarkUrbanExplorerWhereUniqueInput
  }

  /**
   * BookmarkUrbanExplorer deleteMany
   */
  export type BookmarkUrbanExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookmarkUrbanExplorers to delete
     */
    where?: BookmarkUrbanExplorerWhereInput
    /**
     * Limit how many BookmarkUrbanExplorers to delete.
     */
    limit?: number
  }

  /**
   * BookmarkUrbanExplorer without action
   */
  export type BookmarkUrbanExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkUrbanExplorer
     */
    select?: BookmarkUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkUrbanExplorer
     */
    omit?: BookmarkUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkUrbanExplorerInclude<ExtArgs> | null
  }


  /**
   * Model ReportUrbanExplorer
   */

  export type AggregateReportUrbanExplorer = {
    _count: ReportUrbanExplorerCountAggregateOutputType | null
    _min: ReportUrbanExplorerMinAggregateOutputType | null
    _max: ReportUrbanExplorerMaxAggregateOutputType | null
  }

  export type ReportUrbanExplorerMinAggregateOutputType = {
    id: string | null
    placeId: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportUrbanExplorerMaxAggregateOutputType = {
    id: string | null
    placeId: string | null
    reviewId: string | null
    userId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportUrbanExplorerCountAggregateOutputType = {
    id: number
    placeId: number
    reviewId: number
    userId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReportUrbanExplorerMinAggregateInputType = {
    id?: true
    placeId?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ReportUrbanExplorerMaxAggregateInputType = {
    id?: true
    placeId?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
  }

  export type ReportUrbanExplorerCountAggregateInputType = {
    id?: true
    placeId?: true
    reviewId?: true
    userId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReportUrbanExplorerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportUrbanExplorer to aggregate.
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUrbanExplorers to fetch.
     */
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportUrbanExplorers
    **/
    _count?: true | ReportUrbanExplorerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportUrbanExplorerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportUrbanExplorerMaxAggregateInputType
  }

  export type GetReportUrbanExplorerAggregateType<T extends ReportUrbanExplorerAggregateArgs> = {
        [P in keyof T & keyof AggregateReportUrbanExplorer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportUrbanExplorer[P]>
      : GetScalarType<T[P], AggregateReportUrbanExplorer[P]>
  }




  export type ReportUrbanExplorerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportUrbanExplorerWhereInput
    orderBy?: ReportUrbanExplorerOrderByWithAggregationInput | ReportUrbanExplorerOrderByWithAggregationInput[]
    by: ReportUrbanExplorerScalarFieldEnum[] | ReportUrbanExplorerScalarFieldEnum
    having?: ReportUrbanExplorerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportUrbanExplorerCountAggregateInputType | true
    _min?: ReportUrbanExplorerMinAggregateInputType
    _max?: ReportUrbanExplorerMaxAggregateInputType
  }

  export type ReportUrbanExplorerGroupByOutputType = {
    id: string
    placeId: string | null
    reviewId: string | null
    userId: string
    reason: string
    createdAt: Date
    _count: ReportUrbanExplorerCountAggregateOutputType | null
    _min: ReportUrbanExplorerMinAggregateOutputType | null
    _max: ReportUrbanExplorerMaxAggregateOutputType | null
  }

  type GetReportUrbanExplorerGroupByPayload<T extends ReportUrbanExplorerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportUrbanExplorerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportUrbanExplorerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportUrbanExplorerGroupByOutputType[P]>
            : GetScalarType<T[P], ReportUrbanExplorerGroupByOutputType[P]>
        }
      >
    >


  export type ReportUrbanExplorerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | ReportUrbanExplorer$placeArgs<ExtArgs>
    review?: boolean | ReportUrbanExplorer$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["reportUrbanExplorer"]>

  export type ReportUrbanExplorerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | ReportUrbanExplorer$placeArgs<ExtArgs>
    review?: boolean | ReportUrbanExplorer$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["reportUrbanExplorer"]>

  export type ReportUrbanExplorerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placeId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | ReportUrbanExplorer$placeArgs<ExtArgs>
    review?: boolean | ReportUrbanExplorer$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["reportUrbanExplorer"]>

  export type ReportUrbanExplorerSelectScalar = {
    id?: boolean
    placeId?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReportUrbanExplorerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placeId" | "reviewId" | "userId" | "reason" | "createdAt", ExtArgs["result"]["reportUrbanExplorer"]>
  export type ReportUrbanExplorerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | ReportUrbanExplorer$placeArgs<ExtArgs>
    review?: boolean | ReportUrbanExplorer$reviewArgs<ExtArgs>
  }
  export type ReportUrbanExplorerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | ReportUrbanExplorer$placeArgs<ExtArgs>
    review?: boolean | ReportUrbanExplorer$reviewArgs<ExtArgs>
  }
  export type ReportUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserUrbanExplorerDefaultArgs<ExtArgs>
    place?: boolean | ReportUrbanExplorer$placeArgs<ExtArgs>
    review?: boolean | ReportUrbanExplorer$reviewArgs<ExtArgs>
  }

  export type $ReportUrbanExplorerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportUrbanExplorer"
    objects: {
      user: Prisma.$UserUrbanExplorerPayload<ExtArgs>
      place: Prisma.$PlaceUrbanExplorerPayload<ExtArgs> | null
      review: Prisma.$ReviewUrbanExplorerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      placeId: string | null
      reviewId: string | null
      userId: string
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["reportUrbanExplorer"]>
    composites: {}
  }

  type ReportUrbanExplorerGetPayload<S extends boolean | null | undefined | ReportUrbanExplorerDefaultArgs> = $Result.GetResult<Prisma.$ReportUrbanExplorerPayload, S>

  type ReportUrbanExplorerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportUrbanExplorerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportUrbanExplorerCountAggregateInputType | true
    }

  export interface ReportUrbanExplorerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportUrbanExplorer'], meta: { name: 'ReportUrbanExplorer' } }
    /**
     * Find zero or one ReportUrbanExplorer that matches the filter.
     * @param {ReportUrbanExplorerFindUniqueArgs} args - Arguments to find a ReportUrbanExplorer
     * @example
     * // Get one ReportUrbanExplorer
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportUrbanExplorerFindUniqueArgs>(args: SelectSubset<T, ReportUrbanExplorerFindUniqueArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportUrbanExplorer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportUrbanExplorerFindUniqueOrThrowArgs} args - Arguments to find a ReportUrbanExplorer
     * @example
     * // Get one ReportUrbanExplorer
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportUrbanExplorerFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportUrbanExplorerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportUrbanExplorer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerFindFirstArgs} args - Arguments to find a ReportUrbanExplorer
     * @example
     * // Get one ReportUrbanExplorer
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportUrbanExplorerFindFirstArgs>(args?: SelectSubset<T, ReportUrbanExplorerFindFirstArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportUrbanExplorer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerFindFirstOrThrowArgs} args - Arguments to find a ReportUrbanExplorer
     * @example
     * // Get one ReportUrbanExplorer
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportUrbanExplorerFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportUrbanExplorerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportUrbanExplorers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportUrbanExplorers
     * const reportUrbanExplorers = await prisma.reportUrbanExplorer.findMany()
     * 
     * // Get first 10 ReportUrbanExplorers
     * const reportUrbanExplorers = await prisma.reportUrbanExplorer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportUrbanExplorerWithIdOnly = await prisma.reportUrbanExplorer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportUrbanExplorerFindManyArgs>(args?: SelectSubset<T, ReportUrbanExplorerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportUrbanExplorer.
     * @param {ReportUrbanExplorerCreateArgs} args - Arguments to create a ReportUrbanExplorer.
     * @example
     * // Create one ReportUrbanExplorer
     * const ReportUrbanExplorer = await prisma.reportUrbanExplorer.create({
     *   data: {
     *     // ... data to create a ReportUrbanExplorer
     *   }
     * })
     * 
     */
    create<T extends ReportUrbanExplorerCreateArgs>(args: SelectSubset<T, ReportUrbanExplorerCreateArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportUrbanExplorers.
     * @param {ReportUrbanExplorerCreateManyArgs} args - Arguments to create many ReportUrbanExplorers.
     * @example
     * // Create many ReportUrbanExplorers
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportUrbanExplorerCreateManyArgs>(args?: SelectSubset<T, ReportUrbanExplorerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportUrbanExplorers and returns the data saved in the database.
     * @param {ReportUrbanExplorerCreateManyAndReturnArgs} args - Arguments to create many ReportUrbanExplorers.
     * @example
     * // Create many ReportUrbanExplorers
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportUrbanExplorers and only return the `id`
     * const reportUrbanExplorerWithIdOnly = await prisma.reportUrbanExplorer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportUrbanExplorerCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportUrbanExplorerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportUrbanExplorer.
     * @param {ReportUrbanExplorerDeleteArgs} args - Arguments to delete one ReportUrbanExplorer.
     * @example
     * // Delete one ReportUrbanExplorer
     * const ReportUrbanExplorer = await prisma.reportUrbanExplorer.delete({
     *   where: {
     *     // ... filter to delete one ReportUrbanExplorer
     *   }
     * })
     * 
     */
    delete<T extends ReportUrbanExplorerDeleteArgs>(args: SelectSubset<T, ReportUrbanExplorerDeleteArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportUrbanExplorer.
     * @param {ReportUrbanExplorerUpdateArgs} args - Arguments to update one ReportUrbanExplorer.
     * @example
     * // Update one ReportUrbanExplorer
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUrbanExplorerUpdateArgs>(args: SelectSubset<T, ReportUrbanExplorerUpdateArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportUrbanExplorers.
     * @param {ReportUrbanExplorerDeleteManyArgs} args - Arguments to filter ReportUrbanExplorers to delete.
     * @example
     * // Delete a few ReportUrbanExplorers
     * const { count } = await prisma.reportUrbanExplorer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportUrbanExplorerDeleteManyArgs>(args?: SelectSubset<T, ReportUrbanExplorerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportUrbanExplorers
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUrbanExplorerUpdateManyArgs>(args: SelectSubset<T, ReportUrbanExplorerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportUrbanExplorers and returns the data updated in the database.
     * @param {ReportUrbanExplorerUpdateManyAndReturnArgs} args - Arguments to update many ReportUrbanExplorers.
     * @example
     * // Update many ReportUrbanExplorers
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportUrbanExplorers and only return the `id`
     * const reportUrbanExplorerWithIdOnly = await prisma.reportUrbanExplorer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUrbanExplorerUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUrbanExplorerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportUrbanExplorer.
     * @param {ReportUrbanExplorerUpsertArgs} args - Arguments to update or create a ReportUrbanExplorer.
     * @example
     * // Update or create a ReportUrbanExplorer
     * const reportUrbanExplorer = await prisma.reportUrbanExplorer.upsert({
     *   create: {
     *     // ... data to create a ReportUrbanExplorer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportUrbanExplorer we want to update
     *   }
     * })
     */
    upsert<T extends ReportUrbanExplorerUpsertArgs>(args: SelectSubset<T, ReportUrbanExplorerUpsertArgs<ExtArgs>>): Prisma__ReportUrbanExplorerClient<$Result.GetResult<Prisma.$ReportUrbanExplorerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportUrbanExplorers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerCountArgs} args - Arguments to filter ReportUrbanExplorers to count.
     * @example
     * // Count the number of ReportUrbanExplorers
     * const count = await prisma.reportUrbanExplorer.count({
     *   where: {
     *     // ... the filter for the ReportUrbanExplorers we want to count
     *   }
     * })
    **/
    count<T extends ReportUrbanExplorerCountArgs>(
      args?: Subset<T, ReportUrbanExplorerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportUrbanExplorerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportUrbanExplorerAggregateArgs>(args: Subset<T, ReportUrbanExplorerAggregateArgs>): Prisma.PrismaPromise<GetReportUrbanExplorerAggregateType<T>>

    /**
     * Group by ReportUrbanExplorer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUrbanExplorerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportUrbanExplorerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportUrbanExplorerGroupByArgs['orderBy'] }
        : { orderBy?: ReportUrbanExplorerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportUrbanExplorerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportUrbanExplorerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportUrbanExplorer model
   */
  readonly fields: ReportUrbanExplorerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportUrbanExplorer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportUrbanExplorerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserUrbanExplorerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserUrbanExplorerDefaultArgs<ExtArgs>>): Prisma__UserUrbanExplorerClient<$Result.GetResult<Prisma.$UserUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends ReportUrbanExplorer$placeArgs<ExtArgs> = {}>(args?: Subset<T, ReportUrbanExplorer$placeArgs<ExtArgs>>): Prisma__PlaceUrbanExplorerClient<$Result.GetResult<Prisma.$PlaceUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    review<T extends ReportUrbanExplorer$reviewArgs<ExtArgs> = {}>(args?: Subset<T, ReportUrbanExplorer$reviewArgs<ExtArgs>>): Prisma__ReviewUrbanExplorerClient<$Result.GetResult<Prisma.$ReviewUrbanExplorerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportUrbanExplorer model
   */ 
  interface ReportUrbanExplorerFieldRefs {
    readonly id: FieldRef<"ReportUrbanExplorer", 'String'>
    readonly placeId: FieldRef<"ReportUrbanExplorer", 'String'>
    readonly reviewId: FieldRef<"ReportUrbanExplorer", 'String'>
    readonly userId: FieldRef<"ReportUrbanExplorer", 'String'>
    readonly reason: FieldRef<"ReportUrbanExplorer", 'String'>
    readonly createdAt: FieldRef<"ReportUrbanExplorer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportUrbanExplorer findUnique
   */
  export type ReportUrbanExplorerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReportUrbanExplorer to fetch.
     */
    where: ReportUrbanExplorerWhereUniqueInput
  }

  /**
   * ReportUrbanExplorer findUniqueOrThrow
   */
  export type ReportUrbanExplorerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReportUrbanExplorer to fetch.
     */
    where: ReportUrbanExplorerWhereUniqueInput
  }

  /**
   * ReportUrbanExplorer findFirst
   */
  export type ReportUrbanExplorerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReportUrbanExplorer to fetch.
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUrbanExplorers to fetch.
     */
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportUrbanExplorers.
     */
    cursor?: ReportUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportUrbanExplorers.
     */
    distinct?: ReportUrbanExplorerScalarFieldEnum | ReportUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReportUrbanExplorer findFirstOrThrow
   */
  export type ReportUrbanExplorerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReportUrbanExplorer to fetch.
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUrbanExplorers to fetch.
     */
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportUrbanExplorers.
     */
    cursor?: ReportUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUrbanExplorers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportUrbanExplorers.
     */
    distinct?: ReportUrbanExplorerScalarFieldEnum | ReportUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReportUrbanExplorer findMany
   */
  export type ReportUrbanExplorerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter, which ReportUrbanExplorers to fetch.
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportUrbanExplorers to fetch.
     */
    orderBy?: ReportUrbanExplorerOrderByWithRelationInput | ReportUrbanExplorerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportUrbanExplorers.
     */
    cursor?: ReportUrbanExplorerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportUrbanExplorers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportUrbanExplorers.
     */
    skip?: number
    distinct?: ReportUrbanExplorerScalarFieldEnum | ReportUrbanExplorerScalarFieldEnum[]
  }

  /**
   * ReportUrbanExplorer create
   */
  export type ReportUrbanExplorerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportUrbanExplorer.
     */
    data: XOR<ReportUrbanExplorerCreateInput, ReportUrbanExplorerUncheckedCreateInput>
  }

  /**
   * ReportUrbanExplorer createMany
   */
  export type ReportUrbanExplorerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportUrbanExplorers.
     */
    data: ReportUrbanExplorerCreateManyInput | ReportUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportUrbanExplorer createManyAndReturn
   */
  export type ReportUrbanExplorerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to create many ReportUrbanExplorers.
     */
    data: ReportUrbanExplorerCreateManyInput | ReportUrbanExplorerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportUrbanExplorer update
   */
  export type ReportUrbanExplorerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportUrbanExplorer.
     */
    data: XOR<ReportUrbanExplorerUpdateInput, ReportUrbanExplorerUncheckedUpdateInput>
    /**
     * Choose, which ReportUrbanExplorer to update.
     */
    where: ReportUrbanExplorerWhereUniqueInput
  }

  /**
   * ReportUrbanExplorer updateMany
   */
  export type ReportUrbanExplorerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportUrbanExplorers.
     */
    data: XOR<ReportUrbanExplorerUpdateManyMutationInput, ReportUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which ReportUrbanExplorers to update
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * Limit how many ReportUrbanExplorers to update.
     */
    limit?: number
  }

  /**
   * ReportUrbanExplorer updateManyAndReturn
   */
  export type ReportUrbanExplorerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * The data used to update ReportUrbanExplorers.
     */
    data: XOR<ReportUrbanExplorerUpdateManyMutationInput, ReportUrbanExplorerUncheckedUpdateManyInput>
    /**
     * Filter which ReportUrbanExplorers to update
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * Limit how many ReportUrbanExplorers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportUrbanExplorer upsert
   */
  export type ReportUrbanExplorerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportUrbanExplorer to update in case it exists.
     */
    where: ReportUrbanExplorerWhereUniqueInput
    /**
     * In case the ReportUrbanExplorer found by the `where` argument doesn't exist, create a new ReportUrbanExplorer with this data.
     */
    create: XOR<ReportUrbanExplorerCreateInput, ReportUrbanExplorerUncheckedCreateInput>
    /**
     * In case the ReportUrbanExplorer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUrbanExplorerUpdateInput, ReportUrbanExplorerUncheckedUpdateInput>
  }

  /**
   * ReportUrbanExplorer delete
   */
  export type ReportUrbanExplorerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
    /**
     * Filter which ReportUrbanExplorer to delete.
     */
    where: ReportUrbanExplorerWhereUniqueInput
  }

  /**
   * ReportUrbanExplorer deleteMany
   */
  export type ReportUrbanExplorerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportUrbanExplorers to delete
     */
    where?: ReportUrbanExplorerWhereInput
    /**
     * Limit how many ReportUrbanExplorers to delete.
     */
    limit?: number
  }

  /**
   * ReportUrbanExplorer.place
   */
  export type ReportUrbanExplorer$placeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceUrbanExplorer
     */
    select?: PlaceUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceUrbanExplorer
     */
    omit?: PlaceUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceUrbanExplorerInclude<ExtArgs> | null
    where?: PlaceUrbanExplorerWhereInput
  }

  /**
   * ReportUrbanExplorer.review
   */
  export type ReportUrbanExplorer$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewUrbanExplorer
     */
    select?: ReviewUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewUrbanExplorer
     */
    omit?: ReviewUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewUrbanExplorerInclude<ExtArgs> | null
    where?: ReviewUrbanExplorerWhereInput
  }

  /**
   * ReportUrbanExplorer without action
   */
  export type ReportUrbanExplorerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportUrbanExplorer
     */
    select?: ReportUrbanExplorerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportUrbanExplorer
     */
    omit?: ReportUrbanExplorerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportUrbanExplorerInclude<ExtArgs> | null
  }


  /**
   * Model UserFoodie
   */

  export type AggregateUserFoodie = {
    _count: UserFoodieCountAggregateOutputType | null
    _min: UserFoodieMinAggregateOutputType | null
    _max: UserFoodieMaxAggregateOutputType | null
  }

  export type UserFoodieMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserFoodieMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserFoodieCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserFoodieMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserFoodieMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserFoodieCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserFoodieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFoodie to aggregate.
     */
    where?: UserFoodieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFoodies to fetch.
     */
    orderBy?: UserFoodieOrderByWithRelationInput | UserFoodieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFoodieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFoodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFoodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFoodies
    **/
    _count?: true | UserFoodieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFoodieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFoodieMaxAggregateInputType
  }

  export type GetUserFoodieAggregateType<T extends UserFoodieAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFoodie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFoodie[P]>
      : GetScalarType<T[P], AggregateUserFoodie[P]>
  }




  export type UserFoodieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFoodieWhereInput
    orderBy?: UserFoodieOrderByWithAggregationInput | UserFoodieOrderByWithAggregationInput[]
    by: UserFoodieScalarFieldEnum[] | UserFoodieScalarFieldEnum
    having?: UserFoodieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFoodieCountAggregateInputType | true
    _min?: UserFoodieMinAggregateInputType
    _max?: UserFoodieMaxAggregateInputType
  }

  export type UserFoodieGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserFoodieCountAggregateOutputType | null
    _min: UserFoodieMinAggregateOutputType | null
    _max: UserFoodieMaxAggregateOutputType | null
  }

  type GetUserFoodieGroupByPayload<T extends UserFoodieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFoodieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFoodieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFoodieGroupByOutputType[P]>
            : GetScalarType<T[P], UserFoodieGroupByOutputType[P]>
        }
      >
    >


  export type UserFoodieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    FoodieFood?: boolean | UserFoodie$FoodieFoodArgs<ExtArgs>
    FoodieLocation?: boolean | UserFoodie$FoodieLocationArgs<ExtArgs>
    FoodieReview?: boolean | UserFoodie$FoodieReviewArgs<ExtArgs>
    FoodieLike?: boolean | UserFoodie$FoodieLikeArgs<ExtArgs>
    _count?: boolean | UserFoodieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFoodie"]>

  export type UserFoodieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFoodie"]>

  export type UserFoodieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFoodie"]>

  export type UserFoodieSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserFoodieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userFoodie"]>
  export type UserFoodieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FoodieFood?: boolean | UserFoodie$FoodieFoodArgs<ExtArgs>
    FoodieLocation?: boolean | UserFoodie$FoodieLocationArgs<ExtArgs>
    FoodieReview?: boolean | UserFoodie$FoodieReviewArgs<ExtArgs>
    FoodieLike?: boolean | UserFoodie$FoodieLikeArgs<ExtArgs>
    _count?: boolean | UserFoodieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserFoodieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserFoodieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserFoodiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFoodie"
    objects: {
      FoodieFood: Prisma.$FoodieFoodPayload<ExtArgs>[]
      FoodieLocation: Prisma.$FoodieLocationPayload<ExtArgs>[]
      FoodieReview: Prisma.$FoodieReviewPayload<ExtArgs>[]
      FoodieLike: Prisma.$FoodieLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userFoodie"]>
    composites: {}
  }

  type UserFoodieGetPayload<S extends boolean | null | undefined | UserFoodieDefaultArgs> = $Result.GetResult<Prisma.$UserFoodiePayload, S>

  type UserFoodieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFoodieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFoodieCountAggregateInputType | true
    }

  export interface UserFoodieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFoodie'], meta: { name: 'UserFoodie' } }
    /**
     * Find zero or one UserFoodie that matches the filter.
     * @param {UserFoodieFindUniqueArgs} args - Arguments to find a UserFoodie
     * @example
     * // Get one UserFoodie
     * const userFoodie = await prisma.userFoodie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFoodieFindUniqueArgs>(args: SelectSubset<T, UserFoodieFindUniqueArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFoodie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFoodieFindUniqueOrThrowArgs} args - Arguments to find a UserFoodie
     * @example
     * // Get one UserFoodie
     * const userFoodie = await prisma.userFoodie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFoodieFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFoodieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFoodie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieFindFirstArgs} args - Arguments to find a UserFoodie
     * @example
     * // Get one UserFoodie
     * const userFoodie = await prisma.userFoodie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFoodieFindFirstArgs>(args?: SelectSubset<T, UserFoodieFindFirstArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFoodie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieFindFirstOrThrowArgs} args - Arguments to find a UserFoodie
     * @example
     * // Get one UserFoodie
     * const userFoodie = await prisma.userFoodie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFoodieFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFoodieFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFoodies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFoodies
     * const userFoodies = await prisma.userFoodie.findMany()
     * 
     * // Get first 10 UserFoodies
     * const userFoodies = await prisma.userFoodie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFoodieWithIdOnly = await prisma.userFoodie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFoodieFindManyArgs>(args?: SelectSubset<T, UserFoodieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFoodie.
     * @param {UserFoodieCreateArgs} args - Arguments to create a UserFoodie.
     * @example
     * // Create one UserFoodie
     * const UserFoodie = await prisma.userFoodie.create({
     *   data: {
     *     // ... data to create a UserFoodie
     *   }
     * })
     * 
     */
    create<T extends UserFoodieCreateArgs>(args: SelectSubset<T, UserFoodieCreateArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFoodies.
     * @param {UserFoodieCreateManyArgs} args - Arguments to create many UserFoodies.
     * @example
     * // Create many UserFoodies
     * const userFoodie = await prisma.userFoodie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFoodieCreateManyArgs>(args?: SelectSubset<T, UserFoodieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFoodies and returns the data saved in the database.
     * @param {UserFoodieCreateManyAndReturnArgs} args - Arguments to create many UserFoodies.
     * @example
     * // Create many UserFoodies
     * const userFoodie = await prisma.userFoodie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFoodies and only return the `id`
     * const userFoodieWithIdOnly = await prisma.userFoodie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFoodieCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFoodieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFoodie.
     * @param {UserFoodieDeleteArgs} args - Arguments to delete one UserFoodie.
     * @example
     * // Delete one UserFoodie
     * const UserFoodie = await prisma.userFoodie.delete({
     *   where: {
     *     // ... filter to delete one UserFoodie
     *   }
     * })
     * 
     */
    delete<T extends UserFoodieDeleteArgs>(args: SelectSubset<T, UserFoodieDeleteArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFoodie.
     * @param {UserFoodieUpdateArgs} args - Arguments to update one UserFoodie.
     * @example
     * // Update one UserFoodie
     * const userFoodie = await prisma.userFoodie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFoodieUpdateArgs>(args: SelectSubset<T, UserFoodieUpdateArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFoodies.
     * @param {UserFoodieDeleteManyArgs} args - Arguments to filter UserFoodies to delete.
     * @example
     * // Delete a few UserFoodies
     * const { count } = await prisma.userFoodie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFoodieDeleteManyArgs>(args?: SelectSubset<T, UserFoodieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFoodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFoodies
     * const userFoodie = await prisma.userFoodie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFoodieUpdateManyArgs>(args: SelectSubset<T, UserFoodieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFoodies and returns the data updated in the database.
     * @param {UserFoodieUpdateManyAndReturnArgs} args - Arguments to update many UserFoodies.
     * @example
     * // Update many UserFoodies
     * const userFoodie = await prisma.userFoodie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFoodies and only return the `id`
     * const userFoodieWithIdOnly = await prisma.userFoodie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFoodieUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFoodieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFoodie.
     * @param {UserFoodieUpsertArgs} args - Arguments to update or create a UserFoodie.
     * @example
     * // Update or create a UserFoodie
     * const userFoodie = await prisma.userFoodie.upsert({
     *   create: {
     *     // ... data to create a UserFoodie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFoodie we want to update
     *   }
     * })
     */
    upsert<T extends UserFoodieUpsertArgs>(args: SelectSubset<T, UserFoodieUpsertArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFoodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieCountArgs} args - Arguments to filter UserFoodies to count.
     * @example
     * // Count the number of UserFoodies
     * const count = await prisma.userFoodie.count({
     *   where: {
     *     // ... the filter for the UserFoodies we want to count
     *   }
     * })
    **/
    count<T extends UserFoodieCountArgs>(
      args?: Subset<T, UserFoodieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFoodieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFoodie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFoodieAggregateArgs>(args: Subset<T, UserFoodieAggregateArgs>): Prisma.PrismaPromise<GetUserFoodieAggregateType<T>>

    /**
     * Group by UserFoodie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFoodieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFoodieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFoodieGroupByArgs['orderBy'] }
        : { orderBy?: UserFoodieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFoodieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFoodieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFoodie model
   */
  readonly fields: UserFoodieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFoodie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFoodieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FoodieFood<T extends UserFoodie$FoodieFoodArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodie$FoodieFoodArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodieLocation<T extends UserFoodie$FoodieLocationArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodie$FoodieLocationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodieReview<T extends UserFoodie$FoodieReviewArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodie$FoodieReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FoodieLike<T extends UserFoodie$FoodieLikeArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodie$FoodieLikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFoodie model
   */ 
  interface UserFoodieFieldRefs {
    readonly id: FieldRef<"UserFoodie", 'String'>
    readonly email: FieldRef<"UserFoodie", 'String'>
    readonly name: FieldRef<"UserFoodie", 'String'>
    readonly password: FieldRef<"UserFoodie", 'String'>
    readonly createdAt: FieldRef<"UserFoodie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFoodie findUnique
   */
  export type UserFoodieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * Filter, which UserFoodie to fetch.
     */
    where: UserFoodieWhereUniqueInput
  }

  /**
   * UserFoodie findUniqueOrThrow
   */
  export type UserFoodieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * Filter, which UserFoodie to fetch.
     */
    where: UserFoodieWhereUniqueInput
  }

  /**
   * UserFoodie findFirst
   */
  export type UserFoodieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * Filter, which UserFoodie to fetch.
     */
    where?: UserFoodieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFoodies to fetch.
     */
    orderBy?: UserFoodieOrderByWithRelationInput | UserFoodieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFoodies.
     */
    cursor?: UserFoodieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFoodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFoodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFoodies.
     */
    distinct?: UserFoodieScalarFieldEnum | UserFoodieScalarFieldEnum[]
  }

  /**
   * UserFoodie findFirstOrThrow
   */
  export type UserFoodieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * Filter, which UserFoodie to fetch.
     */
    where?: UserFoodieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFoodies to fetch.
     */
    orderBy?: UserFoodieOrderByWithRelationInput | UserFoodieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFoodies.
     */
    cursor?: UserFoodieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFoodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFoodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFoodies.
     */
    distinct?: UserFoodieScalarFieldEnum | UserFoodieScalarFieldEnum[]
  }

  /**
   * UserFoodie findMany
   */
  export type UserFoodieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * Filter, which UserFoodies to fetch.
     */
    where?: UserFoodieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFoodies to fetch.
     */
    orderBy?: UserFoodieOrderByWithRelationInput | UserFoodieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFoodies.
     */
    cursor?: UserFoodieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFoodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFoodies.
     */
    skip?: number
    distinct?: UserFoodieScalarFieldEnum | UserFoodieScalarFieldEnum[]
  }

  /**
   * UserFoodie create
   */
  export type UserFoodieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFoodie.
     */
    data: XOR<UserFoodieCreateInput, UserFoodieUncheckedCreateInput>
  }

  /**
   * UserFoodie createMany
   */
  export type UserFoodieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFoodies.
     */
    data: UserFoodieCreateManyInput | UserFoodieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFoodie createManyAndReturn
   */
  export type UserFoodieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * The data used to create many UserFoodies.
     */
    data: UserFoodieCreateManyInput | UserFoodieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFoodie update
   */
  export type UserFoodieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFoodie.
     */
    data: XOR<UserFoodieUpdateInput, UserFoodieUncheckedUpdateInput>
    /**
     * Choose, which UserFoodie to update.
     */
    where: UserFoodieWhereUniqueInput
  }

  /**
   * UserFoodie updateMany
   */
  export type UserFoodieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFoodies.
     */
    data: XOR<UserFoodieUpdateManyMutationInput, UserFoodieUncheckedUpdateManyInput>
    /**
     * Filter which UserFoodies to update
     */
    where?: UserFoodieWhereInput
    /**
     * Limit how many UserFoodies to update.
     */
    limit?: number
  }

  /**
   * UserFoodie updateManyAndReturn
   */
  export type UserFoodieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * The data used to update UserFoodies.
     */
    data: XOR<UserFoodieUpdateManyMutationInput, UserFoodieUncheckedUpdateManyInput>
    /**
     * Filter which UserFoodies to update
     */
    where?: UserFoodieWhereInput
    /**
     * Limit how many UserFoodies to update.
     */
    limit?: number
  }

  /**
   * UserFoodie upsert
   */
  export type UserFoodieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFoodie to update in case it exists.
     */
    where: UserFoodieWhereUniqueInput
    /**
     * In case the UserFoodie found by the `where` argument doesn't exist, create a new UserFoodie with this data.
     */
    create: XOR<UserFoodieCreateInput, UserFoodieUncheckedCreateInput>
    /**
     * In case the UserFoodie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFoodieUpdateInput, UserFoodieUncheckedUpdateInput>
  }

  /**
   * UserFoodie delete
   */
  export type UserFoodieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
    /**
     * Filter which UserFoodie to delete.
     */
    where: UserFoodieWhereUniqueInput
  }

  /**
   * UserFoodie deleteMany
   */
  export type UserFoodieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFoodies to delete
     */
    where?: UserFoodieWhereInput
    /**
     * Limit how many UserFoodies to delete.
     */
    limit?: number
  }

  /**
   * UserFoodie.FoodieFood
   */
  export type UserFoodie$FoodieFoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    where?: FoodieFoodWhereInput
    orderBy?: FoodieFoodOrderByWithRelationInput | FoodieFoodOrderByWithRelationInput[]
    cursor?: FoodieFoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieFoodScalarFieldEnum | FoodieFoodScalarFieldEnum[]
  }

  /**
   * UserFoodie.FoodieLocation
   */
  export type UserFoodie$FoodieLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    where?: FoodieLocationWhereInput
    orderBy?: FoodieLocationOrderByWithRelationInput | FoodieLocationOrderByWithRelationInput[]
    cursor?: FoodieLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieLocationScalarFieldEnum | FoodieLocationScalarFieldEnum[]
  }

  /**
   * UserFoodie.FoodieReview
   */
  export type UserFoodie$FoodieReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    where?: FoodieReviewWhereInput
    orderBy?: FoodieReviewOrderByWithRelationInput | FoodieReviewOrderByWithRelationInput[]
    cursor?: FoodieReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieReviewScalarFieldEnum | FoodieReviewScalarFieldEnum[]
  }

  /**
   * UserFoodie.FoodieLike
   */
  export type UserFoodie$FoodieLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    where?: FoodieLikeWhereInput
    orderBy?: FoodieLikeOrderByWithRelationInput | FoodieLikeOrderByWithRelationInput[]
    cursor?: FoodieLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieLikeScalarFieldEnum | FoodieLikeScalarFieldEnum[]
  }

  /**
   * UserFoodie without action
   */
  export type UserFoodieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFoodie
     */
    select?: UserFoodieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFoodie
     */
    omit?: UserFoodieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFoodieInclude<ExtArgs> | null
  }


  /**
   * Model FoodieFood
   */

  export type AggregateFoodieFood = {
    _count: FoodieFoodCountAggregateOutputType | null
    _min: FoodieFoodMinAggregateOutputType | null
    _max: FoodieFoodMaxAggregateOutputType | null
  }

  export type FoodieFoodMinAggregateOutputType = {
    id: string | null
    name: string | null
    cuisine: string | null
    origin: string | null
    description: string | null
    submittedBy: string | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type FoodieFoodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cuisine: string | null
    origin: string | null
    description: string | null
    submittedBy: string | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type FoodieFoodCountAggregateOutputType = {
    id: number
    name: number
    cuisine: number
    origin: number
    description: number
    submittedBy: number
    validated: number
    createdAt: number
    _all: number
  }


  export type FoodieFoodMinAggregateInputType = {
    id?: true
    name?: true
    cuisine?: true
    origin?: true
    description?: true
    submittedBy?: true
    validated?: true
    createdAt?: true
  }

  export type FoodieFoodMaxAggregateInputType = {
    id?: true
    name?: true
    cuisine?: true
    origin?: true
    description?: true
    submittedBy?: true
    validated?: true
    createdAt?: true
  }

  export type FoodieFoodCountAggregateInputType = {
    id?: true
    name?: true
    cuisine?: true
    origin?: true
    description?: true
    submittedBy?: true
    validated?: true
    createdAt?: true
    _all?: true
  }

  export type FoodieFoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieFood to aggregate.
     */
    where?: FoodieFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieFoods to fetch.
     */
    orderBy?: FoodieFoodOrderByWithRelationInput | FoodieFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodieFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodieFoods
    **/
    _count?: true | FoodieFoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodieFoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodieFoodMaxAggregateInputType
  }

  export type GetFoodieFoodAggregateType<T extends FoodieFoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodieFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodieFood[P]>
      : GetScalarType<T[P], AggregateFoodieFood[P]>
  }




  export type FoodieFoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieFoodWhereInput
    orderBy?: FoodieFoodOrderByWithAggregationInput | FoodieFoodOrderByWithAggregationInput[]
    by: FoodieFoodScalarFieldEnum[] | FoodieFoodScalarFieldEnum
    having?: FoodieFoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodieFoodCountAggregateInputType | true
    _min?: FoodieFoodMinAggregateInputType
    _max?: FoodieFoodMaxAggregateInputType
  }

  export type FoodieFoodGroupByOutputType = {
    id: string
    name: string
    cuisine: string
    origin: string
    description: string
    submittedBy: string
    validated: boolean
    createdAt: Date
    _count: FoodieFoodCountAggregateOutputType | null
    _min: FoodieFoodMinAggregateOutputType | null
    _max: FoodieFoodMaxAggregateOutputType | null
  }

  type GetFoodieFoodGroupByPayload<T extends FoodieFoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodieFoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodieFoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodieFoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodieFoodGroupByOutputType[P]>
        }
      >
    >


  export type FoodieFoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cuisine?: boolean
    origin?: boolean
    description?: boolean
    submittedBy?: boolean
    validated?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    locations?: boolean | FoodieFood$locationsArgs<ExtArgs>
    reviews?: boolean | FoodieFood$reviewsArgs<ExtArgs>
    likes?: boolean | FoodieFood$likesArgs<ExtArgs>
    _count?: boolean | FoodieFoodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieFood"]>

  export type FoodieFoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cuisine?: boolean
    origin?: boolean
    description?: boolean
    submittedBy?: boolean
    validated?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieFood"]>

  export type FoodieFoodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cuisine?: boolean
    origin?: boolean
    description?: boolean
    submittedBy?: boolean
    validated?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieFood"]>

  export type FoodieFoodSelectScalar = {
    id?: boolean
    name?: boolean
    cuisine?: boolean
    origin?: boolean
    description?: boolean
    submittedBy?: boolean
    validated?: boolean
    createdAt?: boolean
  }

  export type FoodieFoodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "cuisine" | "origin" | "description" | "submittedBy" | "validated" | "createdAt", ExtArgs["result"]["foodieFood"]>
  export type FoodieFoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    locations?: boolean | FoodieFood$locationsArgs<ExtArgs>
    reviews?: boolean | FoodieFood$reviewsArgs<ExtArgs>
    likes?: boolean | FoodieFood$likesArgs<ExtArgs>
    _count?: boolean | FoodieFoodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodieFoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
  }
  export type FoodieFoodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
  }

  export type $FoodieFoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodieFood"
    objects: {
      user: Prisma.$UserFoodiePayload<ExtArgs>
      locations: Prisma.$FoodieLocationPayload<ExtArgs>[]
      reviews: Prisma.$FoodieReviewPayload<ExtArgs>[]
      likes: Prisma.$FoodieLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cuisine: string
      origin: string
      description: string
      submittedBy: string
      validated: boolean
      createdAt: Date
    }, ExtArgs["result"]["foodieFood"]>
    composites: {}
  }

  type FoodieFoodGetPayload<S extends boolean | null | undefined | FoodieFoodDefaultArgs> = $Result.GetResult<Prisma.$FoodieFoodPayload, S>

  type FoodieFoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodieFoodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodieFoodCountAggregateInputType | true
    }

  export interface FoodieFoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodieFood'], meta: { name: 'FoodieFood' } }
    /**
     * Find zero or one FoodieFood that matches the filter.
     * @param {FoodieFoodFindUniqueArgs} args - Arguments to find a FoodieFood
     * @example
     * // Get one FoodieFood
     * const foodieFood = await prisma.foodieFood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodieFoodFindUniqueArgs>(args: SelectSubset<T, FoodieFoodFindUniqueArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodieFood that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodieFoodFindUniqueOrThrowArgs} args - Arguments to find a FoodieFood
     * @example
     * // Get one FoodieFood
     * const foodieFood = await prisma.foodieFood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodieFoodFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodieFoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieFood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodFindFirstArgs} args - Arguments to find a FoodieFood
     * @example
     * // Get one FoodieFood
     * const foodieFood = await prisma.foodieFood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodieFoodFindFirstArgs>(args?: SelectSubset<T, FoodieFoodFindFirstArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieFood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodFindFirstOrThrowArgs} args - Arguments to find a FoodieFood
     * @example
     * // Get one FoodieFood
     * const foodieFood = await prisma.foodieFood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodieFoodFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodieFoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodieFoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodieFoods
     * const foodieFoods = await prisma.foodieFood.findMany()
     * 
     * // Get first 10 FoodieFoods
     * const foodieFoods = await prisma.foodieFood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodieFoodWithIdOnly = await prisma.foodieFood.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodieFoodFindManyArgs>(args?: SelectSubset<T, FoodieFoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodieFood.
     * @param {FoodieFoodCreateArgs} args - Arguments to create a FoodieFood.
     * @example
     * // Create one FoodieFood
     * const FoodieFood = await prisma.foodieFood.create({
     *   data: {
     *     // ... data to create a FoodieFood
     *   }
     * })
     * 
     */
    create<T extends FoodieFoodCreateArgs>(args: SelectSubset<T, FoodieFoodCreateArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodieFoods.
     * @param {FoodieFoodCreateManyArgs} args - Arguments to create many FoodieFoods.
     * @example
     * // Create many FoodieFoods
     * const foodieFood = await prisma.foodieFood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodieFoodCreateManyArgs>(args?: SelectSubset<T, FoodieFoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodieFoods and returns the data saved in the database.
     * @param {FoodieFoodCreateManyAndReturnArgs} args - Arguments to create many FoodieFoods.
     * @example
     * // Create many FoodieFoods
     * const foodieFood = await prisma.foodieFood.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodieFoods and only return the `id`
     * const foodieFoodWithIdOnly = await prisma.foodieFood.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodieFoodCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodieFoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodieFood.
     * @param {FoodieFoodDeleteArgs} args - Arguments to delete one FoodieFood.
     * @example
     * // Delete one FoodieFood
     * const FoodieFood = await prisma.foodieFood.delete({
     *   where: {
     *     // ... filter to delete one FoodieFood
     *   }
     * })
     * 
     */
    delete<T extends FoodieFoodDeleteArgs>(args: SelectSubset<T, FoodieFoodDeleteArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodieFood.
     * @param {FoodieFoodUpdateArgs} args - Arguments to update one FoodieFood.
     * @example
     * // Update one FoodieFood
     * const foodieFood = await prisma.foodieFood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodieFoodUpdateArgs>(args: SelectSubset<T, FoodieFoodUpdateArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodieFoods.
     * @param {FoodieFoodDeleteManyArgs} args - Arguments to filter FoodieFoods to delete.
     * @example
     * // Delete a few FoodieFoods
     * const { count } = await prisma.foodieFood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodieFoodDeleteManyArgs>(args?: SelectSubset<T, FoodieFoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieFoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodieFoods
     * const foodieFood = await prisma.foodieFood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodieFoodUpdateManyArgs>(args: SelectSubset<T, FoodieFoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieFoods and returns the data updated in the database.
     * @param {FoodieFoodUpdateManyAndReturnArgs} args - Arguments to update many FoodieFoods.
     * @example
     * // Update many FoodieFoods
     * const foodieFood = await prisma.foodieFood.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodieFoods and only return the `id`
     * const foodieFoodWithIdOnly = await prisma.foodieFood.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodieFoodUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodieFoodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodieFood.
     * @param {FoodieFoodUpsertArgs} args - Arguments to update or create a FoodieFood.
     * @example
     * // Update or create a FoodieFood
     * const foodieFood = await prisma.foodieFood.upsert({
     *   create: {
     *     // ... data to create a FoodieFood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodieFood we want to update
     *   }
     * })
     */
    upsert<T extends FoodieFoodUpsertArgs>(args: SelectSubset<T, FoodieFoodUpsertArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodieFoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodCountArgs} args - Arguments to filter FoodieFoods to count.
     * @example
     * // Count the number of FoodieFoods
     * const count = await prisma.foodieFood.count({
     *   where: {
     *     // ... the filter for the FoodieFoods we want to count
     *   }
     * })
    **/
    count<T extends FoodieFoodCountArgs>(
      args?: Subset<T, FoodieFoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodieFoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodieFood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodieFoodAggregateArgs>(args: Subset<T, FoodieFoodAggregateArgs>): Prisma.PrismaPromise<GetFoodieFoodAggregateType<T>>

    /**
     * Group by FoodieFood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieFoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodieFoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodieFoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodieFoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodieFoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodieFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodieFood model
   */
  readonly fields: FoodieFoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodieFood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodieFoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFoodieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodieDefaultArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    locations<T extends FoodieFood$locationsArgs<ExtArgs> = {}>(args?: Subset<T, FoodieFood$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends FoodieFood$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, FoodieFood$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends FoodieFood$likesArgs<ExtArgs> = {}>(args?: Subset<T, FoodieFood$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodieFood model
   */ 
  interface FoodieFoodFieldRefs {
    readonly id: FieldRef<"FoodieFood", 'String'>
    readonly name: FieldRef<"FoodieFood", 'String'>
    readonly cuisine: FieldRef<"FoodieFood", 'String'>
    readonly origin: FieldRef<"FoodieFood", 'String'>
    readonly description: FieldRef<"FoodieFood", 'String'>
    readonly submittedBy: FieldRef<"FoodieFood", 'String'>
    readonly validated: FieldRef<"FoodieFood", 'Boolean'>
    readonly createdAt: FieldRef<"FoodieFood", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodieFood findUnique
   */
  export type FoodieFoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * Filter, which FoodieFood to fetch.
     */
    where: FoodieFoodWhereUniqueInput
  }

  /**
   * FoodieFood findUniqueOrThrow
   */
  export type FoodieFoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * Filter, which FoodieFood to fetch.
     */
    where: FoodieFoodWhereUniqueInput
  }

  /**
   * FoodieFood findFirst
   */
  export type FoodieFoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * Filter, which FoodieFood to fetch.
     */
    where?: FoodieFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieFoods to fetch.
     */
    orderBy?: FoodieFoodOrderByWithRelationInput | FoodieFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieFoods.
     */
    cursor?: FoodieFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieFoods.
     */
    distinct?: FoodieFoodScalarFieldEnum | FoodieFoodScalarFieldEnum[]
  }

  /**
   * FoodieFood findFirstOrThrow
   */
  export type FoodieFoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * Filter, which FoodieFood to fetch.
     */
    where?: FoodieFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieFoods to fetch.
     */
    orderBy?: FoodieFoodOrderByWithRelationInput | FoodieFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieFoods.
     */
    cursor?: FoodieFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieFoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieFoods.
     */
    distinct?: FoodieFoodScalarFieldEnum | FoodieFoodScalarFieldEnum[]
  }

  /**
   * FoodieFood findMany
   */
  export type FoodieFoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * Filter, which FoodieFoods to fetch.
     */
    where?: FoodieFoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieFoods to fetch.
     */
    orderBy?: FoodieFoodOrderByWithRelationInput | FoodieFoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodieFoods.
     */
    cursor?: FoodieFoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieFoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieFoods.
     */
    skip?: number
    distinct?: FoodieFoodScalarFieldEnum | FoodieFoodScalarFieldEnum[]
  }

  /**
   * FoodieFood create
   */
  export type FoodieFoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodieFood.
     */
    data: XOR<FoodieFoodCreateInput, FoodieFoodUncheckedCreateInput>
  }

  /**
   * FoodieFood createMany
   */
  export type FoodieFoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodieFoods.
     */
    data: FoodieFoodCreateManyInput | FoodieFoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodieFood createManyAndReturn
   */
  export type FoodieFoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * The data used to create many FoodieFoods.
     */
    data: FoodieFoodCreateManyInput | FoodieFoodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieFood update
   */
  export type FoodieFoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodieFood.
     */
    data: XOR<FoodieFoodUpdateInput, FoodieFoodUncheckedUpdateInput>
    /**
     * Choose, which FoodieFood to update.
     */
    where: FoodieFoodWhereUniqueInput
  }

  /**
   * FoodieFood updateMany
   */
  export type FoodieFoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodieFoods.
     */
    data: XOR<FoodieFoodUpdateManyMutationInput, FoodieFoodUncheckedUpdateManyInput>
    /**
     * Filter which FoodieFoods to update
     */
    where?: FoodieFoodWhereInput
    /**
     * Limit how many FoodieFoods to update.
     */
    limit?: number
  }

  /**
   * FoodieFood updateManyAndReturn
   */
  export type FoodieFoodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * The data used to update FoodieFoods.
     */
    data: XOR<FoodieFoodUpdateManyMutationInput, FoodieFoodUncheckedUpdateManyInput>
    /**
     * Filter which FoodieFoods to update
     */
    where?: FoodieFoodWhereInput
    /**
     * Limit how many FoodieFoods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieFood upsert
   */
  export type FoodieFoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodieFood to update in case it exists.
     */
    where: FoodieFoodWhereUniqueInput
    /**
     * In case the FoodieFood found by the `where` argument doesn't exist, create a new FoodieFood with this data.
     */
    create: XOR<FoodieFoodCreateInput, FoodieFoodUncheckedCreateInput>
    /**
     * In case the FoodieFood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodieFoodUpdateInput, FoodieFoodUncheckedUpdateInput>
  }

  /**
   * FoodieFood delete
   */
  export type FoodieFoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
    /**
     * Filter which FoodieFood to delete.
     */
    where: FoodieFoodWhereUniqueInput
  }

  /**
   * FoodieFood deleteMany
   */
  export type FoodieFoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieFoods to delete
     */
    where?: FoodieFoodWhereInput
    /**
     * Limit how many FoodieFoods to delete.
     */
    limit?: number
  }

  /**
   * FoodieFood.locations
   */
  export type FoodieFood$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    where?: FoodieLocationWhereInput
    orderBy?: FoodieLocationOrderByWithRelationInput | FoodieLocationOrderByWithRelationInput[]
    cursor?: FoodieLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieLocationScalarFieldEnum | FoodieLocationScalarFieldEnum[]
  }

  /**
   * FoodieFood.reviews
   */
  export type FoodieFood$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    where?: FoodieReviewWhereInput
    orderBy?: FoodieReviewOrderByWithRelationInput | FoodieReviewOrderByWithRelationInput[]
    cursor?: FoodieReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieReviewScalarFieldEnum | FoodieReviewScalarFieldEnum[]
  }

  /**
   * FoodieFood.likes
   */
  export type FoodieFood$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    where?: FoodieLikeWhereInput
    orderBy?: FoodieLikeOrderByWithRelationInput | FoodieLikeOrderByWithRelationInput[]
    cursor?: FoodieLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodieLikeScalarFieldEnum | FoodieLikeScalarFieldEnum[]
  }

  /**
   * FoodieFood without action
   */
  export type FoodieFoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieFood
     */
    select?: FoodieFoodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieFood
     */
    omit?: FoodieFoodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieFoodInclude<ExtArgs> | null
  }


  /**
   * Model FoodieLocation
   */

  export type AggregateFoodieLocation = {
    _count: FoodieLocationCountAggregateOutputType | null
    _min: FoodieLocationMinAggregateOutputType | null
    _max: FoodieLocationMaxAggregateOutputType | null
  }

  export type FoodieLocationMinAggregateOutputType = {
    id: string | null
    foodId: string | null
    locationName: string | null
    address: string | null
    submittedBy: string | null
    createdAt: Date | null
  }

  export type FoodieLocationMaxAggregateOutputType = {
    id: string | null
    foodId: string | null
    locationName: string | null
    address: string | null
    submittedBy: string | null
    createdAt: Date | null
  }

  export type FoodieLocationCountAggregateOutputType = {
    id: number
    foodId: number
    locationName: number
    address: number
    submittedBy: number
    createdAt: number
    _all: number
  }


  export type FoodieLocationMinAggregateInputType = {
    id?: true
    foodId?: true
    locationName?: true
    address?: true
    submittedBy?: true
    createdAt?: true
  }

  export type FoodieLocationMaxAggregateInputType = {
    id?: true
    foodId?: true
    locationName?: true
    address?: true
    submittedBy?: true
    createdAt?: true
  }

  export type FoodieLocationCountAggregateInputType = {
    id?: true
    foodId?: true
    locationName?: true
    address?: true
    submittedBy?: true
    createdAt?: true
    _all?: true
  }

  export type FoodieLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieLocation to aggregate.
     */
    where?: FoodieLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLocations to fetch.
     */
    orderBy?: FoodieLocationOrderByWithRelationInput | FoodieLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodieLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodieLocations
    **/
    _count?: true | FoodieLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodieLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodieLocationMaxAggregateInputType
  }

  export type GetFoodieLocationAggregateType<T extends FoodieLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodieLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodieLocation[P]>
      : GetScalarType<T[P], AggregateFoodieLocation[P]>
  }




  export type FoodieLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieLocationWhereInput
    orderBy?: FoodieLocationOrderByWithAggregationInput | FoodieLocationOrderByWithAggregationInput[]
    by: FoodieLocationScalarFieldEnum[] | FoodieLocationScalarFieldEnum
    having?: FoodieLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodieLocationCountAggregateInputType | true
    _min?: FoodieLocationMinAggregateInputType
    _max?: FoodieLocationMaxAggregateInputType
  }

  export type FoodieLocationGroupByOutputType = {
    id: string
    foodId: string
    locationName: string
    address: string
    submittedBy: string
    createdAt: Date
    _count: FoodieLocationCountAggregateOutputType | null
    _min: FoodieLocationMinAggregateOutputType | null
    _max: FoodieLocationMaxAggregateOutputType | null
  }

  type GetFoodieLocationGroupByPayload<T extends FoodieLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodieLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodieLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodieLocationGroupByOutputType[P]>
            : GetScalarType<T[P], FoodieLocationGroupByOutputType[P]>
        }
      >
    >


  export type FoodieLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    locationName?: boolean
    address?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieLocation"]>

  export type FoodieLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    locationName?: boolean
    address?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieLocation"]>

  export type FoodieLocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    locationName?: boolean
    address?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieLocation"]>

  export type FoodieLocationSelectScalar = {
    id?: boolean
    foodId?: boolean
    locationName?: boolean
    address?: boolean
    submittedBy?: boolean
    createdAt?: boolean
  }

  export type FoodieLocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foodId" | "locationName" | "address" | "submittedBy" | "createdAt", ExtArgs["result"]["foodieLocation"]>
  export type FoodieLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }
  export type FoodieLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }
  export type FoodieLocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }

  export type $FoodieLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodieLocation"
    objects: {
      user: Prisma.$UserFoodiePayload<ExtArgs>
      food: Prisma.$FoodieFoodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      foodId: string
      locationName: string
      address: string
      submittedBy: string
      createdAt: Date
    }, ExtArgs["result"]["foodieLocation"]>
    composites: {}
  }

  type FoodieLocationGetPayload<S extends boolean | null | undefined | FoodieLocationDefaultArgs> = $Result.GetResult<Prisma.$FoodieLocationPayload, S>

  type FoodieLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodieLocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodieLocationCountAggregateInputType | true
    }

  export interface FoodieLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodieLocation'], meta: { name: 'FoodieLocation' } }
    /**
     * Find zero or one FoodieLocation that matches the filter.
     * @param {FoodieLocationFindUniqueArgs} args - Arguments to find a FoodieLocation
     * @example
     * // Get one FoodieLocation
     * const foodieLocation = await prisma.foodieLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodieLocationFindUniqueArgs>(args: SelectSubset<T, FoodieLocationFindUniqueArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodieLocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodieLocationFindUniqueOrThrowArgs} args - Arguments to find a FoodieLocation
     * @example
     * // Get one FoodieLocation
     * const foodieLocation = await prisma.foodieLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodieLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodieLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationFindFirstArgs} args - Arguments to find a FoodieLocation
     * @example
     * // Get one FoodieLocation
     * const foodieLocation = await prisma.foodieLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodieLocationFindFirstArgs>(args?: SelectSubset<T, FoodieLocationFindFirstArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationFindFirstOrThrowArgs} args - Arguments to find a FoodieLocation
     * @example
     * // Get one FoodieLocation
     * const foodieLocation = await prisma.foodieLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodieLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodieLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodieLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodieLocations
     * const foodieLocations = await prisma.foodieLocation.findMany()
     * 
     * // Get first 10 FoodieLocations
     * const foodieLocations = await prisma.foodieLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodieLocationWithIdOnly = await prisma.foodieLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodieLocationFindManyArgs>(args?: SelectSubset<T, FoodieLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodieLocation.
     * @param {FoodieLocationCreateArgs} args - Arguments to create a FoodieLocation.
     * @example
     * // Create one FoodieLocation
     * const FoodieLocation = await prisma.foodieLocation.create({
     *   data: {
     *     // ... data to create a FoodieLocation
     *   }
     * })
     * 
     */
    create<T extends FoodieLocationCreateArgs>(args: SelectSubset<T, FoodieLocationCreateArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodieLocations.
     * @param {FoodieLocationCreateManyArgs} args - Arguments to create many FoodieLocations.
     * @example
     * // Create many FoodieLocations
     * const foodieLocation = await prisma.foodieLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodieLocationCreateManyArgs>(args?: SelectSubset<T, FoodieLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodieLocations and returns the data saved in the database.
     * @param {FoodieLocationCreateManyAndReturnArgs} args - Arguments to create many FoodieLocations.
     * @example
     * // Create many FoodieLocations
     * const foodieLocation = await prisma.foodieLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodieLocations and only return the `id`
     * const foodieLocationWithIdOnly = await prisma.foodieLocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodieLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodieLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodieLocation.
     * @param {FoodieLocationDeleteArgs} args - Arguments to delete one FoodieLocation.
     * @example
     * // Delete one FoodieLocation
     * const FoodieLocation = await prisma.foodieLocation.delete({
     *   where: {
     *     // ... filter to delete one FoodieLocation
     *   }
     * })
     * 
     */
    delete<T extends FoodieLocationDeleteArgs>(args: SelectSubset<T, FoodieLocationDeleteArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodieLocation.
     * @param {FoodieLocationUpdateArgs} args - Arguments to update one FoodieLocation.
     * @example
     * // Update one FoodieLocation
     * const foodieLocation = await prisma.foodieLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodieLocationUpdateArgs>(args: SelectSubset<T, FoodieLocationUpdateArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodieLocations.
     * @param {FoodieLocationDeleteManyArgs} args - Arguments to filter FoodieLocations to delete.
     * @example
     * // Delete a few FoodieLocations
     * const { count } = await prisma.foodieLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodieLocationDeleteManyArgs>(args?: SelectSubset<T, FoodieLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodieLocations
     * const foodieLocation = await prisma.foodieLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodieLocationUpdateManyArgs>(args: SelectSubset<T, FoodieLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieLocations and returns the data updated in the database.
     * @param {FoodieLocationUpdateManyAndReturnArgs} args - Arguments to update many FoodieLocations.
     * @example
     * // Update many FoodieLocations
     * const foodieLocation = await prisma.foodieLocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodieLocations and only return the `id`
     * const foodieLocationWithIdOnly = await prisma.foodieLocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodieLocationUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodieLocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodieLocation.
     * @param {FoodieLocationUpsertArgs} args - Arguments to update or create a FoodieLocation.
     * @example
     * // Update or create a FoodieLocation
     * const foodieLocation = await prisma.foodieLocation.upsert({
     *   create: {
     *     // ... data to create a FoodieLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodieLocation we want to update
     *   }
     * })
     */
    upsert<T extends FoodieLocationUpsertArgs>(args: SelectSubset<T, FoodieLocationUpsertArgs<ExtArgs>>): Prisma__FoodieLocationClient<$Result.GetResult<Prisma.$FoodieLocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodieLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationCountArgs} args - Arguments to filter FoodieLocations to count.
     * @example
     * // Count the number of FoodieLocations
     * const count = await prisma.foodieLocation.count({
     *   where: {
     *     // ... the filter for the FoodieLocations we want to count
     *   }
     * })
    **/
    count<T extends FoodieLocationCountArgs>(
      args?: Subset<T, FoodieLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodieLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodieLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodieLocationAggregateArgs>(args: Subset<T, FoodieLocationAggregateArgs>): Prisma.PrismaPromise<GetFoodieLocationAggregateType<T>>

    /**
     * Group by FoodieLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodieLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodieLocationGroupByArgs['orderBy'] }
        : { orderBy?: FoodieLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodieLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodieLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodieLocation model
   */
  readonly fields: FoodieLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodieLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodieLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFoodieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodieDefaultArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    food<T extends FoodieFoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodieFoodDefaultArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodieLocation model
   */ 
  interface FoodieLocationFieldRefs {
    readonly id: FieldRef<"FoodieLocation", 'String'>
    readonly foodId: FieldRef<"FoodieLocation", 'String'>
    readonly locationName: FieldRef<"FoodieLocation", 'String'>
    readonly address: FieldRef<"FoodieLocation", 'String'>
    readonly submittedBy: FieldRef<"FoodieLocation", 'String'>
    readonly createdAt: FieldRef<"FoodieLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodieLocation findUnique
   */
  export type FoodieLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLocation to fetch.
     */
    where: FoodieLocationWhereUniqueInput
  }

  /**
   * FoodieLocation findUniqueOrThrow
   */
  export type FoodieLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLocation to fetch.
     */
    where: FoodieLocationWhereUniqueInput
  }

  /**
   * FoodieLocation findFirst
   */
  export type FoodieLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLocation to fetch.
     */
    where?: FoodieLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLocations to fetch.
     */
    orderBy?: FoodieLocationOrderByWithRelationInput | FoodieLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieLocations.
     */
    cursor?: FoodieLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieLocations.
     */
    distinct?: FoodieLocationScalarFieldEnum | FoodieLocationScalarFieldEnum[]
  }

  /**
   * FoodieLocation findFirstOrThrow
   */
  export type FoodieLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLocation to fetch.
     */
    where?: FoodieLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLocations to fetch.
     */
    orderBy?: FoodieLocationOrderByWithRelationInput | FoodieLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieLocations.
     */
    cursor?: FoodieLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieLocations.
     */
    distinct?: FoodieLocationScalarFieldEnum | FoodieLocationScalarFieldEnum[]
  }

  /**
   * FoodieLocation findMany
   */
  export type FoodieLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLocations to fetch.
     */
    where?: FoodieLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLocations to fetch.
     */
    orderBy?: FoodieLocationOrderByWithRelationInput | FoodieLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodieLocations.
     */
    cursor?: FoodieLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLocations.
     */
    skip?: number
    distinct?: FoodieLocationScalarFieldEnum | FoodieLocationScalarFieldEnum[]
  }

  /**
   * FoodieLocation create
   */
  export type FoodieLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodieLocation.
     */
    data: XOR<FoodieLocationCreateInput, FoodieLocationUncheckedCreateInput>
  }

  /**
   * FoodieLocation createMany
   */
  export type FoodieLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodieLocations.
     */
    data: FoodieLocationCreateManyInput | FoodieLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodieLocation createManyAndReturn
   */
  export type FoodieLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * The data used to create many FoodieLocations.
     */
    data: FoodieLocationCreateManyInput | FoodieLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieLocation update
   */
  export type FoodieLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodieLocation.
     */
    data: XOR<FoodieLocationUpdateInput, FoodieLocationUncheckedUpdateInput>
    /**
     * Choose, which FoodieLocation to update.
     */
    where: FoodieLocationWhereUniqueInput
  }

  /**
   * FoodieLocation updateMany
   */
  export type FoodieLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodieLocations.
     */
    data: XOR<FoodieLocationUpdateManyMutationInput, FoodieLocationUncheckedUpdateManyInput>
    /**
     * Filter which FoodieLocations to update
     */
    where?: FoodieLocationWhereInput
    /**
     * Limit how many FoodieLocations to update.
     */
    limit?: number
  }

  /**
   * FoodieLocation updateManyAndReturn
   */
  export type FoodieLocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * The data used to update FoodieLocations.
     */
    data: XOR<FoodieLocationUpdateManyMutationInput, FoodieLocationUncheckedUpdateManyInput>
    /**
     * Filter which FoodieLocations to update
     */
    where?: FoodieLocationWhereInput
    /**
     * Limit how many FoodieLocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieLocation upsert
   */
  export type FoodieLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodieLocation to update in case it exists.
     */
    where: FoodieLocationWhereUniqueInput
    /**
     * In case the FoodieLocation found by the `where` argument doesn't exist, create a new FoodieLocation with this data.
     */
    create: XOR<FoodieLocationCreateInput, FoodieLocationUncheckedCreateInput>
    /**
     * In case the FoodieLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodieLocationUpdateInput, FoodieLocationUncheckedUpdateInput>
  }

  /**
   * FoodieLocation delete
   */
  export type FoodieLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
    /**
     * Filter which FoodieLocation to delete.
     */
    where: FoodieLocationWhereUniqueInput
  }

  /**
   * FoodieLocation deleteMany
   */
  export type FoodieLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieLocations to delete
     */
    where?: FoodieLocationWhereInput
    /**
     * Limit how many FoodieLocations to delete.
     */
    limit?: number
  }

  /**
   * FoodieLocation without action
   */
  export type FoodieLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLocation
     */
    select?: FoodieLocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLocation
     */
    omit?: FoodieLocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLocationInclude<ExtArgs> | null
  }


  /**
   * Model FoodieReview
   */

  export type AggregateFoodieReview = {
    _count: FoodieReviewCountAggregateOutputType | null
    _avg: FoodieReviewAvgAggregateOutputType | null
    _sum: FoodieReviewSumAggregateOutputType | null
    _min: FoodieReviewMinAggregateOutputType | null
    _max: FoodieReviewMaxAggregateOutputType | null
  }

  export type FoodieReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type FoodieReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type FoodieReviewMinAggregateOutputType = {
    id: string | null
    foodId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type FoodieReviewMaxAggregateOutputType = {
    id: string | null
    foodId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type FoodieReviewCountAggregateOutputType = {
    id: number
    foodId: number
    userId: number
    rating: number
    comment: number
    validated: number
    createdAt: number
    _all: number
  }


  export type FoodieReviewAvgAggregateInputType = {
    rating?: true
  }

  export type FoodieReviewSumAggregateInputType = {
    rating?: true
  }

  export type FoodieReviewMinAggregateInputType = {
    id?: true
    foodId?: true
    userId?: true
    rating?: true
    comment?: true
    validated?: true
    createdAt?: true
  }

  export type FoodieReviewMaxAggregateInputType = {
    id?: true
    foodId?: true
    userId?: true
    rating?: true
    comment?: true
    validated?: true
    createdAt?: true
  }

  export type FoodieReviewCountAggregateInputType = {
    id?: true
    foodId?: true
    userId?: true
    rating?: true
    comment?: true
    validated?: true
    createdAt?: true
    _all?: true
  }

  export type FoodieReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieReview to aggregate.
     */
    where?: FoodieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieReviews to fetch.
     */
    orderBy?: FoodieReviewOrderByWithRelationInput | FoodieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodieReviews
    **/
    _count?: true | FoodieReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodieReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodieReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodieReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodieReviewMaxAggregateInputType
  }

  export type GetFoodieReviewAggregateType<T extends FoodieReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodieReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodieReview[P]>
      : GetScalarType<T[P], AggregateFoodieReview[P]>
  }




  export type FoodieReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieReviewWhereInput
    orderBy?: FoodieReviewOrderByWithAggregationInput | FoodieReviewOrderByWithAggregationInput[]
    by: FoodieReviewScalarFieldEnum[] | FoodieReviewScalarFieldEnum
    having?: FoodieReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodieReviewCountAggregateInputType | true
    _avg?: FoodieReviewAvgAggregateInputType
    _sum?: FoodieReviewSumAggregateInputType
    _min?: FoodieReviewMinAggregateInputType
    _max?: FoodieReviewMaxAggregateInputType
  }

  export type FoodieReviewGroupByOutputType = {
    id: string
    foodId: string
    userId: string
    rating: number
    comment: string
    validated: boolean
    createdAt: Date
    _count: FoodieReviewCountAggregateOutputType | null
    _avg: FoodieReviewAvgAggregateOutputType | null
    _sum: FoodieReviewSumAggregateOutputType | null
    _min: FoodieReviewMinAggregateOutputType | null
    _max: FoodieReviewMaxAggregateOutputType | null
  }

  type GetFoodieReviewGroupByPayload<T extends FoodieReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodieReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodieReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodieReviewGroupByOutputType[P]>
            : GetScalarType<T[P], FoodieReviewGroupByOutputType[P]>
        }
      >
    >


  export type FoodieReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieReview"]>

  export type FoodieReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieReview"]>

  export type FoodieReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieReview"]>

  export type FoodieReviewSelectScalar = {
    id?: boolean
    foodId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
  }

  export type FoodieReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foodId" | "userId" | "rating" | "comment" | "validated" | "createdAt", ExtArgs["result"]["foodieReview"]>
  export type FoodieReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }
  export type FoodieReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }
  export type FoodieReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }

  export type $FoodieReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodieReview"
    objects: {
      user: Prisma.$UserFoodiePayload<ExtArgs>
      food: Prisma.$FoodieFoodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      foodId: string
      userId: string
      rating: number
      comment: string
      validated: boolean
      createdAt: Date
    }, ExtArgs["result"]["foodieReview"]>
    composites: {}
  }

  type FoodieReviewGetPayload<S extends boolean | null | undefined | FoodieReviewDefaultArgs> = $Result.GetResult<Prisma.$FoodieReviewPayload, S>

  type FoodieReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodieReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodieReviewCountAggregateInputType | true
    }

  export interface FoodieReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodieReview'], meta: { name: 'FoodieReview' } }
    /**
     * Find zero or one FoodieReview that matches the filter.
     * @param {FoodieReviewFindUniqueArgs} args - Arguments to find a FoodieReview
     * @example
     * // Get one FoodieReview
     * const foodieReview = await prisma.foodieReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodieReviewFindUniqueArgs>(args: SelectSubset<T, FoodieReviewFindUniqueArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodieReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodieReviewFindUniqueOrThrowArgs} args - Arguments to find a FoodieReview
     * @example
     * // Get one FoodieReview
     * const foodieReview = await prisma.foodieReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodieReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodieReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewFindFirstArgs} args - Arguments to find a FoodieReview
     * @example
     * // Get one FoodieReview
     * const foodieReview = await prisma.foodieReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodieReviewFindFirstArgs>(args?: SelectSubset<T, FoodieReviewFindFirstArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewFindFirstOrThrowArgs} args - Arguments to find a FoodieReview
     * @example
     * // Get one FoodieReview
     * const foodieReview = await prisma.foodieReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodieReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodieReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodieReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodieReviews
     * const foodieReviews = await prisma.foodieReview.findMany()
     * 
     * // Get first 10 FoodieReviews
     * const foodieReviews = await prisma.foodieReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodieReviewWithIdOnly = await prisma.foodieReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodieReviewFindManyArgs>(args?: SelectSubset<T, FoodieReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodieReview.
     * @param {FoodieReviewCreateArgs} args - Arguments to create a FoodieReview.
     * @example
     * // Create one FoodieReview
     * const FoodieReview = await prisma.foodieReview.create({
     *   data: {
     *     // ... data to create a FoodieReview
     *   }
     * })
     * 
     */
    create<T extends FoodieReviewCreateArgs>(args: SelectSubset<T, FoodieReviewCreateArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodieReviews.
     * @param {FoodieReviewCreateManyArgs} args - Arguments to create many FoodieReviews.
     * @example
     * // Create many FoodieReviews
     * const foodieReview = await prisma.foodieReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodieReviewCreateManyArgs>(args?: SelectSubset<T, FoodieReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodieReviews and returns the data saved in the database.
     * @param {FoodieReviewCreateManyAndReturnArgs} args - Arguments to create many FoodieReviews.
     * @example
     * // Create many FoodieReviews
     * const foodieReview = await prisma.foodieReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodieReviews and only return the `id`
     * const foodieReviewWithIdOnly = await prisma.foodieReview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodieReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodieReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodieReview.
     * @param {FoodieReviewDeleteArgs} args - Arguments to delete one FoodieReview.
     * @example
     * // Delete one FoodieReview
     * const FoodieReview = await prisma.foodieReview.delete({
     *   where: {
     *     // ... filter to delete one FoodieReview
     *   }
     * })
     * 
     */
    delete<T extends FoodieReviewDeleteArgs>(args: SelectSubset<T, FoodieReviewDeleteArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodieReview.
     * @param {FoodieReviewUpdateArgs} args - Arguments to update one FoodieReview.
     * @example
     * // Update one FoodieReview
     * const foodieReview = await prisma.foodieReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodieReviewUpdateArgs>(args: SelectSubset<T, FoodieReviewUpdateArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodieReviews.
     * @param {FoodieReviewDeleteManyArgs} args - Arguments to filter FoodieReviews to delete.
     * @example
     * // Delete a few FoodieReviews
     * const { count } = await prisma.foodieReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodieReviewDeleteManyArgs>(args?: SelectSubset<T, FoodieReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodieReviews
     * const foodieReview = await prisma.foodieReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodieReviewUpdateManyArgs>(args: SelectSubset<T, FoodieReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieReviews and returns the data updated in the database.
     * @param {FoodieReviewUpdateManyAndReturnArgs} args - Arguments to update many FoodieReviews.
     * @example
     * // Update many FoodieReviews
     * const foodieReview = await prisma.foodieReview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodieReviews and only return the `id`
     * const foodieReviewWithIdOnly = await prisma.foodieReview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodieReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodieReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodieReview.
     * @param {FoodieReviewUpsertArgs} args - Arguments to update or create a FoodieReview.
     * @example
     * // Update or create a FoodieReview
     * const foodieReview = await prisma.foodieReview.upsert({
     *   create: {
     *     // ... data to create a FoodieReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodieReview we want to update
     *   }
     * })
     */
    upsert<T extends FoodieReviewUpsertArgs>(args: SelectSubset<T, FoodieReviewUpsertArgs<ExtArgs>>): Prisma__FoodieReviewClient<$Result.GetResult<Prisma.$FoodieReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodieReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewCountArgs} args - Arguments to filter FoodieReviews to count.
     * @example
     * // Count the number of FoodieReviews
     * const count = await prisma.foodieReview.count({
     *   where: {
     *     // ... the filter for the FoodieReviews we want to count
     *   }
     * })
    **/
    count<T extends FoodieReviewCountArgs>(
      args?: Subset<T, FoodieReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodieReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodieReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodieReviewAggregateArgs>(args: Subset<T, FoodieReviewAggregateArgs>): Prisma.PrismaPromise<GetFoodieReviewAggregateType<T>>

    /**
     * Group by FoodieReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodieReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodieReviewGroupByArgs['orderBy'] }
        : { orderBy?: FoodieReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodieReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodieReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodieReview model
   */
  readonly fields: FoodieReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodieReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodieReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFoodieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodieDefaultArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    food<T extends FoodieFoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodieFoodDefaultArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodieReview model
   */ 
  interface FoodieReviewFieldRefs {
    readonly id: FieldRef<"FoodieReview", 'String'>
    readonly foodId: FieldRef<"FoodieReview", 'String'>
    readonly userId: FieldRef<"FoodieReview", 'String'>
    readonly rating: FieldRef<"FoodieReview", 'Int'>
    readonly comment: FieldRef<"FoodieReview", 'String'>
    readonly validated: FieldRef<"FoodieReview", 'Boolean'>
    readonly createdAt: FieldRef<"FoodieReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodieReview findUnique
   */
  export type FoodieReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * Filter, which FoodieReview to fetch.
     */
    where: FoodieReviewWhereUniqueInput
  }

  /**
   * FoodieReview findUniqueOrThrow
   */
  export type FoodieReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * Filter, which FoodieReview to fetch.
     */
    where: FoodieReviewWhereUniqueInput
  }

  /**
   * FoodieReview findFirst
   */
  export type FoodieReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * Filter, which FoodieReview to fetch.
     */
    where?: FoodieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieReviews to fetch.
     */
    orderBy?: FoodieReviewOrderByWithRelationInput | FoodieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieReviews.
     */
    cursor?: FoodieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieReviews.
     */
    distinct?: FoodieReviewScalarFieldEnum | FoodieReviewScalarFieldEnum[]
  }

  /**
   * FoodieReview findFirstOrThrow
   */
  export type FoodieReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * Filter, which FoodieReview to fetch.
     */
    where?: FoodieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieReviews to fetch.
     */
    orderBy?: FoodieReviewOrderByWithRelationInput | FoodieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieReviews.
     */
    cursor?: FoodieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieReviews.
     */
    distinct?: FoodieReviewScalarFieldEnum | FoodieReviewScalarFieldEnum[]
  }

  /**
   * FoodieReview findMany
   */
  export type FoodieReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * Filter, which FoodieReviews to fetch.
     */
    where?: FoodieReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieReviews to fetch.
     */
    orderBy?: FoodieReviewOrderByWithRelationInput | FoodieReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodieReviews.
     */
    cursor?: FoodieReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieReviews.
     */
    skip?: number
    distinct?: FoodieReviewScalarFieldEnum | FoodieReviewScalarFieldEnum[]
  }

  /**
   * FoodieReview create
   */
  export type FoodieReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodieReview.
     */
    data: XOR<FoodieReviewCreateInput, FoodieReviewUncheckedCreateInput>
  }

  /**
   * FoodieReview createMany
   */
  export type FoodieReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodieReviews.
     */
    data: FoodieReviewCreateManyInput | FoodieReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodieReview createManyAndReturn
   */
  export type FoodieReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * The data used to create many FoodieReviews.
     */
    data: FoodieReviewCreateManyInput | FoodieReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieReview update
   */
  export type FoodieReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodieReview.
     */
    data: XOR<FoodieReviewUpdateInput, FoodieReviewUncheckedUpdateInput>
    /**
     * Choose, which FoodieReview to update.
     */
    where: FoodieReviewWhereUniqueInput
  }

  /**
   * FoodieReview updateMany
   */
  export type FoodieReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodieReviews.
     */
    data: XOR<FoodieReviewUpdateManyMutationInput, FoodieReviewUncheckedUpdateManyInput>
    /**
     * Filter which FoodieReviews to update
     */
    where?: FoodieReviewWhereInput
    /**
     * Limit how many FoodieReviews to update.
     */
    limit?: number
  }

  /**
   * FoodieReview updateManyAndReturn
   */
  export type FoodieReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * The data used to update FoodieReviews.
     */
    data: XOR<FoodieReviewUpdateManyMutationInput, FoodieReviewUncheckedUpdateManyInput>
    /**
     * Filter which FoodieReviews to update
     */
    where?: FoodieReviewWhereInput
    /**
     * Limit how many FoodieReviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieReview upsert
   */
  export type FoodieReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodieReview to update in case it exists.
     */
    where: FoodieReviewWhereUniqueInput
    /**
     * In case the FoodieReview found by the `where` argument doesn't exist, create a new FoodieReview with this data.
     */
    create: XOR<FoodieReviewCreateInput, FoodieReviewUncheckedCreateInput>
    /**
     * In case the FoodieReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodieReviewUpdateInput, FoodieReviewUncheckedUpdateInput>
  }

  /**
   * FoodieReview delete
   */
  export type FoodieReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
    /**
     * Filter which FoodieReview to delete.
     */
    where: FoodieReviewWhereUniqueInput
  }

  /**
   * FoodieReview deleteMany
   */
  export type FoodieReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieReviews to delete
     */
    where?: FoodieReviewWhereInput
    /**
     * Limit how many FoodieReviews to delete.
     */
    limit?: number
  }

  /**
   * FoodieReview without action
   */
  export type FoodieReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieReview
     */
    select?: FoodieReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieReview
     */
    omit?: FoodieReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieReviewInclude<ExtArgs> | null
  }


  /**
   * Model FoodieLike
   */

  export type AggregateFoodieLike = {
    _count: FoodieLikeCountAggregateOutputType | null
    _min: FoodieLikeMinAggregateOutputType | null
    _max: FoodieLikeMaxAggregateOutputType | null
  }

  export type FoodieLikeMinAggregateOutputType = {
    id: string | null
    foodId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type FoodieLikeMaxAggregateOutputType = {
    id: string | null
    foodId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type FoodieLikeCountAggregateOutputType = {
    id: number
    foodId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type FoodieLikeMinAggregateInputType = {
    id?: true
    foodId?: true
    userId?: true
    createdAt?: true
  }

  export type FoodieLikeMaxAggregateInputType = {
    id?: true
    foodId?: true
    userId?: true
    createdAt?: true
  }

  export type FoodieLikeCountAggregateInputType = {
    id?: true
    foodId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type FoodieLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieLike to aggregate.
     */
    where?: FoodieLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLikes to fetch.
     */
    orderBy?: FoodieLikeOrderByWithRelationInput | FoodieLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodieLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodieLikes
    **/
    _count?: true | FoodieLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodieLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodieLikeMaxAggregateInputType
  }

  export type GetFoodieLikeAggregateType<T extends FoodieLikeAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodieLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodieLike[P]>
      : GetScalarType<T[P], AggregateFoodieLike[P]>
  }




  export type FoodieLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodieLikeWhereInput
    orderBy?: FoodieLikeOrderByWithAggregationInput | FoodieLikeOrderByWithAggregationInput[]
    by: FoodieLikeScalarFieldEnum[] | FoodieLikeScalarFieldEnum
    having?: FoodieLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodieLikeCountAggregateInputType | true
    _min?: FoodieLikeMinAggregateInputType
    _max?: FoodieLikeMaxAggregateInputType
  }

  export type FoodieLikeGroupByOutputType = {
    id: string
    foodId: string
    userId: string
    createdAt: Date
    _count: FoodieLikeCountAggregateOutputType | null
    _min: FoodieLikeMinAggregateOutputType | null
    _max: FoodieLikeMaxAggregateOutputType | null
  }

  type GetFoodieLikeGroupByPayload<T extends FoodieLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodieLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodieLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodieLikeGroupByOutputType[P]>
            : GetScalarType<T[P], FoodieLikeGroupByOutputType[P]>
        }
      >
    >


  export type FoodieLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieLike"]>

  export type FoodieLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieLike"]>

  export type FoodieLikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodId?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodieLike"]>

  export type FoodieLikeSelectScalar = {
    id?: boolean
    foodId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type FoodieLikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "foodId" | "userId" | "createdAt", ExtArgs["result"]["foodieLike"]>
  export type FoodieLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }
  export type FoodieLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }
  export type FoodieLikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFoodieDefaultArgs<ExtArgs>
    food?: boolean | FoodieFoodDefaultArgs<ExtArgs>
  }

  export type $FoodieLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodieLike"
    objects: {
      user: Prisma.$UserFoodiePayload<ExtArgs>
      food: Prisma.$FoodieFoodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      foodId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["foodieLike"]>
    composites: {}
  }

  type FoodieLikeGetPayload<S extends boolean | null | undefined | FoodieLikeDefaultArgs> = $Result.GetResult<Prisma.$FoodieLikePayload, S>

  type FoodieLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodieLikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodieLikeCountAggregateInputType | true
    }

  export interface FoodieLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodieLike'], meta: { name: 'FoodieLike' } }
    /**
     * Find zero or one FoodieLike that matches the filter.
     * @param {FoodieLikeFindUniqueArgs} args - Arguments to find a FoodieLike
     * @example
     * // Get one FoodieLike
     * const foodieLike = await prisma.foodieLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodieLikeFindUniqueArgs>(args: SelectSubset<T, FoodieLikeFindUniqueArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodieLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodieLikeFindUniqueOrThrowArgs} args - Arguments to find a FoodieLike
     * @example
     * // Get one FoodieLike
     * const foodieLike = await prisma.foodieLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodieLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodieLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeFindFirstArgs} args - Arguments to find a FoodieLike
     * @example
     * // Get one FoodieLike
     * const foodieLike = await prisma.foodieLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodieLikeFindFirstArgs>(args?: SelectSubset<T, FoodieLikeFindFirstArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodieLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeFindFirstOrThrowArgs} args - Arguments to find a FoodieLike
     * @example
     * // Get one FoodieLike
     * const foodieLike = await prisma.foodieLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodieLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodieLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodieLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodieLikes
     * const foodieLikes = await prisma.foodieLike.findMany()
     * 
     * // Get first 10 FoodieLikes
     * const foodieLikes = await prisma.foodieLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodieLikeWithIdOnly = await prisma.foodieLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodieLikeFindManyArgs>(args?: SelectSubset<T, FoodieLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodieLike.
     * @param {FoodieLikeCreateArgs} args - Arguments to create a FoodieLike.
     * @example
     * // Create one FoodieLike
     * const FoodieLike = await prisma.foodieLike.create({
     *   data: {
     *     // ... data to create a FoodieLike
     *   }
     * })
     * 
     */
    create<T extends FoodieLikeCreateArgs>(args: SelectSubset<T, FoodieLikeCreateArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodieLikes.
     * @param {FoodieLikeCreateManyArgs} args - Arguments to create many FoodieLikes.
     * @example
     * // Create many FoodieLikes
     * const foodieLike = await prisma.foodieLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodieLikeCreateManyArgs>(args?: SelectSubset<T, FoodieLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodieLikes and returns the data saved in the database.
     * @param {FoodieLikeCreateManyAndReturnArgs} args - Arguments to create many FoodieLikes.
     * @example
     * // Create many FoodieLikes
     * const foodieLike = await prisma.foodieLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodieLikes and only return the `id`
     * const foodieLikeWithIdOnly = await prisma.foodieLike.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodieLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodieLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FoodieLike.
     * @param {FoodieLikeDeleteArgs} args - Arguments to delete one FoodieLike.
     * @example
     * // Delete one FoodieLike
     * const FoodieLike = await prisma.foodieLike.delete({
     *   where: {
     *     // ... filter to delete one FoodieLike
     *   }
     * })
     * 
     */
    delete<T extends FoodieLikeDeleteArgs>(args: SelectSubset<T, FoodieLikeDeleteArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodieLike.
     * @param {FoodieLikeUpdateArgs} args - Arguments to update one FoodieLike.
     * @example
     * // Update one FoodieLike
     * const foodieLike = await prisma.foodieLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodieLikeUpdateArgs>(args: SelectSubset<T, FoodieLikeUpdateArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodieLikes.
     * @param {FoodieLikeDeleteManyArgs} args - Arguments to filter FoodieLikes to delete.
     * @example
     * // Delete a few FoodieLikes
     * const { count } = await prisma.foodieLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodieLikeDeleteManyArgs>(args?: SelectSubset<T, FoodieLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodieLikes
     * const foodieLike = await prisma.foodieLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodieLikeUpdateManyArgs>(args: SelectSubset<T, FoodieLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodieLikes and returns the data updated in the database.
     * @param {FoodieLikeUpdateManyAndReturnArgs} args - Arguments to update many FoodieLikes.
     * @example
     * // Update many FoodieLikes
     * const foodieLike = await prisma.foodieLike.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FoodieLikes and only return the `id`
     * const foodieLikeWithIdOnly = await prisma.foodieLike.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FoodieLikeUpdateManyAndReturnArgs>(args: SelectSubset<T, FoodieLikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FoodieLike.
     * @param {FoodieLikeUpsertArgs} args - Arguments to update or create a FoodieLike.
     * @example
     * // Update or create a FoodieLike
     * const foodieLike = await prisma.foodieLike.upsert({
     *   create: {
     *     // ... data to create a FoodieLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodieLike we want to update
     *   }
     * })
     */
    upsert<T extends FoodieLikeUpsertArgs>(args: SelectSubset<T, FoodieLikeUpsertArgs<ExtArgs>>): Prisma__FoodieLikeClient<$Result.GetResult<Prisma.$FoodieLikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodieLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeCountArgs} args - Arguments to filter FoodieLikes to count.
     * @example
     * // Count the number of FoodieLikes
     * const count = await prisma.foodieLike.count({
     *   where: {
     *     // ... the filter for the FoodieLikes we want to count
     *   }
     * })
    **/
    count<T extends FoodieLikeCountArgs>(
      args?: Subset<T, FoodieLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodieLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodieLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodieLikeAggregateArgs>(args: Subset<T, FoodieLikeAggregateArgs>): Prisma.PrismaPromise<GetFoodieLikeAggregateType<T>>

    /**
     * Group by FoodieLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodieLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodieLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodieLikeGroupByArgs['orderBy'] }
        : { orderBy?: FoodieLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodieLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodieLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodieLike model
   */
  readonly fields: FoodieLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodieLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodieLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFoodieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFoodieDefaultArgs<ExtArgs>>): Prisma__UserFoodieClient<$Result.GetResult<Prisma.$UserFoodiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    food<T extends FoodieFoodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodieFoodDefaultArgs<ExtArgs>>): Prisma__FoodieFoodClient<$Result.GetResult<Prisma.$FoodieFoodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodieLike model
   */ 
  interface FoodieLikeFieldRefs {
    readonly id: FieldRef<"FoodieLike", 'String'>
    readonly foodId: FieldRef<"FoodieLike", 'String'>
    readonly userId: FieldRef<"FoodieLike", 'String'>
    readonly createdAt: FieldRef<"FoodieLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodieLike findUnique
   */
  export type FoodieLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLike to fetch.
     */
    where: FoodieLikeWhereUniqueInput
  }

  /**
   * FoodieLike findUniqueOrThrow
   */
  export type FoodieLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLike to fetch.
     */
    where: FoodieLikeWhereUniqueInput
  }

  /**
   * FoodieLike findFirst
   */
  export type FoodieLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLike to fetch.
     */
    where?: FoodieLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLikes to fetch.
     */
    orderBy?: FoodieLikeOrderByWithRelationInput | FoodieLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieLikes.
     */
    cursor?: FoodieLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieLikes.
     */
    distinct?: FoodieLikeScalarFieldEnum | FoodieLikeScalarFieldEnum[]
  }

  /**
   * FoodieLike findFirstOrThrow
   */
  export type FoodieLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLike to fetch.
     */
    where?: FoodieLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLikes to fetch.
     */
    orderBy?: FoodieLikeOrderByWithRelationInput | FoodieLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodieLikes.
     */
    cursor?: FoodieLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodieLikes.
     */
    distinct?: FoodieLikeScalarFieldEnum | FoodieLikeScalarFieldEnum[]
  }

  /**
   * FoodieLike findMany
   */
  export type FoodieLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * Filter, which FoodieLikes to fetch.
     */
    where?: FoodieLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodieLikes to fetch.
     */
    orderBy?: FoodieLikeOrderByWithRelationInput | FoodieLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodieLikes.
     */
    cursor?: FoodieLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodieLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodieLikes.
     */
    skip?: number
    distinct?: FoodieLikeScalarFieldEnum | FoodieLikeScalarFieldEnum[]
  }

  /**
   * FoodieLike create
   */
  export type FoodieLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodieLike.
     */
    data: XOR<FoodieLikeCreateInput, FoodieLikeUncheckedCreateInput>
  }

  /**
   * FoodieLike createMany
   */
  export type FoodieLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodieLikes.
     */
    data: FoodieLikeCreateManyInput | FoodieLikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodieLike createManyAndReturn
   */
  export type FoodieLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * The data used to create many FoodieLikes.
     */
    data: FoodieLikeCreateManyInput | FoodieLikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieLike update
   */
  export type FoodieLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodieLike.
     */
    data: XOR<FoodieLikeUpdateInput, FoodieLikeUncheckedUpdateInput>
    /**
     * Choose, which FoodieLike to update.
     */
    where: FoodieLikeWhereUniqueInput
  }

  /**
   * FoodieLike updateMany
   */
  export type FoodieLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodieLikes.
     */
    data: XOR<FoodieLikeUpdateManyMutationInput, FoodieLikeUncheckedUpdateManyInput>
    /**
     * Filter which FoodieLikes to update
     */
    where?: FoodieLikeWhereInput
    /**
     * Limit how many FoodieLikes to update.
     */
    limit?: number
  }

  /**
   * FoodieLike updateManyAndReturn
   */
  export type FoodieLikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * The data used to update FoodieLikes.
     */
    data: XOR<FoodieLikeUpdateManyMutationInput, FoodieLikeUncheckedUpdateManyInput>
    /**
     * Filter which FoodieLikes to update
     */
    where?: FoodieLikeWhereInput
    /**
     * Limit how many FoodieLikes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodieLike upsert
   */
  export type FoodieLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodieLike to update in case it exists.
     */
    where: FoodieLikeWhereUniqueInput
    /**
     * In case the FoodieLike found by the `where` argument doesn't exist, create a new FoodieLike with this data.
     */
    create: XOR<FoodieLikeCreateInput, FoodieLikeUncheckedCreateInput>
    /**
     * In case the FoodieLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodieLikeUpdateInput, FoodieLikeUncheckedUpdateInput>
  }

  /**
   * FoodieLike delete
   */
  export type FoodieLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
    /**
     * Filter which FoodieLike to delete.
     */
    where: FoodieLikeWhereUniqueInput
  }

  /**
   * FoodieLike deleteMany
   */
  export type FoodieLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodieLikes to delete
     */
    where?: FoodieLikeWhereInput
    /**
     * Limit how many FoodieLikes to delete.
     */
    limit?: number
  }

  /**
   * FoodieLike without action
   */
  export type FoodieLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodieLike
     */
    select?: FoodieLikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodieLike
     */
    omit?: FoodieLikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodieLikeInclude<ExtArgs> | null
  }


  /**
   * Model UserPetLover
   */

  export type AggregateUserPetLover = {
    _count: UserPetLoverCountAggregateOutputType | null
    _min: UserPetLoverMinAggregateOutputType | null
    _max: UserPetLoverMaxAggregateOutputType | null
  }

  export type UserPetLoverMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserPetLoverMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserPetLoverCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserPetLoverMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserPetLoverMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserPetLoverCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserPetLoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPetLover to aggregate.
     */
    where?: UserPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPetLovers to fetch.
     */
    orderBy?: UserPetLoverOrderByWithRelationInput | UserPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPetLovers
    **/
    _count?: true | UserPetLoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPetLoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPetLoverMaxAggregateInputType
  }

  export type GetUserPetLoverAggregateType<T extends UserPetLoverAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPetLover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPetLover[P]>
      : GetScalarType<T[P], AggregateUserPetLover[P]>
  }




  export type UserPetLoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPetLoverWhereInput
    orderBy?: UserPetLoverOrderByWithAggregationInput | UserPetLoverOrderByWithAggregationInput[]
    by: UserPetLoverScalarFieldEnum[] | UserPetLoverScalarFieldEnum
    having?: UserPetLoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPetLoverCountAggregateInputType | true
    _min?: UserPetLoverMinAggregateInputType
    _max?: UserPetLoverMaxAggregateInputType
  }

  export type UserPetLoverGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserPetLoverCountAggregateOutputType | null
    _min: UserPetLoverMinAggregateOutputType | null
    _max: UserPetLoverMaxAggregateOutputType | null
  }

  type GetUserPetLoverGroupByPayload<T extends UserPetLoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPetLoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPetLoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPetLoverGroupByOutputType[P]>
            : GetScalarType<T[P], UserPetLoverGroupByOutputType[P]>
        }
      >
    >


  export type UserPetLoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    PetPetLover?: boolean | UserPetLover$PetPetLoverArgs<ExtArgs>
    AppointmentPetLover?: boolean | UserPetLover$AppointmentPetLoverArgs<ExtArgs>
    _count?: boolean | UserPetLoverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPetLover"]>

  export type UserPetLoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userPetLover"]>

  export type UserPetLoverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userPetLover"]>

  export type UserPetLoverSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserPetLoverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userPetLover"]>
  export type UserPetLoverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PetPetLover?: boolean | UserPetLover$PetPetLoverArgs<ExtArgs>
    AppointmentPetLover?: boolean | UserPetLover$AppointmentPetLoverArgs<ExtArgs>
    _count?: boolean | UserPetLoverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserPetLoverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserPetLoverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPetLoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPetLover"
    objects: {
      PetPetLover: Prisma.$PetPetLoverPayload<ExtArgs>[]
      AppointmentPetLover: Prisma.$AppointmentPetLoverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userPetLover"]>
    composites: {}
  }

  type UserPetLoverGetPayload<S extends boolean | null | undefined | UserPetLoverDefaultArgs> = $Result.GetResult<Prisma.$UserPetLoverPayload, S>

  type UserPetLoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPetLoverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPetLoverCountAggregateInputType | true
    }

  export interface UserPetLoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPetLover'], meta: { name: 'UserPetLover' } }
    /**
     * Find zero or one UserPetLover that matches the filter.
     * @param {UserPetLoverFindUniqueArgs} args - Arguments to find a UserPetLover
     * @example
     * // Get one UserPetLover
     * const userPetLover = await prisma.userPetLover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPetLoverFindUniqueArgs>(args: SelectSubset<T, UserPetLoverFindUniqueArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPetLover that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPetLoverFindUniqueOrThrowArgs} args - Arguments to find a UserPetLover
     * @example
     * // Get one UserPetLover
     * const userPetLover = await prisma.userPetLover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPetLoverFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPetLoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPetLover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverFindFirstArgs} args - Arguments to find a UserPetLover
     * @example
     * // Get one UserPetLover
     * const userPetLover = await prisma.userPetLover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPetLoverFindFirstArgs>(args?: SelectSubset<T, UserPetLoverFindFirstArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPetLover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverFindFirstOrThrowArgs} args - Arguments to find a UserPetLover
     * @example
     * // Get one UserPetLover
     * const userPetLover = await prisma.userPetLover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPetLoverFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPetLoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPetLovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPetLovers
     * const userPetLovers = await prisma.userPetLover.findMany()
     * 
     * // Get first 10 UserPetLovers
     * const userPetLovers = await prisma.userPetLover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPetLoverWithIdOnly = await prisma.userPetLover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPetLoverFindManyArgs>(args?: SelectSubset<T, UserPetLoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPetLover.
     * @param {UserPetLoverCreateArgs} args - Arguments to create a UserPetLover.
     * @example
     * // Create one UserPetLover
     * const UserPetLover = await prisma.userPetLover.create({
     *   data: {
     *     // ... data to create a UserPetLover
     *   }
     * })
     * 
     */
    create<T extends UserPetLoverCreateArgs>(args: SelectSubset<T, UserPetLoverCreateArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPetLovers.
     * @param {UserPetLoverCreateManyArgs} args - Arguments to create many UserPetLovers.
     * @example
     * // Create many UserPetLovers
     * const userPetLover = await prisma.userPetLover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPetLoverCreateManyArgs>(args?: SelectSubset<T, UserPetLoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPetLovers and returns the data saved in the database.
     * @param {UserPetLoverCreateManyAndReturnArgs} args - Arguments to create many UserPetLovers.
     * @example
     * // Create many UserPetLovers
     * const userPetLover = await prisma.userPetLover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPetLovers and only return the `id`
     * const userPetLoverWithIdOnly = await prisma.userPetLover.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPetLoverCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPetLoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPetLover.
     * @param {UserPetLoverDeleteArgs} args - Arguments to delete one UserPetLover.
     * @example
     * // Delete one UserPetLover
     * const UserPetLover = await prisma.userPetLover.delete({
     *   where: {
     *     // ... filter to delete one UserPetLover
     *   }
     * })
     * 
     */
    delete<T extends UserPetLoverDeleteArgs>(args: SelectSubset<T, UserPetLoverDeleteArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPetLover.
     * @param {UserPetLoverUpdateArgs} args - Arguments to update one UserPetLover.
     * @example
     * // Update one UserPetLover
     * const userPetLover = await prisma.userPetLover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPetLoverUpdateArgs>(args: SelectSubset<T, UserPetLoverUpdateArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPetLovers.
     * @param {UserPetLoverDeleteManyArgs} args - Arguments to filter UserPetLovers to delete.
     * @example
     * // Delete a few UserPetLovers
     * const { count } = await prisma.userPetLover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPetLoverDeleteManyArgs>(args?: SelectSubset<T, UserPetLoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPetLovers
     * const userPetLover = await prisma.userPetLover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPetLoverUpdateManyArgs>(args: SelectSubset<T, UserPetLoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPetLovers and returns the data updated in the database.
     * @param {UserPetLoverUpdateManyAndReturnArgs} args - Arguments to update many UserPetLovers.
     * @example
     * // Update many UserPetLovers
     * const userPetLover = await prisma.userPetLover.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPetLovers and only return the `id`
     * const userPetLoverWithIdOnly = await prisma.userPetLover.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPetLoverUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPetLoverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPetLover.
     * @param {UserPetLoverUpsertArgs} args - Arguments to update or create a UserPetLover.
     * @example
     * // Update or create a UserPetLover
     * const userPetLover = await prisma.userPetLover.upsert({
     *   create: {
     *     // ... data to create a UserPetLover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPetLover we want to update
     *   }
     * })
     */
    upsert<T extends UserPetLoverUpsertArgs>(args: SelectSubset<T, UserPetLoverUpsertArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverCountArgs} args - Arguments to filter UserPetLovers to count.
     * @example
     * // Count the number of UserPetLovers
     * const count = await prisma.userPetLover.count({
     *   where: {
     *     // ... the filter for the UserPetLovers we want to count
     *   }
     * })
    **/
    count<T extends UserPetLoverCountArgs>(
      args?: Subset<T, UserPetLoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPetLoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPetLoverAggregateArgs>(args: Subset<T, UserPetLoverAggregateArgs>): Prisma.PrismaPromise<GetUserPetLoverAggregateType<T>>

    /**
     * Group by UserPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetLoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPetLoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPetLoverGroupByArgs['orderBy'] }
        : { orderBy?: UserPetLoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPetLoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPetLoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPetLover model
   */
  readonly fields: UserPetLoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPetLover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPetLoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PetPetLover<T extends UserPetLover$PetPetLoverArgs<ExtArgs> = {}>(args?: Subset<T, UserPetLover$PetPetLoverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AppointmentPetLover<T extends UserPetLover$AppointmentPetLoverArgs<ExtArgs> = {}>(args?: Subset<T, UserPetLover$AppointmentPetLoverArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPetLover model
   */ 
  interface UserPetLoverFieldRefs {
    readonly id: FieldRef<"UserPetLover", 'String'>
    readonly email: FieldRef<"UserPetLover", 'String'>
    readonly name: FieldRef<"UserPetLover", 'String'>
    readonly password: FieldRef<"UserPetLover", 'String'>
    readonly createdAt: FieldRef<"UserPetLover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPetLover findUnique
   */
  export type UserPetLoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which UserPetLover to fetch.
     */
    where: UserPetLoverWhereUniqueInput
  }

  /**
   * UserPetLover findUniqueOrThrow
   */
  export type UserPetLoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which UserPetLover to fetch.
     */
    where: UserPetLoverWhereUniqueInput
  }

  /**
   * UserPetLover findFirst
   */
  export type UserPetLoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which UserPetLover to fetch.
     */
    where?: UserPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPetLovers to fetch.
     */
    orderBy?: UserPetLoverOrderByWithRelationInput | UserPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPetLovers.
     */
    cursor?: UserPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPetLovers.
     */
    distinct?: UserPetLoverScalarFieldEnum | UserPetLoverScalarFieldEnum[]
  }

  /**
   * UserPetLover findFirstOrThrow
   */
  export type UserPetLoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which UserPetLover to fetch.
     */
    where?: UserPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPetLovers to fetch.
     */
    orderBy?: UserPetLoverOrderByWithRelationInput | UserPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPetLovers.
     */
    cursor?: UserPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPetLovers.
     */
    distinct?: UserPetLoverScalarFieldEnum | UserPetLoverScalarFieldEnum[]
  }

  /**
   * UserPetLover findMany
   */
  export type UserPetLoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which UserPetLovers to fetch.
     */
    where?: UserPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPetLovers to fetch.
     */
    orderBy?: UserPetLoverOrderByWithRelationInput | UserPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPetLovers.
     */
    cursor?: UserPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPetLovers.
     */
    skip?: number
    distinct?: UserPetLoverScalarFieldEnum | UserPetLoverScalarFieldEnum[]
  }

  /**
   * UserPetLover create
   */
  export type UserPetLoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPetLover.
     */
    data: XOR<UserPetLoverCreateInput, UserPetLoverUncheckedCreateInput>
  }

  /**
   * UserPetLover createMany
   */
  export type UserPetLoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPetLovers.
     */
    data: UserPetLoverCreateManyInput | UserPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPetLover createManyAndReturn
   */
  export type UserPetLoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * The data used to create many UserPetLovers.
     */
    data: UserPetLoverCreateManyInput | UserPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPetLover update
   */
  export type UserPetLoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPetLover.
     */
    data: XOR<UserPetLoverUpdateInput, UserPetLoverUncheckedUpdateInput>
    /**
     * Choose, which UserPetLover to update.
     */
    where: UserPetLoverWhereUniqueInput
  }

  /**
   * UserPetLover updateMany
   */
  export type UserPetLoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPetLovers.
     */
    data: XOR<UserPetLoverUpdateManyMutationInput, UserPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which UserPetLovers to update
     */
    where?: UserPetLoverWhereInput
    /**
     * Limit how many UserPetLovers to update.
     */
    limit?: number
  }

  /**
   * UserPetLover updateManyAndReturn
   */
  export type UserPetLoverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * The data used to update UserPetLovers.
     */
    data: XOR<UserPetLoverUpdateManyMutationInput, UserPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which UserPetLovers to update
     */
    where?: UserPetLoverWhereInput
    /**
     * Limit how many UserPetLovers to update.
     */
    limit?: number
  }

  /**
   * UserPetLover upsert
   */
  export type UserPetLoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPetLover to update in case it exists.
     */
    where: UserPetLoverWhereUniqueInput
    /**
     * In case the UserPetLover found by the `where` argument doesn't exist, create a new UserPetLover with this data.
     */
    create: XOR<UserPetLoverCreateInput, UserPetLoverUncheckedCreateInput>
    /**
     * In case the UserPetLover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPetLoverUpdateInput, UserPetLoverUncheckedUpdateInput>
  }

  /**
   * UserPetLover delete
   */
  export type UserPetLoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
    /**
     * Filter which UserPetLover to delete.
     */
    where: UserPetLoverWhereUniqueInput
  }

  /**
   * UserPetLover deleteMany
   */
  export type UserPetLoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPetLovers to delete
     */
    where?: UserPetLoverWhereInput
    /**
     * Limit how many UserPetLovers to delete.
     */
    limit?: number
  }

  /**
   * UserPetLover.PetPetLover
   */
  export type UserPetLover$PetPetLoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    where?: PetPetLoverWhereInput
    orderBy?: PetPetLoverOrderByWithRelationInput | PetPetLoverOrderByWithRelationInput[]
    cursor?: PetPetLoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PetPetLoverScalarFieldEnum | PetPetLoverScalarFieldEnum[]
  }

  /**
   * UserPetLover.AppointmentPetLover
   */
  export type UserPetLover$AppointmentPetLoverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    where?: AppointmentPetLoverWhereInput
    orderBy?: AppointmentPetLoverOrderByWithRelationInput | AppointmentPetLoverOrderByWithRelationInput[]
    cursor?: AppointmentPetLoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentPetLoverScalarFieldEnum | AppointmentPetLoverScalarFieldEnum[]
  }

  /**
   * UserPetLover without action
   */
  export type UserPetLoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPetLover
     */
    select?: UserPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPetLover
     */
    omit?: UserPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPetLoverInclude<ExtArgs> | null
  }


  /**
   * Model PetPetLover
   */

  export type AggregatePetPetLover = {
    _count: PetPetLoverCountAggregateOutputType | null
    _avg: PetPetLoverAvgAggregateOutputType | null
    _sum: PetPetLoverSumAggregateOutputType | null
    _min: PetPetLoverMinAggregateOutputType | null
    _max: PetPetLoverMaxAggregateOutputType | null
  }

  export type PetPetLoverAvgAggregateOutputType = {
    age: number | null
  }

  export type PetPetLoverSumAggregateOutputType = {
    age: number | null
  }

  export type PetPetLoverMinAggregateOutputType = {
    id: string | null
    userId: string | null
    petName: string | null
    species: string | null
    breed: string | null
    age: number | null
    medicalHistory: string | null
    createdAt: Date | null
  }

  export type PetPetLoverMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    petName: string | null
    species: string | null
    breed: string | null
    age: number | null
    medicalHistory: string | null
    createdAt: Date | null
  }

  export type PetPetLoverCountAggregateOutputType = {
    id: number
    userId: number
    petName: number
    species: number
    breed: number
    age: number
    medicalHistory: number
    createdAt: number
    _all: number
  }


  export type PetPetLoverAvgAggregateInputType = {
    age?: true
  }

  export type PetPetLoverSumAggregateInputType = {
    age?: true
  }

  export type PetPetLoverMinAggregateInputType = {
    id?: true
    userId?: true
    petName?: true
    species?: true
    breed?: true
    age?: true
    medicalHistory?: true
    createdAt?: true
  }

  export type PetPetLoverMaxAggregateInputType = {
    id?: true
    userId?: true
    petName?: true
    species?: true
    breed?: true
    age?: true
    medicalHistory?: true
    createdAt?: true
  }

  export type PetPetLoverCountAggregateInputType = {
    id?: true
    userId?: true
    petName?: true
    species?: true
    breed?: true
    age?: true
    medicalHistory?: true
    createdAt?: true
    _all?: true
  }

  export type PetPetLoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetPetLover to aggregate.
     */
    where?: PetPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetPetLovers to fetch.
     */
    orderBy?: PetPetLoverOrderByWithRelationInput | PetPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PetPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PetPetLovers
    **/
    _count?: true | PetPetLoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetPetLoverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetPetLoverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetPetLoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetPetLoverMaxAggregateInputType
  }

  export type GetPetPetLoverAggregateType<T extends PetPetLoverAggregateArgs> = {
        [P in keyof T & keyof AggregatePetPetLover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePetPetLover[P]>
      : GetScalarType<T[P], AggregatePetPetLover[P]>
  }




  export type PetPetLoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PetPetLoverWhereInput
    orderBy?: PetPetLoverOrderByWithAggregationInput | PetPetLoverOrderByWithAggregationInput[]
    by: PetPetLoverScalarFieldEnum[] | PetPetLoverScalarFieldEnum
    having?: PetPetLoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetPetLoverCountAggregateInputType | true
    _avg?: PetPetLoverAvgAggregateInputType
    _sum?: PetPetLoverSumAggregateInputType
    _min?: PetPetLoverMinAggregateInputType
    _max?: PetPetLoverMaxAggregateInputType
  }

  export type PetPetLoverGroupByOutputType = {
    id: string
    userId: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory: string | null
    createdAt: Date
    _count: PetPetLoverCountAggregateOutputType | null
    _avg: PetPetLoverAvgAggregateOutputType | null
    _sum: PetPetLoverSumAggregateOutputType | null
    _min: PetPetLoverMinAggregateOutputType | null
    _max: PetPetLoverMaxAggregateOutputType | null
  }

  type GetPetPetLoverGroupByPayload<T extends PetPetLoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PetPetLoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetPetLoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetPetLoverGroupByOutputType[P]>
            : GetScalarType<T[P], PetPetLoverGroupByOutputType[P]>
        }
      >
    >


  export type PetPetLoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petName?: boolean
    species?: boolean
    breed?: boolean
    age?: boolean
    medicalHistory?: boolean
    createdAt?: boolean
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    vaccinations?: boolean | PetPetLover$vaccinationsArgs<ExtArgs>
    appointments?: boolean | PetPetLover$appointmentsArgs<ExtArgs>
    _count?: boolean | PetPetLoverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petPetLover"]>

  export type PetPetLoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petName?: boolean
    species?: boolean
    breed?: boolean
    age?: boolean
    medicalHistory?: boolean
    createdAt?: boolean
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petPetLover"]>

  export type PetPetLoverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petName?: boolean
    species?: boolean
    breed?: boolean
    age?: boolean
    medicalHistory?: boolean
    createdAt?: boolean
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["petPetLover"]>

  export type PetPetLoverSelectScalar = {
    id?: boolean
    userId?: boolean
    petName?: boolean
    species?: boolean
    breed?: boolean
    age?: boolean
    medicalHistory?: boolean
    createdAt?: boolean
  }

  export type PetPetLoverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "petName" | "species" | "breed" | "age" | "medicalHistory" | "createdAt", ExtArgs["result"]["petPetLover"]>
  export type PetPetLoverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    vaccinations?: boolean | PetPetLover$vaccinationsArgs<ExtArgs>
    appointments?: boolean | PetPetLover$appointmentsArgs<ExtArgs>
    _count?: boolean | PetPetLoverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PetPetLoverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
  }
  export type PetPetLoverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
  }

  export type $PetPetLoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PetPetLover"
    objects: {
      user: Prisma.$UserPetLoverPayload<ExtArgs>
      vaccinations: Prisma.$VaccinationPetLoverPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPetLoverPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      petName: string
      species: string
      breed: string
      age: number
      medicalHistory: string | null
      createdAt: Date
    }, ExtArgs["result"]["petPetLover"]>
    composites: {}
  }

  type PetPetLoverGetPayload<S extends boolean | null | undefined | PetPetLoverDefaultArgs> = $Result.GetResult<Prisma.$PetPetLoverPayload, S>

  type PetPetLoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PetPetLoverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PetPetLoverCountAggregateInputType | true
    }

  export interface PetPetLoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PetPetLover'], meta: { name: 'PetPetLover' } }
    /**
     * Find zero or one PetPetLover that matches the filter.
     * @param {PetPetLoverFindUniqueArgs} args - Arguments to find a PetPetLover
     * @example
     * // Get one PetPetLover
     * const petPetLover = await prisma.petPetLover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PetPetLoverFindUniqueArgs>(args: SelectSubset<T, PetPetLoverFindUniqueArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PetPetLover that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PetPetLoverFindUniqueOrThrowArgs} args - Arguments to find a PetPetLover
     * @example
     * // Get one PetPetLover
     * const petPetLover = await prisma.petPetLover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PetPetLoverFindUniqueOrThrowArgs>(args: SelectSubset<T, PetPetLoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetPetLover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverFindFirstArgs} args - Arguments to find a PetPetLover
     * @example
     * // Get one PetPetLover
     * const petPetLover = await prisma.petPetLover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PetPetLoverFindFirstArgs>(args?: SelectSubset<T, PetPetLoverFindFirstArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PetPetLover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverFindFirstOrThrowArgs} args - Arguments to find a PetPetLover
     * @example
     * // Get one PetPetLover
     * const petPetLover = await prisma.petPetLover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PetPetLoverFindFirstOrThrowArgs>(args?: SelectSubset<T, PetPetLoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PetPetLovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PetPetLovers
     * const petPetLovers = await prisma.petPetLover.findMany()
     * 
     * // Get first 10 PetPetLovers
     * const petPetLovers = await prisma.petPetLover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petPetLoverWithIdOnly = await prisma.petPetLover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PetPetLoverFindManyArgs>(args?: SelectSubset<T, PetPetLoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PetPetLover.
     * @param {PetPetLoverCreateArgs} args - Arguments to create a PetPetLover.
     * @example
     * // Create one PetPetLover
     * const PetPetLover = await prisma.petPetLover.create({
     *   data: {
     *     // ... data to create a PetPetLover
     *   }
     * })
     * 
     */
    create<T extends PetPetLoverCreateArgs>(args: SelectSubset<T, PetPetLoverCreateArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PetPetLovers.
     * @param {PetPetLoverCreateManyArgs} args - Arguments to create many PetPetLovers.
     * @example
     * // Create many PetPetLovers
     * const petPetLover = await prisma.petPetLover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PetPetLoverCreateManyArgs>(args?: SelectSubset<T, PetPetLoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PetPetLovers and returns the data saved in the database.
     * @param {PetPetLoverCreateManyAndReturnArgs} args - Arguments to create many PetPetLovers.
     * @example
     * // Create many PetPetLovers
     * const petPetLover = await prisma.petPetLover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PetPetLovers and only return the `id`
     * const petPetLoverWithIdOnly = await prisma.petPetLover.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PetPetLoverCreateManyAndReturnArgs>(args?: SelectSubset<T, PetPetLoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PetPetLover.
     * @param {PetPetLoverDeleteArgs} args - Arguments to delete one PetPetLover.
     * @example
     * // Delete one PetPetLover
     * const PetPetLover = await prisma.petPetLover.delete({
     *   where: {
     *     // ... filter to delete one PetPetLover
     *   }
     * })
     * 
     */
    delete<T extends PetPetLoverDeleteArgs>(args: SelectSubset<T, PetPetLoverDeleteArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PetPetLover.
     * @param {PetPetLoverUpdateArgs} args - Arguments to update one PetPetLover.
     * @example
     * // Update one PetPetLover
     * const petPetLover = await prisma.petPetLover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PetPetLoverUpdateArgs>(args: SelectSubset<T, PetPetLoverUpdateArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PetPetLovers.
     * @param {PetPetLoverDeleteManyArgs} args - Arguments to filter PetPetLovers to delete.
     * @example
     * // Delete a few PetPetLovers
     * const { count } = await prisma.petPetLover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PetPetLoverDeleteManyArgs>(args?: SelectSubset<T, PetPetLoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PetPetLovers
     * const petPetLover = await prisma.petPetLover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PetPetLoverUpdateManyArgs>(args: SelectSubset<T, PetPetLoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PetPetLovers and returns the data updated in the database.
     * @param {PetPetLoverUpdateManyAndReturnArgs} args - Arguments to update many PetPetLovers.
     * @example
     * // Update many PetPetLovers
     * const petPetLover = await prisma.petPetLover.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PetPetLovers and only return the `id`
     * const petPetLoverWithIdOnly = await prisma.petPetLover.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PetPetLoverUpdateManyAndReturnArgs>(args: SelectSubset<T, PetPetLoverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PetPetLover.
     * @param {PetPetLoverUpsertArgs} args - Arguments to update or create a PetPetLover.
     * @example
     * // Update or create a PetPetLover
     * const petPetLover = await prisma.petPetLover.upsert({
     *   create: {
     *     // ... data to create a PetPetLover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PetPetLover we want to update
     *   }
     * })
     */
    upsert<T extends PetPetLoverUpsertArgs>(args: SelectSubset<T, PetPetLoverUpsertArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PetPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverCountArgs} args - Arguments to filter PetPetLovers to count.
     * @example
     * // Count the number of PetPetLovers
     * const count = await prisma.petPetLover.count({
     *   where: {
     *     // ... the filter for the PetPetLovers we want to count
     *   }
     * })
    **/
    count<T extends PetPetLoverCountArgs>(
      args?: Subset<T, PetPetLoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetPetLoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PetPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetPetLoverAggregateArgs>(args: Subset<T, PetPetLoverAggregateArgs>): Prisma.PrismaPromise<GetPetPetLoverAggregateType<T>>

    /**
     * Group by PetPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetPetLoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetPetLoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetPetLoverGroupByArgs['orderBy'] }
        : { orderBy?: PetPetLoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetPetLoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetPetLoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PetPetLover model
   */
  readonly fields: PetPetLoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PetPetLover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PetPetLoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserPetLoverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPetLoverDefaultArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vaccinations<T extends PetPetLover$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, PetPetLover$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends PetPetLover$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, PetPetLover$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PetPetLover model
   */ 
  interface PetPetLoverFieldRefs {
    readonly id: FieldRef<"PetPetLover", 'String'>
    readonly userId: FieldRef<"PetPetLover", 'String'>
    readonly petName: FieldRef<"PetPetLover", 'String'>
    readonly species: FieldRef<"PetPetLover", 'String'>
    readonly breed: FieldRef<"PetPetLover", 'String'>
    readonly age: FieldRef<"PetPetLover", 'Int'>
    readonly medicalHistory: FieldRef<"PetPetLover", 'String'>
    readonly createdAt: FieldRef<"PetPetLover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PetPetLover findUnique
   */
  export type PetPetLoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which PetPetLover to fetch.
     */
    where: PetPetLoverWhereUniqueInput
  }

  /**
   * PetPetLover findUniqueOrThrow
   */
  export type PetPetLoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which PetPetLover to fetch.
     */
    where: PetPetLoverWhereUniqueInput
  }

  /**
   * PetPetLover findFirst
   */
  export type PetPetLoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which PetPetLover to fetch.
     */
    where?: PetPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetPetLovers to fetch.
     */
    orderBy?: PetPetLoverOrderByWithRelationInput | PetPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetPetLovers.
     */
    cursor?: PetPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetPetLovers.
     */
    distinct?: PetPetLoverScalarFieldEnum | PetPetLoverScalarFieldEnum[]
  }

  /**
   * PetPetLover findFirstOrThrow
   */
  export type PetPetLoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which PetPetLover to fetch.
     */
    where?: PetPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetPetLovers to fetch.
     */
    orderBy?: PetPetLoverOrderByWithRelationInput | PetPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PetPetLovers.
     */
    cursor?: PetPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PetPetLovers.
     */
    distinct?: PetPetLoverScalarFieldEnum | PetPetLoverScalarFieldEnum[]
  }

  /**
   * PetPetLover findMany
   */
  export type PetPetLoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which PetPetLovers to fetch.
     */
    where?: PetPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PetPetLovers to fetch.
     */
    orderBy?: PetPetLoverOrderByWithRelationInput | PetPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PetPetLovers.
     */
    cursor?: PetPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PetPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PetPetLovers.
     */
    skip?: number
    distinct?: PetPetLoverScalarFieldEnum | PetPetLoverScalarFieldEnum[]
  }

  /**
   * PetPetLover create
   */
  export type PetPetLoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to create a PetPetLover.
     */
    data: XOR<PetPetLoverCreateInput, PetPetLoverUncheckedCreateInput>
  }

  /**
   * PetPetLover createMany
   */
  export type PetPetLoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PetPetLovers.
     */
    data: PetPetLoverCreateManyInput | PetPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PetPetLover createManyAndReturn
   */
  export type PetPetLoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * The data used to create many PetPetLovers.
     */
    data: PetPetLoverCreateManyInput | PetPetLoverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetPetLover update
   */
  export type PetPetLoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to update a PetPetLover.
     */
    data: XOR<PetPetLoverUpdateInput, PetPetLoverUncheckedUpdateInput>
    /**
     * Choose, which PetPetLover to update.
     */
    where: PetPetLoverWhereUniqueInput
  }

  /**
   * PetPetLover updateMany
   */
  export type PetPetLoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PetPetLovers.
     */
    data: XOR<PetPetLoverUpdateManyMutationInput, PetPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which PetPetLovers to update
     */
    where?: PetPetLoverWhereInput
    /**
     * Limit how many PetPetLovers to update.
     */
    limit?: number
  }

  /**
   * PetPetLover updateManyAndReturn
   */
  export type PetPetLoverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * The data used to update PetPetLovers.
     */
    data: XOR<PetPetLoverUpdateManyMutationInput, PetPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which PetPetLovers to update
     */
    where?: PetPetLoverWhereInput
    /**
     * Limit how many PetPetLovers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PetPetLover upsert
   */
  export type PetPetLoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * The filter to search for the PetPetLover to update in case it exists.
     */
    where: PetPetLoverWhereUniqueInput
    /**
     * In case the PetPetLover found by the `where` argument doesn't exist, create a new PetPetLover with this data.
     */
    create: XOR<PetPetLoverCreateInput, PetPetLoverUncheckedCreateInput>
    /**
     * In case the PetPetLover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PetPetLoverUpdateInput, PetPetLoverUncheckedUpdateInput>
  }

  /**
   * PetPetLover delete
   */
  export type PetPetLoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
    /**
     * Filter which PetPetLover to delete.
     */
    where: PetPetLoverWhereUniqueInput
  }

  /**
   * PetPetLover deleteMany
   */
  export type PetPetLoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PetPetLovers to delete
     */
    where?: PetPetLoverWhereInput
    /**
     * Limit how many PetPetLovers to delete.
     */
    limit?: number
  }

  /**
   * PetPetLover.vaccinations
   */
  export type PetPetLover$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    where?: VaccinationPetLoverWhereInput
    orderBy?: VaccinationPetLoverOrderByWithRelationInput | VaccinationPetLoverOrderByWithRelationInput[]
    cursor?: VaccinationPetLoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationPetLoverScalarFieldEnum | VaccinationPetLoverScalarFieldEnum[]
  }

  /**
   * PetPetLover.appointments
   */
  export type PetPetLover$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    where?: AppointmentPetLoverWhereInput
    orderBy?: AppointmentPetLoverOrderByWithRelationInput | AppointmentPetLoverOrderByWithRelationInput[]
    cursor?: AppointmentPetLoverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentPetLoverScalarFieldEnum | AppointmentPetLoverScalarFieldEnum[]
  }

  /**
   * PetPetLover without action
   */
  export type PetPetLoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PetPetLover
     */
    select?: PetPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PetPetLover
     */
    omit?: PetPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PetPetLoverInclude<ExtArgs> | null
  }


  /**
   * Model AppointmentPetLover
   */

  export type AggregateAppointmentPetLover = {
    _count: AppointmentPetLoverCountAggregateOutputType | null
    _min: AppointmentPetLoverMinAggregateOutputType | null
    _max: AppointmentPetLoverMaxAggregateOutputType | null
  }

  export type AppointmentPetLoverMinAggregateOutputType = {
    id: string | null
    userId: string | null
    petId: string | null
    appointmentType: string | null
    dateTime: Date | null
    location: string | null
    createdAt: Date | null
  }

  export type AppointmentPetLoverMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    petId: string | null
    appointmentType: string | null
    dateTime: Date | null
    location: string | null
    createdAt: Date | null
  }

  export type AppointmentPetLoverCountAggregateOutputType = {
    id: number
    userId: number
    petId: number
    appointmentType: number
    dateTime: number
    location: number
    createdAt: number
    _all: number
  }


  export type AppointmentPetLoverMinAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    appointmentType?: true
    dateTime?: true
    location?: true
    createdAt?: true
  }

  export type AppointmentPetLoverMaxAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    appointmentType?: true
    dateTime?: true
    location?: true
    createdAt?: true
  }

  export type AppointmentPetLoverCountAggregateInputType = {
    id?: true
    userId?: true
    petId?: true
    appointmentType?: true
    dateTime?: true
    location?: true
    createdAt?: true
    _all?: true
  }

  export type AppointmentPetLoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentPetLover to aggregate.
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentPetLovers to fetch.
     */
    orderBy?: AppointmentPetLoverOrderByWithRelationInput | AppointmentPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppointmentPetLovers
    **/
    _count?: true | AppointmentPetLoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentPetLoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentPetLoverMaxAggregateInputType
  }

  export type GetAppointmentPetLoverAggregateType<T extends AppointmentPetLoverAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointmentPetLover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointmentPetLover[P]>
      : GetScalarType<T[P], AggregateAppointmentPetLover[P]>
  }




  export type AppointmentPetLoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentPetLoverWhereInput
    orderBy?: AppointmentPetLoverOrderByWithAggregationInput | AppointmentPetLoverOrderByWithAggregationInput[]
    by: AppointmentPetLoverScalarFieldEnum[] | AppointmentPetLoverScalarFieldEnum
    having?: AppointmentPetLoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentPetLoverCountAggregateInputType | true
    _min?: AppointmentPetLoverMinAggregateInputType
    _max?: AppointmentPetLoverMaxAggregateInputType
  }

  export type AppointmentPetLoverGroupByOutputType = {
    id: string
    userId: string
    petId: string
    appointmentType: string
    dateTime: Date
    location: string
    createdAt: Date
    _count: AppointmentPetLoverCountAggregateOutputType | null
    _min: AppointmentPetLoverMinAggregateOutputType | null
    _max: AppointmentPetLoverMaxAggregateOutputType | null
  }

  type GetAppointmentPetLoverGroupByPayload<T extends AppointmentPetLoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentPetLoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentPetLoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentPetLoverGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentPetLoverGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentPetLoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    appointmentType?: boolean
    dateTime?: boolean
    location?: boolean
    createdAt?: boolean
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentPetLover"]>

  export type AppointmentPetLoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    appointmentType?: boolean
    dateTime?: boolean
    location?: boolean
    createdAt?: boolean
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentPetLover"]>

  export type AppointmentPetLoverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    petId?: boolean
    appointmentType?: boolean
    dateTime?: boolean
    location?: boolean
    createdAt?: boolean
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointmentPetLover"]>

  export type AppointmentPetLoverSelectScalar = {
    id?: boolean
    userId?: boolean
    petId?: boolean
    appointmentType?: boolean
    dateTime?: boolean
    location?: boolean
    createdAt?: boolean
  }

  export type AppointmentPetLoverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "petId" | "appointmentType" | "dateTime" | "location" | "createdAt", ExtArgs["result"]["appointmentPetLover"]>
  export type AppointmentPetLoverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }
  export type AppointmentPetLoverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }
  export type AppointmentPetLoverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserPetLoverDefaultArgs<ExtArgs>
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }

  export type $AppointmentPetLoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppointmentPetLover"
    objects: {
      user: Prisma.$UserPetLoverPayload<ExtArgs>
      pet: Prisma.$PetPetLoverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      petId: string
      appointmentType: string
      dateTime: Date
      location: string
      createdAt: Date
    }, ExtArgs["result"]["appointmentPetLover"]>
    composites: {}
  }

  type AppointmentPetLoverGetPayload<S extends boolean | null | undefined | AppointmentPetLoverDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPetLoverPayload, S>

  type AppointmentPetLoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentPetLoverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentPetLoverCountAggregateInputType | true
    }

  export interface AppointmentPetLoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppointmentPetLover'], meta: { name: 'AppointmentPetLover' } }
    /**
     * Find zero or one AppointmentPetLover that matches the filter.
     * @param {AppointmentPetLoverFindUniqueArgs} args - Arguments to find a AppointmentPetLover
     * @example
     * // Get one AppointmentPetLover
     * const appointmentPetLover = await prisma.appointmentPetLover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentPetLoverFindUniqueArgs>(args: SelectSubset<T, AppointmentPetLoverFindUniqueArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppointmentPetLover that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentPetLoverFindUniqueOrThrowArgs} args - Arguments to find a AppointmentPetLover
     * @example
     * // Get one AppointmentPetLover
     * const appointmentPetLover = await prisma.appointmentPetLover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentPetLoverFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentPetLoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppointmentPetLover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverFindFirstArgs} args - Arguments to find a AppointmentPetLover
     * @example
     * // Get one AppointmentPetLover
     * const appointmentPetLover = await prisma.appointmentPetLover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentPetLoverFindFirstArgs>(args?: SelectSubset<T, AppointmentPetLoverFindFirstArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppointmentPetLover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverFindFirstOrThrowArgs} args - Arguments to find a AppointmentPetLover
     * @example
     * // Get one AppointmentPetLover
     * const appointmentPetLover = await prisma.appointmentPetLover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentPetLoverFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentPetLoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppointmentPetLovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppointmentPetLovers
     * const appointmentPetLovers = await prisma.appointmentPetLover.findMany()
     * 
     * // Get first 10 AppointmentPetLovers
     * const appointmentPetLovers = await prisma.appointmentPetLover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentPetLoverWithIdOnly = await prisma.appointmentPetLover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentPetLoverFindManyArgs>(args?: SelectSubset<T, AppointmentPetLoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppointmentPetLover.
     * @param {AppointmentPetLoverCreateArgs} args - Arguments to create a AppointmentPetLover.
     * @example
     * // Create one AppointmentPetLover
     * const AppointmentPetLover = await prisma.appointmentPetLover.create({
     *   data: {
     *     // ... data to create a AppointmentPetLover
     *   }
     * })
     * 
     */
    create<T extends AppointmentPetLoverCreateArgs>(args: SelectSubset<T, AppointmentPetLoverCreateArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppointmentPetLovers.
     * @param {AppointmentPetLoverCreateManyArgs} args - Arguments to create many AppointmentPetLovers.
     * @example
     * // Create many AppointmentPetLovers
     * const appointmentPetLover = await prisma.appointmentPetLover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentPetLoverCreateManyArgs>(args?: SelectSubset<T, AppointmentPetLoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppointmentPetLovers and returns the data saved in the database.
     * @param {AppointmentPetLoverCreateManyAndReturnArgs} args - Arguments to create many AppointmentPetLovers.
     * @example
     * // Create many AppointmentPetLovers
     * const appointmentPetLover = await prisma.appointmentPetLover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppointmentPetLovers and only return the `id`
     * const appointmentPetLoverWithIdOnly = await prisma.appointmentPetLover.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentPetLoverCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentPetLoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppointmentPetLover.
     * @param {AppointmentPetLoverDeleteArgs} args - Arguments to delete one AppointmentPetLover.
     * @example
     * // Delete one AppointmentPetLover
     * const AppointmentPetLover = await prisma.appointmentPetLover.delete({
     *   where: {
     *     // ... filter to delete one AppointmentPetLover
     *   }
     * })
     * 
     */
    delete<T extends AppointmentPetLoverDeleteArgs>(args: SelectSubset<T, AppointmentPetLoverDeleteArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppointmentPetLover.
     * @param {AppointmentPetLoverUpdateArgs} args - Arguments to update one AppointmentPetLover.
     * @example
     * // Update one AppointmentPetLover
     * const appointmentPetLover = await prisma.appointmentPetLover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentPetLoverUpdateArgs>(args: SelectSubset<T, AppointmentPetLoverUpdateArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppointmentPetLovers.
     * @param {AppointmentPetLoverDeleteManyArgs} args - Arguments to filter AppointmentPetLovers to delete.
     * @example
     * // Delete a few AppointmentPetLovers
     * const { count } = await prisma.appointmentPetLover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentPetLoverDeleteManyArgs>(args?: SelectSubset<T, AppointmentPetLoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppointmentPetLovers
     * const appointmentPetLover = await prisma.appointmentPetLover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentPetLoverUpdateManyArgs>(args: SelectSubset<T, AppointmentPetLoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppointmentPetLovers and returns the data updated in the database.
     * @param {AppointmentPetLoverUpdateManyAndReturnArgs} args - Arguments to update many AppointmentPetLovers.
     * @example
     * // Update many AppointmentPetLovers
     * const appointmentPetLover = await prisma.appointmentPetLover.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppointmentPetLovers and only return the `id`
     * const appointmentPetLoverWithIdOnly = await prisma.appointmentPetLover.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentPetLoverUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentPetLoverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppointmentPetLover.
     * @param {AppointmentPetLoverUpsertArgs} args - Arguments to update or create a AppointmentPetLover.
     * @example
     * // Update or create a AppointmentPetLover
     * const appointmentPetLover = await prisma.appointmentPetLover.upsert({
     *   create: {
     *     // ... data to create a AppointmentPetLover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppointmentPetLover we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentPetLoverUpsertArgs>(args: SelectSubset<T, AppointmentPetLoverUpsertArgs<ExtArgs>>): Prisma__AppointmentPetLoverClient<$Result.GetResult<Prisma.$AppointmentPetLoverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppointmentPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverCountArgs} args - Arguments to filter AppointmentPetLovers to count.
     * @example
     * // Count the number of AppointmentPetLovers
     * const count = await prisma.appointmentPetLover.count({
     *   where: {
     *     // ... the filter for the AppointmentPetLovers we want to count
     *   }
     * })
    **/
    count<T extends AppointmentPetLoverCountArgs>(
      args?: Subset<T, AppointmentPetLoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentPetLoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppointmentPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentPetLoverAggregateArgs>(args: Subset<T, AppointmentPetLoverAggregateArgs>): Prisma.PrismaPromise<GetAppointmentPetLoverAggregateType<T>>

    /**
     * Group by AppointmentPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentPetLoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentPetLoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentPetLoverGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentPetLoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentPetLoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentPetLoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppointmentPetLover model
   */
  readonly fields: AppointmentPetLoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppointmentPetLover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentPetLoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserPetLoverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPetLoverDefaultArgs<ExtArgs>>): Prisma__UserPetLoverClient<$Result.GetResult<Prisma.$UserPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pet<T extends PetPetLoverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetPetLoverDefaultArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppointmentPetLover model
   */ 
  interface AppointmentPetLoverFieldRefs {
    readonly id: FieldRef<"AppointmentPetLover", 'String'>
    readonly userId: FieldRef<"AppointmentPetLover", 'String'>
    readonly petId: FieldRef<"AppointmentPetLover", 'String'>
    readonly appointmentType: FieldRef<"AppointmentPetLover", 'String'>
    readonly dateTime: FieldRef<"AppointmentPetLover", 'DateTime'>
    readonly location: FieldRef<"AppointmentPetLover", 'String'>
    readonly createdAt: FieldRef<"AppointmentPetLover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppointmentPetLover findUnique
   */
  export type AppointmentPetLoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentPetLover to fetch.
     */
    where: AppointmentPetLoverWhereUniqueInput
  }

  /**
   * AppointmentPetLover findUniqueOrThrow
   */
  export type AppointmentPetLoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentPetLover to fetch.
     */
    where: AppointmentPetLoverWhereUniqueInput
  }

  /**
   * AppointmentPetLover findFirst
   */
  export type AppointmentPetLoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentPetLover to fetch.
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentPetLovers to fetch.
     */
    orderBy?: AppointmentPetLoverOrderByWithRelationInput | AppointmentPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentPetLovers.
     */
    cursor?: AppointmentPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentPetLovers.
     */
    distinct?: AppointmentPetLoverScalarFieldEnum | AppointmentPetLoverScalarFieldEnum[]
  }

  /**
   * AppointmentPetLover findFirstOrThrow
   */
  export type AppointmentPetLoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentPetLover to fetch.
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentPetLovers to fetch.
     */
    orderBy?: AppointmentPetLoverOrderByWithRelationInput | AppointmentPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppointmentPetLovers.
     */
    cursor?: AppointmentPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppointmentPetLovers.
     */
    distinct?: AppointmentPetLoverScalarFieldEnum | AppointmentPetLoverScalarFieldEnum[]
  }

  /**
   * AppointmentPetLover findMany
   */
  export type AppointmentPetLoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which AppointmentPetLovers to fetch.
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppointmentPetLovers to fetch.
     */
    orderBy?: AppointmentPetLoverOrderByWithRelationInput | AppointmentPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppointmentPetLovers.
     */
    cursor?: AppointmentPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppointmentPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppointmentPetLovers.
     */
    skip?: number
    distinct?: AppointmentPetLoverScalarFieldEnum | AppointmentPetLoverScalarFieldEnum[]
  }

  /**
   * AppointmentPetLover create
   */
  export type AppointmentPetLoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to create a AppointmentPetLover.
     */
    data: XOR<AppointmentPetLoverCreateInput, AppointmentPetLoverUncheckedCreateInput>
  }

  /**
   * AppointmentPetLover createMany
   */
  export type AppointmentPetLoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppointmentPetLovers.
     */
    data: AppointmentPetLoverCreateManyInput | AppointmentPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppointmentPetLover createManyAndReturn
   */
  export type AppointmentPetLoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * The data used to create many AppointmentPetLovers.
     */
    data: AppointmentPetLoverCreateManyInput | AppointmentPetLoverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppointmentPetLover update
   */
  export type AppointmentPetLoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to update a AppointmentPetLover.
     */
    data: XOR<AppointmentPetLoverUpdateInput, AppointmentPetLoverUncheckedUpdateInput>
    /**
     * Choose, which AppointmentPetLover to update.
     */
    where: AppointmentPetLoverWhereUniqueInput
  }

  /**
   * AppointmentPetLover updateMany
   */
  export type AppointmentPetLoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppointmentPetLovers.
     */
    data: XOR<AppointmentPetLoverUpdateManyMutationInput, AppointmentPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentPetLovers to update
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * Limit how many AppointmentPetLovers to update.
     */
    limit?: number
  }

  /**
   * AppointmentPetLover updateManyAndReturn
   */
  export type AppointmentPetLoverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * The data used to update AppointmentPetLovers.
     */
    data: XOR<AppointmentPetLoverUpdateManyMutationInput, AppointmentPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which AppointmentPetLovers to update
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * Limit how many AppointmentPetLovers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppointmentPetLover upsert
   */
  export type AppointmentPetLoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * The filter to search for the AppointmentPetLover to update in case it exists.
     */
    where: AppointmentPetLoverWhereUniqueInput
    /**
     * In case the AppointmentPetLover found by the `where` argument doesn't exist, create a new AppointmentPetLover with this data.
     */
    create: XOR<AppointmentPetLoverCreateInput, AppointmentPetLoverUncheckedCreateInput>
    /**
     * In case the AppointmentPetLover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentPetLoverUpdateInput, AppointmentPetLoverUncheckedUpdateInput>
  }

  /**
   * AppointmentPetLover delete
   */
  export type AppointmentPetLoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
    /**
     * Filter which AppointmentPetLover to delete.
     */
    where: AppointmentPetLoverWhereUniqueInput
  }

  /**
   * AppointmentPetLover deleteMany
   */
  export type AppointmentPetLoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppointmentPetLovers to delete
     */
    where?: AppointmentPetLoverWhereInput
    /**
     * Limit how many AppointmentPetLovers to delete.
     */
    limit?: number
  }

  /**
   * AppointmentPetLover without action
   */
  export type AppointmentPetLoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentPetLover
     */
    select?: AppointmentPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppointmentPetLover
     */
    omit?: AppointmentPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentPetLoverInclude<ExtArgs> | null
  }


  /**
   * Model VaccinationPetLover
   */

  export type AggregateVaccinationPetLover = {
    _count: VaccinationPetLoverCountAggregateOutputType | null
    _min: VaccinationPetLoverMinAggregateOutputType | null
    _max: VaccinationPetLoverMaxAggregateOutputType | null
  }

  export type VaccinationPetLoverMinAggregateOutputType = {
    id: string | null
    petId: string | null
    vaccineName: string | null
    dateAdministered: Date | null
    nextDueDate: Date | null
    createdAt: Date | null
  }

  export type VaccinationPetLoverMaxAggregateOutputType = {
    id: string | null
    petId: string | null
    vaccineName: string | null
    dateAdministered: Date | null
    nextDueDate: Date | null
    createdAt: Date | null
  }

  export type VaccinationPetLoverCountAggregateOutputType = {
    id: number
    petId: number
    vaccineName: number
    dateAdministered: number
    nextDueDate: number
    createdAt: number
    _all: number
  }


  export type VaccinationPetLoverMinAggregateInputType = {
    id?: true
    petId?: true
    vaccineName?: true
    dateAdministered?: true
    nextDueDate?: true
    createdAt?: true
  }

  export type VaccinationPetLoverMaxAggregateInputType = {
    id?: true
    petId?: true
    vaccineName?: true
    dateAdministered?: true
    nextDueDate?: true
    createdAt?: true
  }

  export type VaccinationPetLoverCountAggregateInputType = {
    id?: true
    petId?: true
    vaccineName?: true
    dateAdministered?: true
    nextDueDate?: true
    createdAt?: true
    _all?: true
  }

  export type VaccinationPetLoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccinationPetLover to aggregate.
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationPetLovers to fetch.
     */
    orderBy?: VaccinationPetLoverOrderByWithRelationInput | VaccinationPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccinationPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccinationPetLovers
    **/
    _count?: true | VaccinationPetLoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccinationPetLoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccinationPetLoverMaxAggregateInputType
  }

  export type GetVaccinationPetLoverAggregateType<T extends VaccinationPetLoverAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccinationPetLover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccinationPetLover[P]>
      : GetScalarType<T[P], AggregateVaccinationPetLover[P]>
  }




  export type VaccinationPetLoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationPetLoverWhereInput
    orderBy?: VaccinationPetLoverOrderByWithAggregationInput | VaccinationPetLoverOrderByWithAggregationInput[]
    by: VaccinationPetLoverScalarFieldEnum[] | VaccinationPetLoverScalarFieldEnum
    having?: VaccinationPetLoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccinationPetLoverCountAggregateInputType | true
    _min?: VaccinationPetLoverMinAggregateInputType
    _max?: VaccinationPetLoverMaxAggregateInputType
  }

  export type VaccinationPetLoverGroupByOutputType = {
    id: string
    petId: string
    vaccineName: string
    dateAdministered: Date
    nextDueDate: Date | null
    createdAt: Date
    _count: VaccinationPetLoverCountAggregateOutputType | null
    _min: VaccinationPetLoverMinAggregateOutputType | null
    _max: VaccinationPetLoverMaxAggregateOutputType | null
  }

  type GetVaccinationPetLoverGroupByPayload<T extends VaccinationPetLoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccinationPetLoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccinationPetLoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccinationPetLoverGroupByOutputType[P]>
            : GetScalarType<T[P], VaccinationPetLoverGroupByOutputType[P]>
        }
      >
    >


  export type VaccinationPetLoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    vaccineName?: boolean
    dateAdministered?: boolean
    nextDueDate?: boolean
    createdAt?: boolean
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationPetLover"]>

  export type VaccinationPetLoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    vaccineName?: boolean
    dateAdministered?: boolean
    nextDueDate?: boolean
    createdAt?: boolean
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationPetLover"]>

  export type VaccinationPetLoverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    petId?: boolean
    vaccineName?: boolean
    dateAdministered?: boolean
    nextDueDate?: boolean
    createdAt?: boolean
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationPetLover"]>

  export type VaccinationPetLoverSelectScalar = {
    id?: boolean
    petId?: boolean
    vaccineName?: boolean
    dateAdministered?: boolean
    nextDueDate?: boolean
    createdAt?: boolean
  }

  export type VaccinationPetLoverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "petId" | "vaccineName" | "dateAdministered" | "nextDueDate" | "createdAt", ExtArgs["result"]["vaccinationPetLover"]>
  export type VaccinationPetLoverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }
  export type VaccinationPetLoverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }
  export type VaccinationPetLoverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pet?: boolean | PetPetLoverDefaultArgs<ExtArgs>
  }

  export type $VaccinationPetLoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VaccinationPetLover"
    objects: {
      pet: Prisma.$PetPetLoverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      petId: string
      vaccineName: string
      dateAdministered: Date
      nextDueDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["vaccinationPetLover"]>
    composites: {}
  }

  type VaccinationPetLoverGetPayload<S extends boolean | null | undefined | VaccinationPetLoverDefaultArgs> = $Result.GetResult<Prisma.$VaccinationPetLoverPayload, S>

  type VaccinationPetLoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccinationPetLoverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccinationPetLoverCountAggregateInputType | true
    }

  export interface VaccinationPetLoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VaccinationPetLover'], meta: { name: 'VaccinationPetLover' } }
    /**
     * Find zero or one VaccinationPetLover that matches the filter.
     * @param {VaccinationPetLoverFindUniqueArgs} args - Arguments to find a VaccinationPetLover
     * @example
     * // Get one VaccinationPetLover
     * const vaccinationPetLover = await prisma.vaccinationPetLover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccinationPetLoverFindUniqueArgs>(args: SelectSubset<T, VaccinationPetLoverFindUniqueArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VaccinationPetLover that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccinationPetLoverFindUniqueOrThrowArgs} args - Arguments to find a VaccinationPetLover
     * @example
     * // Get one VaccinationPetLover
     * const vaccinationPetLover = await prisma.vaccinationPetLover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccinationPetLoverFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccinationPetLoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccinationPetLover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverFindFirstArgs} args - Arguments to find a VaccinationPetLover
     * @example
     * // Get one VaccinationPetLover
     * const vaccinationPetLover = await prisma.vaccinationPetLover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccinationPetLoverFindFirstArgs>(args?: SelectSubset<T, VaccinationPetLoverFindFirstArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccinationPetLover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverFindFirstOrThrowArgs} args - Arguments to find a VaccinationPetLover
     * @example
     * // Get one VaccinationPetLover
     * const vaccinationPetLover = await prisma.vaccinationPetLover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccinationPetLoverFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccinationPetLoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VaccinationPetLovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccinationPetLovers
     * const vaccinationPetLovers = await prisma.vaccinationPetLover.findMany()
     * 
     * // Get first 10 VaccinationPetLovers
     * const vaccinationPetLovers = await prisma.vaccinationPetLover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccinationPetLoverWithIdOnly = await prisma.vaccinationPetLover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccinationPetLoverFindManyArgs>(args?: SelectSubset<T, VaccinationPetLoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VaccinationPetLover.
     * @param {VaccinationPetLoverCreateArgs} args - Arguments to create a VaccinationPetLover.
     * @example
     * // Create one VaccinationPetLover
     * const VaccinationPetLover = await prisma.vaccinationPetLover.create({
     *   data: {
     *     // ... data to create a VaccinationPetLover
     *   }
     * })
     * 
     */
    create<T extends VaccinationPetLoverCreateArgs>(args: SelectSubset<T, VaccinationPetLoverCreateArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VaccinationPetLovers.
     * @param {VaccinationPetLoverCreateManyArgs} args - Arguments to create many VaccinationPetLovers.
     * @example
     * // Create many VaccinationPetLovers
     * const vaccinationPetLover = await prisma.vaccinationPetLover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccinationPetLoverCreateManyArgs>(args?: SelectSubset<T, VaccinationPetLoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VaccinationPetLovers and returns the data saved in the database.
     * @param {VaccinationPetLoverCreateManyAndReturnArgs} args - Arguments to create many VaccinationPetLovers.
     * @example
     * // Create many VaccinationPetLovers
     * const vaccinationPetLover = await prisma.vaccinationPetLover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VaccinationPetLovers and only return the `id`
     * const vaccinationPetLoverWithIdOnly = await prisma.vaccinationPetLover.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VaccinationPetLoverCreateManyAndReturnArgs>(args?: SelectSubset<T, VaccinationPetLoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VaccinationPetLover.
     * @param {VaccinationPetLoverDeleteArgs} args - Arguments to delete one VaccinationPetLover.
     * @example
     * // Delete one VaccinationPetLover
     * const VaccinationPetLover = await prisma.vaccinationPetLover.delete({
     *   where: {
     *     // ... filter to delete one VaccinationPetLover
     *   }
     * })
     * 
     */
    delete<T extends VaccinationPetLoverDeleteArgs>(args: SelectSubset<T, VaccinationPetLoverDeleteArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VaccinationPetLover.
     * @param {VaccinationPetLoverUpdateArgs} args - Arguments to update one VaccinationPetLover.
     * @example
     * // Update one VaccinationPetLover
     * const vaccinationPetLover = await prisma.vaccinationPetLover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccinationPetLoverUpdateArgs>(args: SelectSubset<T, VaccinationPetLoverUpdateArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VaccinationPetLovers.
     * @param {VaccinationPetLoverDeleteManyArgs} args - Arguments to filter VaccinationPetLovers to delete.
     * @example
     * // Delete a few VaccinationPetLovers
     * const { count } = await prisma.vaccinationPetLover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccinationPetLoverDeleteManyArgs>(args?: SelectSubset<T, VaccinationPetLoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccinationPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccinationPetLovers
     * const vaccinationPetLover = await prisma.vaccinationPetLover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccinationPetLoverUpdateManyArgs>(args: SelectSubset<T, VaccinationPetLoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccinationPetLovers and returns the data updated in the database.
     * @param {VaccinationPetLoverUpdateManyAndReturnArgs} args - Arguments to update many VaccinationPetLovers.
     * @example
     * // Update many VaccinationPetLovers
     * const vaccinationPetLover = await prisma.vaccinationPetLover.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VaccinationPetLovers and only return the `id`
     * const vaccinationPetLoverWithIdOnly = await prisma.vaccinationPetLover.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VaccinationPetLoverUpdateManyAndReturnArgs>(args: SelectSubset<T, VaccinationPetLoverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VaccinationPetLover.
     * @param {VaccinationPetLoverUpsertArgs} args - Arguments to update or create a VaccinationPetLover.
     * @example
     * // Update or create a VaccinationPetLover
     * const vaccinationPetLover = await prisma.vaccinationPetLover.upsert({
     *   create: {
     *     // ... data to create a VaccinationPetLover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccinationPetLover we want to update
     *   }
     * })
     */
    upsert<T extends VaccinationPetLoverUpsertArgs>(args: SelectSubset<T, VaccinationPetLoverUpsertArgs<ExtArgs>>): Prisma__VaccinationPetLoverClient<$Result.GetResult<Prisma.$VaccinationPetLoverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VaccinationPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverCountArgs} args - Arguments to filter VaccinationPetLovers to count.
     * @example
     * // Count the number of VaccinationPetLovers
     * const count = await prisma.vaccinationPetLover.count({
     *   where: {
     *     // ... the filter for the VaccinationPetLovers we want to count
     *   }
     * })
    **/
    count<T extends VaccinationPetLoverCountArgs>(
      args?: Subset<T, VaccinationPetLoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccinationPetLoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccinationPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccinationPetLoverAggregateArgs>(args: Subset<T, VaccinationPetLoverAggregateArgs>): Prisma.PrismaPromise<GetVaccinationPetLoverAggregateType<T>>

    /**
     * Group by VaccinationPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationPetLoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccinationPetLoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccinationPetLoverGroupByArgs['orderBy'] }
        : { orderBy?: VaccinationPetLoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccinationPetLoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccinationPetLoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VaccinationPetLover model
   */
  readonly fields: VaccinationPetLoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccinationPetLover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccinationPetLoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pet<T extends PetPetLoverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PetPetLoverDefaultArgs<ExtArgs>>): Prisma__PetPetLoverClient<$Result.GetResult<Prisma.$PetPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VaccinationPetLover model
   */ 
  interface VaccinationPetLoverFieldRefs {
    readonly id: FieldRef<"VaccinationPetLover", 'String'>
    readonly petId: FieldRef<"VaccinationPetLover", 'String'>
    readonly vaccineName: FieldRef<"VaccinationPetLover", 'String'>
    readonly dateAdministered: FieldRef<"VaccinationPetLover", 'DateTime'>
    readonly nextDueDate: FieldRef<"VaccinationPetLover", 'DateTime'>
    readonly createdAt: FieldRef<"VaccinationPetLover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VaccinationPetLover findUnique
   */
  export type VaccinationPetLoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationPetLover to fetch.
     */
    where: VaccinationPetLoverWhereUniqueInput
  }

  /**
   * VaccinationPetLover findUniqueOrThrow
   */
  export type VaccinationPetLoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationPetLover to fetch.
     */
    where: VaccinationPetLoverWhereUniqueInput
  }

  /**
   * VaccinationPetLover findFirst
   */
  export type VaccinationPetLoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationPetLover to fetch.
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationPetLovers to fetch.
     */
    orderBy?: VaccinationPetLoverOrderByWithRelationInput | VaccinationPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccinationPetLovers.
     */
    cursor?: VaccinationPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccinationPetLovers.
     */
    distinct?: VaccinationPetLoverScalarFieldEnum | VaccinationPetLoverScalarFieldEnum[]
  }

  /**
   * VaccinationPetLover findFirstOrThrow
   */
  export type VaccinationPetLoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationPetLover to fetch.
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationPetLovers to fetch.
     */
    orderBy?: VaccinationPetLoverOrderByWithRelationInput | VaccinationPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccinationPetLovers.
     */
    cursor?: VaccinationPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccinationPetLovers.
     */
    distinct?: VaccinationPetLoverScalarFieldEnum | VaccinationPetLoverScalarFieldEnum[]
  }

  /**
   * VaccinationPetLover findMany
   */
  export type VaccinationPetLoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationPetLovers to fetch.
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationPetLovers to fetch.
     */
    orderBy?: VaccinationPetLoverOrderByWithRelationInput | VaccinationPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccinationPetLovers.
     */
    cursor?: VaccinationPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationPetLovers.
     */
    skip?: number
    distinct?: VaccinationPetLoverScalarFieldEnum | VaccinationPetLoverScalarFieldEnum[]
  }

  /**
   * VaccinationPetLover create
   */
  export type VaccinationPetLoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to create a VaccinationPetLover.
     */
    data: XOR<VaccinationPetLoverCreateInput, VaccinationPetLoverUncheckedCreateInput>
  }

  /**
   * VaccinationPetLover createMany
   */
  export type VaccinationPetLoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VaccinationPetLovers.
     */
    data: VaccinationPetLoverCreateManyInput | VaccinationPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VaccinationPetLover createManyAndReturn
   */
  export type VaccinationPetLoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * The data used to create many VaccinationPetLovers.
     */
    data: VaccinationPetLoverCreateManyInput | VaccinationPetLoverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VaccinationPetLover update
   */
  export type VaccinationPetLoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * The data needed to update a VaccinationPetLover.
     */
    data: XOR<VaccinationPetLoverUpdateInput, VaccinationPetLoverUncheckedUpdateInput>
    /**
     * Choose, which VaccinationPetLover to update.
     */
    where: VaccinationPetLoverWhereUniqueInput
  }

  /**
   * VaccinationPetLover updateMany
   */
  export type VaccinationPetLoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VaccinationPetLovers.
     */
    data: XOR<VaccinationPetLoverUpdateManyMutationInput, VaccinationPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which VaccinationPetLovers to update
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * Limit how many VaccinationPetLovers to update.
     */
    limit?: number
  }

  /**
   * VaccinationPetLover updateManyAndReturn
   */
  export type VaccinationPetLoverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * The data used to update VaccinationPetLovers.
     */
    data: XOR<VaccinationPetLoverUpdateManyMutationInput, VaccinationPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which VaccinationPetLovers to update
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * Limit how many VaccinationPetLovers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VaccinationPetLover upsert
   */
  export type VaccinationPetLoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * The filter to search for the VaccinationPetLover to update in case it exists.
     */
    where: VaccinationPetLoverWhereUniqueInput
    /**
     * In case the VaccinationPetLover found by the `where` argument doesn't exist, create a new VaccinationPetLover with this data.
     */
    create: XOR<VaccinationPetLoverCreateInput, VaccinationPetLoverUncheckedCreateInput>
    /**
     * In case the VaccinationPetLover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccinationPetLoverUpdateInput, VaccinationPetLoverUncheckedUpdateInput>
  }

  /**
   * VaccinationPetLover delete
   */
  export type VaccinationPetLoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
    /**
     * Filter which VaccinationPetLover to delete.
     */
    where: VaccinationPetLoverWhereUniqueInput
  }

  /**
   * VaccinationPetLover deleteMany
   */
  export type VaccinationPetLoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccinationPetLovers to delete
     */
    where?: VaccinationPetLoverWhereInput
    /**
     * Limit how many VaccinationPetLovers to delete.
     */
    limit?: number
  }

  /**
   * VaccinationPetLover without action
   */
  export type VaccinationPetLoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationPetLover
     */
    select?: VaccinationPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationPetLover
     */
    omit?: VaccinationPetLoverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationPetLoverInclude<ExtArgs> | null
  }


  /**
   * Model ClinicPetLover
   */

  export type AggregateClinicPetLover = {
    _count: ClinicPetLoverCountAggregateOutputType | null
    _min: ClinicPetLoverMinAggregateOutputType | null
    _max: ClinicPetLoverMaxAggregateOutputType | null
  }

  export type ClinicPetLoverMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type ClinicPetLoverMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type ClinicPetLoverCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    _all: number
  }


  export type ClinicPetLoverMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type ClinicPetLoverMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type ClinicPetLoverCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    _all?: true
  }

  export type ClinicPetLoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicPetLover to aggregate.
     */
    where?: ClinicPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPetLovers to fetch.
     */
    orderBy?: ClinicPetLoverOrderByWithRelationInput | ClinicPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicPetLovers
    **/
    _count?: true | ClinicPetLoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicPetLoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicPetLoverMaxAggregateInputType
  }

  export type GetClinicPetLoverAggregateType<T extends ClinicPetLoverAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicPetLover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicPetLover[P]>
      : GetScalarType<T[P], AggregateClinicPetLover[P]>
  }




  export type ClinicPetLoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicPetLoverWhereInput
    orderBy?: ClinicPetLoverOrderByWithAggregationInput | ClinicPetLoverOrderByWithAggregationInput[]
    by: ClinicPetLoverScalarFieldEnum[] | ClinicPetLoverScalarFieldEnum
    having?: ClinicPetLoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicPetLoverCountAggregateInputType | true
    _min?: ClinicPetLoverMinAggregateInputType
    _max?: ClinicPetLoverMaxAggregateInputType
  }

  export type ClinicPetLoverGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string
    createdAt: Date
    _count: ClinicPetLoverCountAggregateOutputType | null
    _min: ClinicPetLoverMinAggregateOutputType | null
    _max: ClinicPetLoverMaxAggregateOutputType | null
  }

  type GetClinicPetLoverGroupByPayload<T extends ClinicPetLoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicPetLoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicPetLoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicPetLoverGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicPetLoverGroupByOutputType[P]>
        }
      >
    >


  export type ClinicPetLoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clinicPetLover"]>

  export type ClinicPetLoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clinicPetLover"]>

  export type ClinicPetLoverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["clinicPetLover"]>

  export type ClinicPetLoverSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }

  export type ClinicPetLoverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "createdAt", ExtArgs["result"]["clinicPetLover"]>

  export type $ClinicPetLoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicPetLover"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string
      createdAt: Date
    }, ExtArgs["result"]["clinicPetLover"]>
    composites: {}
  }

  type ClinicPetLoverGetPayload<S extends boolean | null | undefined | ClinicPetLoverDefaultArgs> = $Result.GetResult<Prisma.$ClinicPetLoverPayload, S>

  type ClinicPetLoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicPetLoverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicPetLoverCountAggregateInputType | true
    }

  export interface ClinicPetLoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicPetLover'], meta: { name: 'ClinicPetLover' } }
    /**
     * Find zero or one ClinicPetLover that matches the filter.
     * @param {ClinicPetLoverFindUniqueArgs} args - Arguments to find a ClinicPetLover
     * @example
     * // Get one ClinicPetLover
     * const clinicPetLover = await prisma.clinicPetLover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicPetLoverFindUniqueArgs>(args: SelectSubset<T, ClinicPetLoverFindUniqueArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicPetLover that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicPetLoverFindUniqueOrThrowArgs} args - Arguments to find a ClinicPetLover
     * @example
     * // Get one ClinicPetLover
     * const clinicPetLover = await prisma.clinicPetLover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicPetLoverFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicPetLoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicPetLover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverFindFirstArgs} args - Arguments to find a ClinicPetLover
     * @example
     * // Get one ClinicPetLover
     * const clinicPetLover = await prisma.clinicPetLover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicPetLoverFindFirstArgs>(args?: SelectSubset<T, ClinicPetLoverFindFirstArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicPetLover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverFindFirstOrThrowArgs} args - Arguments to find a ClinicPetLover
     * @example
     * // Get one ClinicPetLover
     * const clinicPetLover = await prisma.clinicPetLover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicPetLoverFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicPetLoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicPetLovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicPetLovers
     * const clinicPetLovers = await prisma.clinicPetLover.findMany()
     * 
     * // Get first 10 ClinicPetLovers
     * const clinicPetLovers = await prisma.clinicPetLover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicPetLoverWithIdOnly = await prisma.clinicPetLover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicPetLoverFindManyArgs>(args?: SelectSubset<T, ClinicPetLoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicPetLover.
     * @param {ClinicPetLoverCreateArgs} args - Arguments to create a ClinicPetLover.
     * @example
     * // Create one ClinicPetLover
     * const ClinicPetLover = await prisma.clinicPetLover.create({
     *   data: {
     *     // ... data to create a ClinicPetLover
     *   }
     * })
     * 
     */
    create<T extends ClinicPetLoverCreateArgs>(args: SelectSubset<T, ClinicPetLoverCreateArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicPetLovers.
     * @param {ClinicPetLoverCreateManyArgs} args - Arguments to create many ClinicPetLovers.
     * @example
     * // Create many ClinicPetLovers
     * const clinicPetLover = await prisma.clinicPetLover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicPetLoverCreateManyArgs>(args?: SelectSubset<T, ClinicPetLoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicPetLovers and returns the data saved in the database.
     * @param {ClinicPetLoverCreateManyAndReturnArgs} args - Arguments to create many ClinicPetLovers.
     * @example
     * // Create many ClinicPetLovers
     * const clinicPetLover = await prisma.clinicPetLover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicPetLovers and only return the `id`
     * const clinicPetLoverWithIdOnly = await prisma.clinicPetLover.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicPetLoverCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicPetLoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicPetLover.
     * @param {ClinicPetLoverDeleteArgs} args - Arguments to delete one ClinicPetLover.
     * @example
     * // Delete one ClinicPetLover
     * const ClinicPetLover = await prisma.clinicPetLover.delete({
     *   where: {
     *     // ... filter to delete one ClinicPetLover
     *   }
     * })
     * 
     */
    delete<T extends ClinicPetLoverDeleteArgs>(args: SelectSubset<T, ClinicPetLoverDeleteArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicPetLover.
     * @param {ClinicPetLoverUpdateArgs} args - Arguments to update one ClinicPetLover.
     * @example
     * // Update one ClinicPetLover
     * const clinicPetLover = await prisma.clinicPetLover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicPetLoverUpdateArgs>(args: SelectSubset<T, ClinicPetLoverUpdateArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicPetLovers.
     * @param {ClinicPetLoverDeleteManyArgs} args - Arguments to filter ClinicPetLovers to delete.
     * @example
     * // Delete a few ClinicPetLovers
     * const { count } = await prisma.clinicPetLover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicPetLoverDeleteManyArgs>(args?: SelectSubset<T, ClinicPetLoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicPetLovers
     * const clinicPetLover = await prisma.clinicPetLover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicPetLoverUpdateManyArgs>(args: SelectSubset<T, ClinicPetLoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicPetLovers and returns the data updated in the database.
     * @param {ClinicPetLoverUpdateManyAndReturnArgs} args - Arguments to update many ClinicPetLovers.
     * @example
     * // Update many ClinicPetLovers
     * const clinicPetLover = await prisma.clinicPetLover.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicPetLovers and only return the `id`
     * const clinicPetLoverWithIdOnly = await prisma.clinicPetLover.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicPetLoverUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicPetLoverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicPetLover.
     * @param {ClinicPetLoverUpsertArgs} args - Arguments to update or create a ClinicPetLover.
     * @example
     * // Update or create a ClinicPetLover
     * const clinicPetLover = await prisma.clinicPetLover.upsert({
     *   create: {
     *     // ... data to create a ClinicPetLover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicPetLover we want to update
     *   }
     * })
     */
    upsert<T extends ClinicPetLoverUpsertArgs>(args: SelectSubset<T, ClinicPetLoverUpsertArgs<ExtArgs>>): Prisma__ClinicPetLoverClient<$Result.GetResult<Prisma.$ClinicPetLoverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicPetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverCountArgs} args - Arguments to filter ClinicPetLovers to count.
     * @example
     * // Count the number of ClinicPetLovers
     * const count = await prisma.clinicPetLover.count({
     *   where: {
     *     // ... the filter for the ClinicPetLovers we want to count
     *   }
     * })
    **/
    count<T extends ClinicPetLoverCountArgs>(
      args?: Subset<T, ClinicPetLoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicPetLoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicPetLoverAggregateArgs>(args: Subset<T, ClinicPetLoverAggregateArgs>): Prisma.PrismaPromise<GetClinicPetLoverAggregateType<T>>

    /**
     * Group by ClinicPetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicPetLoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicPetLoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicPetLoverGroupByArgs['orderBy'] }
        : { orderBy?: ClinicPetLoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicPetLoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicPetLoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicPetLover model
   */
  readonly fields: ClinicPetLoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicPetLover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicPetLoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicPetLover model
   */ 
  interface ClinicPetLoverFieldRefs {
    readonly id: FieldRef<"ClinicPetLover", 'String'>
    readonly name: FieldRef<"ClinicPetLover", 'String'>
    readonly address: FieldRef<"ClinicPetLover", 'String'>
    readonly phone: FieldRef<"ClinicPetLover", 'String'>
    readonly createdAt: FieldRef<"ClinicPetLover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicPetLover findUnique
   */
  export type ClinicPetLoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * Filter, which ClinicPetLover to fetch.
     */
    where: ClinicPetLoverWhereUniqueInput
  }

  /**
   * ClinicPetLover findUniqueOrThrow
   */
  export type ClinicPetLoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * Filter, which ClinicPetLover to fetch.
     */
    where: ClinicPetLoverWhereUniqueInput
  }

  /**
   * ClinicPetLover findFirst
   */
  export type ClinicPetLoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * Filter, which ClinicPetLover to fetch.
     */
    where?: ClinicPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPetLovers to fetch.
     */
    orderBy?: ClinicPetLoverOrderByWithRelationInput | ClinicPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicPetLovers.
     */
    cursor?: ClinicPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicPetLovers.
     */
    distinct?: ClinicPetLoverScalarFieldEnum | ClinicPetLoverScalarFieldEnum[]
  }

  /**
   * ClinicPetLover findFirstOrThrow
   */
  export type ClinicPetLoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * Filter, which ClinicPetLover to fetch.
     */
    where?: ClinicPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPetLovers to fetch.
     */
    orderBy?: ClinicPetLoverOrderByWithRelationInput | ClinicPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicPetLovers.
     */
    cursor?: ClinicPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicPetLovers.
     */
    distinct?: ClinicPetLoverScalarFieldEnum | ClinicPetLoverScalarFieldEnum[]
  }

  /**
   * ClinicPetLover findMany
   */
  export type ClinicPetLoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * Filter, which ClinicPetLovers to fetch.
     */
    where?: ClinicPetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicPetLovers to fetch.
     */
    orderBy?: ClinicPetLoverOrderByWithRelationInput | ClinicPetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicPetLovers.
     */
    cursor?: ClinicPetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicPetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicPetLovers.
     */
    skip?: number
    distinct?: ClinicPetLoverScalarFieldEnum | ClinicPetLoverScalarFieldEnum[]
  }

  /**
   * ClinicPetLover create
   */
  export type ClinicPetLoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * The data needed to create a ClinicPetLover.
     */
    data: XOR<ClinicPetLoverCreateInput, ClinicPetLoverUncheckedCreateInput>
  }

  /**
   * ClinicPetLover createMany
   */
  export type ClinicPetLoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicPetLovers.
     */
    data: ClinicPetLoverCreateManyInput | ClinicPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicPetLover createManyAndReturn
   */
  export type ClinicPetLoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicPetLovers.
     */
    data: ClinicPetLoverCreateManyInput | ClinicPetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicPetLover update
   */
  export type ClinicPetLoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * The data needed to update a ClinicPetLover.
     */
    data: XOR<ClinicPetLoverUpdateInput, ClinicPetLoverUncheckedUpdateInput>
    /**
     * Choose, which ClinicPetLover to update.
     */
    where: ClinicPetLoverWhereUniqueInput
  }

  /**
   * ClinicPetLover updateMany
   */
  export type ClinicPetLoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicPetLovers.
     */
    data: XOR<ClinicPetLoverUpdateManyMutationInput, ClinicPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which ClinicPetLovers to update
     */
    where?: ClinicPetLoverWhereInput
    /**
     * Limit how many ClinicPetLovers to update.
     */
    limit?: number
  }

  /**
   * ClinicPetLover updateManyAndReturn
   */
  export type ClinicPetLoverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * The data used to update ClinicPetLovers.
     */
    data: XOR<ClinicPetLoverUpdateManyMutationInput, ClinicPetLoverUncheckedUpdateManyInput>
    /**
     * Filter which ClinicPetLovers to update
     */
    where?: ClinicPetLoverWhereInput
    /**
     * Limit how many ClinicPetLovers to update.
     */
    limit?: number
  }

  /**
   * ClinicPetLover upsert
   */
  export type ClinicPetLoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * The filter to search for the ClinicPetLover to update in case it exists.
     */
    where: ClinicPetLoverWhereUniqueInput
    /**
     * In case the ClinicPetLover found by the `where` argument doesn't exist, create a new ClinicPetLover with this data.
     */
    create: XOR<ClinicPetLoverCreateInput, ClinicPetLoverUncheckedCreateInput>
    /**
     * In case the ClinicPetLover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicPetLoverUpdateInput, ClinicPetLoverUncheckedUpdateInput>
  }

  /**
   * ClinicPetLover delete
   */
  export type ClinicPetLoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
    /**
     * Filter which ClinicPetLover to delete.
     */
    where: ClinicPetLoverWhereUniqueInput
  }

  /**
   * ClinicPetLover deleteMany
   */
  export type ClinicPetLoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicPetLovers to delete
     */
    where?: ClinicPetLoverWhereInput
    /**
     * Limit how many ClinicPetLovers to delete.
     */
    limit?: number
  }

  /**
   * ClinicPetLover without action
   */
  export type ClinicPetLoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicPetLover
     */
    select?: ClinicPetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicPetLover
     */
    omit?: ClinicPetLoverOmit<ExtArgs> | null
  }


  /**
   * Model StorePetLover
   */

  export type AggregateStorePetLover = {
    _count: StorePetLoverCountAggregateOutputType | null
    _min: StorePetLoverMinAggregateOutputType | null
    _max: StorePetLoverMaxAggregateOutputType | null
  }

  export type StorePetLoverMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type StorePetLoverMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type StorePetLoverCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    _all: number
  }


  export type StorePetLoverMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type StorePetLoverMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type StorePetLoverCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    _all?: true
  }

  export type StorePetLoverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePetLover to aggregate.
     */
    where?: StorePetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePetLovers to fetch.
     */
    orderBy?: StorePetLoverOrderByWithRelationInput | StorePetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorePetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorePetLovers
    **/
    _count?: true | StorePetLoverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorePetLoverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorePetLoverMaxAggregateInputType
  }

  export type GetStorePetLoverAggregateType<T extends StorePetLoverAggregateArgs> = {
        [P in keyof T & keyof AggregateStorePetLover]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorePetLover[P]>
      : GetScalarType<T[P], AggregateStorePetLover[P]>
  }




  export type StorePetLoverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePetLoverWhereInput
    orderBy?: StorePetLoverOrderByWithAggregationInput | StorePetLoverOrderByWithAggregationInput[]
    by: StorePetLoverScalarFieldEnum[] | StorePetLoverScalarFieldEnum
    having?: StorePetLoverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorePetLoverCountAggregateInputType | true
    _min?: StorePetLoverMinAggregateInputType
    _max?: StorePetLoverMaxAggregateInputType
  }

  export type StorePetLoverGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string
    createdAt: Date
    _count: StorePetLoverCountAggregateOutputType | null
    _min: StorePetLoverMinAggregateOutputType | null
    _max: StorePetLoverMaxAggregateOutputType | null
  }

  type GetStorePetLoverGroupByPayload<T extends StorePetLoverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorePetLoverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorePetLoverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorePetLoverGroupByOutputType[P]>
            : GetScalarType<T[P], StorePetLoverGroupByOutputType[P]>
        }
      >
    >


  export type StorePetLoverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["storePetLover"]>

  export type StorePetLoverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["storePetLover"]>

  export type StorePetLoverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["storePetLover"]>

  export type StorePetLoverSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }

  export type StorePetLoverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "createdAt", ExtArgs["result"]["storePetLover"]>

  export type $StorePetLoverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorePetLover"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string
      createdAt: Date
    }, ExtArgs["result"]["storePetLover"]>
    composites: {}
  }

  type StorePetLoverGetPayload<S extends boolean | null | undefined | StorePetLoverDefaultArgs> = $Result.GetResult<Prisma.$StorePetLoverPayload, S>

  type StorePetLoverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StorePetLoverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StorePetLoverCountAggregateInputType | true
    }

  export interface StorePetLoverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorePetLover'], meta: { name: 'StorePetLover' } }
    /**
     * Find zero or one StorePetLover that matches the filter.
     * @param {StorePetLoverFindUniqueArgs} args - Arguments to find a StorePetLover
     * @example
     * // Get one StorePetLover
     * const storePetLover = await prisma.storePetLover.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorePetLoverFindUniqueArgs>(args: SelectSubset<T, StorePetLoverFindUniqueArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StorePetLover that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StorePetLoverFindUniqueOrThrowArgs} args - Arguments to find a StorePetLover
     * @example
     * // Get one StorePetLover
     * const storePetLover = await prisma.storePetLover.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorePetLoverFindUniqueOrThrowArgs>(args: SelectSubset<T, StorePetLoverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorePetLover that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverFindFirstArgs} args - Arguments to find a StorePetLover
     * @example
     * // Get one StorePetLover
     * const storePetLover = await prisma.storePetLover.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorePetLoverFindFirstArgs>(args?: SelectSubset<T, StorePetLoverFindFirstArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorePetLover that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverFindFirstOrThrowArgs} args - Arguments to find a StorePetLover
     * @example
     * // Get one StorePetLover
     * const storePetLover = await prisma.storePetLover.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorePetLoverFindFirstOrThrowArgs>(args?: SelectSubset<T, StorePetLoverFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StorePetLovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorePetLovers
     * const storePetLovers = await prisma.storePetLover.findMany()
     * 
     * // Get first 10 StorePetLovers
     * const storePetLovers = await prisma.storePetLover.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storePetLoverWithIdOnly = await prisma.storePetLover.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorePetLoverFindManyArgs>(args?: SelectSubset<T, StorePetLoverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StorePetLover.
     * @param {StorePetLoverCreateArgs} args - Arguments to create a StorePetLover.
     * @example
     * // Create one StorePetLover
     * const StorePetLover = await prisma.storePetLover.create({
     *   data: {
     *     // ... data to create a StorePetLover
     *   }
     * })
     * 
     */
    create<T extends StorePetLoverCreateArgs>(args: SelectSubset<T, StorePetLoverCreateArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StorePetLovers.
     * @param {StorePetLoverCreateManyArgs} args - Arguments to create many StorePetLovers.
     * @example
     * // Create many StorePetLovers
     * const storePetLover = await prisma.storePetLover.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorePetLoverCreateManyArgs>(args?: SelectSubset<T, StorePetLoverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorePetLovers and returns the data saved in the database.
     * @param {StorePetLoverCreateManyAndReturnArgs} args - Arguments to create many StorePetLovers.
     * @example
     * // Create many StorePetLovers
     * const storePetLover = await prisma.storePetLover.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorePetLovers and only return the `id`
     * const storePetLoverWithIdOnly = await prisma.storePetLover.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorePetLoverCreateManyAndReturnArgs>(args?: SelectSubset<T, StorePetLoverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StorePetLover.
     * @param {StorePetLoverDeleteArgs} args - Arguments to delete one StorePetLover.
     * @example
     * // Delete one StorePetLover
     * const StorePetLover = await prisma.storePetLover.delete({
     *   where: {
     *     // ... filter to delete one StorePetLover
     *   }
     * })
     * 
     */
    delete<T extends StorePetLoverDeleteArgs>(args: SelectSubset<T, StorePetLoverDeleteArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StorePetLover.
     * @param {StorePetLoverUpdateArgs} args - Arguments to update one StorePetLover.
     * @example
     * // Update one StorePetLover
     * const storePetLover = await prisma.storePetLover.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorePetLoverUpdateArgs>(args: SelectSubset<T, StorePetLoverUpdateArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StorePetLovers.
     * @param {StorePetLoverDeleteManyArgs} args - Arguments to filter StorePetLovers to delete.
     * @example
     * // Delete a few StorePetLovers
     * const { count } = await prisma.storePetLover.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorePetLoverDeleteManyArgs>(args?: SelectSubset<T, StorePetLoverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorePetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorePetLovers
     * const storePetLover = await prisma.storePetLover.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorePetLoverUpdateManyArgs>(args: SelectSubset<T, StorePetLoverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorePetLovers and returns the data updated in the database.
     * @param {StorePetLoverUpdateManyAndReturnArgs} args - Arguments to update many StorePetLovers.
     * @example
     * // Update many StorePetLovers
     * const storePetLover = await prisma.storePetLover.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StorePetLovers and only return the `id`
     * const storePetLoverWithIdOnly = await prisma.storePetLover.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StorePetLoverUpdateManyAndReturnArgs>(args: SelectSubset<T, StorePetLoverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StorePetLover.
     * @param {StorePetLoverUpsertArgs} args - Arguments to update or create a StorePetLover.
     * @example
     * // Update or create a StorePetLover
     * const storePetLover = await prisma.storePetLover.upsert({
     *   create: {
     *     // ... data to create a StorePetLover
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorePetLover we want to update
     *   }
     * })
     */
    upsert<T extends StorePetLoverUpsertArgs>(args: SelectSubset<T, StorePetLoverUpsertArgs<ExtArgs>>): Prisma__StorePetLoverClient<$Result.GetResult<Prisma.$StorePetLoverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StorePetLovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverCountArgs} args - Arguments to filter StorePetLovers to count.
     * @example
     * // Count the number of StorePetLovers
     * const count = await prisma.storePetLover.count({
     *   where: {
     *     // ... the filter for the StorePetLovers we want to count
     *   }
     * })
    **/
    count<T extends StorePetLoverCountArgs>(
      args?: Subset<T, StorePetLoverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorePetLoverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorePetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorePetLoverAggregateArgs>(args: Subset<T, StorePetLoverAggregateArgs>): Prisma.PrismaPromise<GetStorePetLoverAggregateType<T>>

    /**
     * Group by StorePetLover.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePetLoverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorePetLoverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorePetLoverGroupByArgs['orderBy'] }
        : { orderBy?: StorePetLoverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorePetLoverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorePetLoverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorePetLover model
   */
  readonly fields: StorePetLoverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorePetLover.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorePetLoverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorePetLover model
   */ 
  interface StorePetLoverFieldRefs {
    readonly id: FieldRef<"StorePetLover", 'String'>
    readonly name: FieldRef<"StorePetLover", 'String'>
    readonly address: FieldRef<"StorePetLover", 'String'>
    readonly phone: FieldRef<"StorePetLover", 'String'>
    readonly createdAt: FieldRef<"StorePetLover", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorePetLover findUnique
   */
  export type StorePetLoverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * Filter, which StorePetLover to fetch.
     */
    where: StorePetLoverWhereUniqueInput
  }

  /**
   * StorePetLover findUniqueOrThrow
   */
  export type StorePetLoverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * Filter, which StorePetLover to fetch.
     */
    where: StorePetLoverWhereUniqueInput
  }

  /**
   * StorePetLover findFirst
   */
  export type StorePetLoverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * Filter, which StorePetLover to fetch.
     */
    where?: StorePetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePetLovers to fetch.
     */
    orderBy?: StorePetLoverOrderByWithRelationInput | StorePetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePetLovers.
     */
    cursor?: StorePetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePetLovers.
     */
    distinct?: StorePetLoverScalarFieldEnum | StorePetLoverScalarFieldEnum[]
  }

  /**
   * StorePetLover findFirstOrThrow
   */
  export type StorePetLoverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * Filter, which StorePetLover to fetch.
     */
    where?: StorePetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePetLovers to fetch.
     */
    orderBy?: StorePetLoverOrderByWithRelationInput | StorePetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePetLovers.
     */
    cursor?: StorePetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePetLovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePetLovers.
     */
    distinct?: StorePetLoverScalarFieldEnum | StorePetLoverScalarFieldEnum[]
  }

  /**
   * StorePetLover findMany
   */
  export type StorePetLoverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * Filter, which StorePetLovers to fetch.
     */
    where?: StorePetLoverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePetLovers to fetch.
     */
    orderBy?: StorePetLoverOrderByWithRelationInput | StorePetLoverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorePetLovers.
     */
    cursor?: StorePetLoverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePetLovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePetLovers.
     */
    skip?: number
    distinct?: StorePetLoverScalarFieldEnum | StorePetLoverScalarFieldEnum[]
  }

  /**
   * StorePetLover create
   */
  export type StorePetLoverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * The data needed to create a StorePetLover.
     */
    data: XOR<StorePetLoverCreateInput, StorePetLoverUncheckedCreateInput>
  }

  /**
   * StorePetLover createMany
   */
  export type StorePetLoverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorePetLovers.
     */
    data: StorePetLoverCreateManyInput | StorePetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorePetLover createManyAndReturn
   */
  export type StorePetLoverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * The data used to create many StorePetLovers.
     */
    data: StorePetLoverCreateManyInput | StorePetLoverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorePetLover update
   */
  export type StorePetLoverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * The data needed to update a StorePetLover.
     */
    data: XOR<StorePetLoverUpdateInput, StorePetLoverUncheckedUpdateInput>
    /**
     * Choose, which StorePetLover to update.
     */
    where: StorePetLoverWhereUniqueInput
  }

  /**
   * StorePetLover updateMany
   */
  export type StorePetLoverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorePetLovers.
     */
    data: XOR<StorePetLoverUpdateManyMutationInput, StorePetLoverUncheckedUpdateManyInput>
    /**
     * Filter which StorePetLovers to update
     */
    where?: StorePetLoverWhereInput
    /**
     * Limit how many StorePetLovers to update.
     */
    limit?: number
  }

  /**
   * StorePetLover updateManyAndReturn
   */
  export type StorePetLoverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * The data used to update StorePetLovers.
     */
    data: XOR<StorePetLoverUpdateManyMutationInput, StorePetLoverUncheckedUpdateManyInput>
    /**
     * Filter which StorePetLovers to update
     */
    where?: StorePetLoverWhereInput
    /**
     * Limit how many StorePetLovers to update.
     */
    limit?: number
  }

  /**
   * StorePetLover upsert
   */
  export type StorePetLoverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * The filter to search for the StorePetLover to update in case it exists.
     */
    where: StorePetLoverWhereUniqueInput
    /**
     * In case the StorePetLover found by the `where` argument doesn't exist, create a new StorePetLover with this data.
     */
    create: XOR<StorePetLoverCreateInput, StorePetLoverUncheckedCreateInput>
    /**
     * In case the StorePetLover was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorePetLoverUpdateInput, StorePetLoverUncheckedUpdateInput>
  }

  /**
   * StorePetLover delete
   */
  export type StorePetLoverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
    /**
     * Filter which StorePetLover to delete.
     */
    where: StorePetLoverWhereUniqueInput
  }

  /**
   * StorePetLover deleteMany
   */
  export type StorePetLoverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePetLovers to delete
     */
    where?: StorePetLoverWhereInput
    /**
     * Limit how many StorePetLovers to delete.
     */
    limit?: number
  }

  /**
   * StorePetLover without action
   */
  export type StorePetLoverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePetLover
     */
    select?: StorePetLoverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorePetLover
     */
    omit?: StorePetLoverOmit<ExtArgs> | null
  }


  /**
   * Model UserElderlyCareCompanion
   */

  export type AggregateUserElderlyCareCompanion = {
    _count: UserElderlyCareCompanionCountAggregateOutputType | null
    _min: UserElderlyCareCompanionMinAggregateOutputType | null
    _max: UserElderlyCareCompanionMaxAggregateOutputType | null
  }

  export type UserElderlyCareCompanionMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserElderlyCareCompanionMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserElderlyCareCompanionCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserElderlyCareCompanionMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserElderlyCareCompanionMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserElderlyCareCompanionCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserElderlyCareCompanionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserElderlyCareCompanion to aggregate.
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserElderlyCareCompanions to fetch.
     */
    orderBy?: UserElderlyCareCompanionOrderByWithRelationInput | UserElderlyCareCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserElderlyCareCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserElderlyCareCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserElderlyCareCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserElderlyCareCompanions
    **/
    _count?: true | UserElderlyCareCompanionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserElderlyCareCompanionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserElderlyCareCompanionMaxAggregateInputType
  }

  export type GetUserElderlyCareCompanionAggregateType<T extends UserElderlyCareCompanionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserElderlyCareCompanion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserElderlyCareCompanion[P]>
      : GetScalarType<T[P], AggregateUserElderlyCareCompanion[P]>
  }




  export type UserElderlyCareCompanionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserElderlyCareCompanionWhereInput
    orderBy?: UserElderlyCareCompanionOrderByWithAggregationInput | UserElderlyCareCompanionOrderByWithAggregationInput[]
    by: UserElderlyCareCompanionScalarFieldEnum[] | UserElderlyCareCompanionScalarFieldEnum
    having?: UserElderlyCareCompanionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserElderlyCareCompanionCountAggregateInputType | true
    _min?: UserElderlyCareCompanionMinAggregateInputType
    _max?: UserElderlyCareCompanionMaxAggregateInputType
  }

  export type UserElderlyCareCompanionGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserElderlyCareCompanionCountAggregateOutputType | null
    _min: UserElderlyCareCompanionMinAggregateOutputType | null
    _max: UserElderlyCareCompanionMaxAggregateOutputType | null
  }

  type GetUserElderlyCareCompanionGroupByPayload<T extends UserElderlyCareCompanionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserElderlyCareCompanionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserElderlyCareCompanionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserElderlyCareCompanionGroupByOutputType[P]>
            : GetScalarType<T[P], UserElderlyCareCompanionGroupByOutputType[P]>
        }
      >
    >


  export type UserElderlyCareCompanionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    ElderlyCareCompanionAppointment?: boolean | UserElderlyCareCompanion$ElderlyCareCompanionAppointmentArgs<ExtArgs>
    ElderlyCareCompanionRecord?: boolean | UserElderlyCareCompanion$ElderlyCareCompanionRecordArgs<ExtArgs>
    ElderlyCareCompanionMedicationTracking?: boolean | UserElderlyCareCompanion$ElderlyCareCompanionMedicationTrackingArgs<ExtArgs>
    _count?: boolean | UserElderlyCareCompanionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userElderlyCareCompanion"]>

  export type UserElderlyCareCompanionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userElderlyCareCompanion"]>

  export type UserElderlyCareCompanionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userElderlyCareCompanion"]>

  export type UserElderlyCareCompanionSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserElderlyCareCompanionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userElderlyCareCompanion"]>
  export type UserElderlyCareCompanionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ElderlyCareCompanionAppointment?: boolean | UserElderlyCareCompanion$ElderlyCareCompanionAppointmentArgs<ExtArgs>
    ElderlyCareCompanionRecord?: boolean | UserElderlyCareCompanion$ElderlyCareCompanionRecordArgs<ExtArgs>
    ElderlyCareCompanionMedicationTracking?: boolean | UserElderlyCareCompanion$ElderlyCareCompanionMedicationTrackingArgs<ExtArgs>
    _count?: boolean | UserElderlyCareCompanionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserElderlyCareCompanionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserElderlyCareCompanionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserElderlyCareCompanionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserElderlyCareCompanion"
    objects: {
      ElderlyCareCompanionAppointment: Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>[]
      ElderlyCareCompanionRecord: Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>[]
      ElderlyCareCompanionMedicationTracking: Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userElderlyCareCompanion"]>
    composites: {}
  }

  type UserElderlyCareCompanionGetPayload<S extends boolean | null | undefined | UserElderlyCareCompanionDefaultArgs> = $Result.GetResult<Prisma.$UserElderlyCareCompanionPayload, S>

  type UserElderlyCareCompanionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserElderlyCareCompanionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserElderlyCareCompanionCountAggregateInputType | true
    }

  export interface UserElderlyCareCompanionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserElderlyCareCompanion'], meta: { name: 'UserElderlyCareCompanion' } }
    /**
     * Find zero or one UserElderlyCareCompanion that matches the filter.
     * @param {UserElderlyCareCompanionFindUniqueArgs} args - Arguments to find a UserElderlyCareCompanion
     * @example
     * // Get one UserElderlyCareCompanion
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserElderlyCareCompanionFindUniqueArgs>(args: SelectSubset<T, UserElderlyCareCompanionFindUniqueArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserElderlyCareCompanion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserElderlyCareCompanionFindUniqueOrThrowArgs} args - Arguments to find a UserElderlyCareCompanion
     * @example
     * // Get one UserElderlyCareCompanion
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserElderlyCareCompanionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserElderlyCareCompanionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserElderlyCareCompanion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionFindFirstArgs} args - Arguments to find a UserElderlyCareCompanion
     * @example
     * // Get one UserElderlyCareCompanion
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserElderlyCareCompanionFindFirstArgs>(args?: SelectSubset<T, UserElderlyCareCompanionFindFirstArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserElderlyCareCompanion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionFindFirstOrThrowArgs} args - Arguments to find a UserElderlyCareCompanion
     * @example
     * // Get one UserElderlyCareCompanion
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserElderlyCareCompanionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserElderlyCareCompanionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserElderlyCareCompanions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserElderlyCareCompanions
     * const userElderlyCareCompanions = await prisma.userElderlyCareCompanion.findMany()
     * 
     * // Get first 10 UserElderlyCareCompanions
     * const userElderlyCareCompanions = await prisma.userElderlyCareCompanion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userElderlyCareCompanionWithIdOnly = await prisma.userElderlyCareCompanion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserElderlyCareCompanionFindManyArgs>(args?: SelectSubset<T, UserElderlyCareCompanionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserElderlyCareCompanion.
     * @param {UserElderlyCareCompanionCreateArgs} args - Arguments to create a UserElderlyCareCompanion.
     * @example
     * // Create one UserElderlyCareCompanion
     * const UserElderlyCareCompanion = await prisma.userElderlyCareCompanion.create({
     *   data: {
     *     // ... data to create a UserElderlyCareCompanion
     *   }
     * })
     * 
     */
    create<T extends UserElderlyCareCompanionCreateArgs>(args: SelectSubset<T, UserElderlyCareCompanionCreateArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserElderlyCareCompanions.
     * @param {UserElderlyCareCompanionCreateManyArgs} args - Arguments to create many UserElderlyCareCompanions.
     * @example
     * // Create many UserElderlyCareCompanions
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserElderlyCareCompanionCreateManyArgs>(args?: SelectSubset<T, UserElderlyCareCompanionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserElderlyCareCompanions and returns the data saved in the database.
     * @param {UserElderlyCareCompanionCreateManyAndReturnArgs} args - Arguments to create many UserElderlyCareCompanions.
     * @example
     * // Create many UserElderlyCareCompanions
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserElderlyCareCompanions and only return the `id`
     * const userElderlyCareCompanionWithIdOnly = await prisma.userElderlyCareCompanion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserElderlyCareCompanionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserElderlyCareCompanionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserElderlyCareCompanion.
     * @param {UserElderlyCareCompanionDeleteArgs} args - Arguments to delete one UserElderlyCareCompanion.
     * @example
     * // Delete one UserElderlyCareCompanion
     * const UserElderlyCareCompanion = await prisma.userElderlyCareCompanion.delete({
     *   where: {
     *     // ... filter to delete one UserElderlyCareCompanion
     *   }
     * })
     * 
     */
    delete<T extends UserElderlyCareCompanionDeleteArgs>(args: SelectSubset<T, UserElderlyCareCompanionDeleteArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserElderlyCareCompanion.
     * @param {UserElderlyCareCompanionUpdateArgs} args - Arguments to update one UserElderlyCareCompanion.
     * @example
     * // Update one UserElderlyCareCompanion
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserElderlyCareCompanionUpdateArgs>(args: SelectSubset<T, UserElderlyCareCompanionUpdateArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserElderlyCareCompanions.
     * @param {UserElderlyCareCompanionDeleteManyArgs} args - Arguments to filter UserElderlyCareCompanions to delete.
     * @example
     * // Delete a few UserElderlyCareCompanions
     * const { count } = await prisma.userElderlyCareCompanion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserElderlyCareCompanionDeleteManyArgs>(args?: SelectSubset<T, UserElderlyCareCompanionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserElderlyCareCompanions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserElderlyCareCompanions
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserElderlyCareCompanionUpdateManyArgs>(args: SelectSubset<T, UserElderlyCareCompanionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserElderlyCareCompanions and returns the data updated in the database.
     * @param {UserElderlyCareCompanionUpdateManyAndReturnArgs} args - Arguments to update many UserElderlyCareCompanions.
     * @example
     * // Update many UserElderlyCareCompanions
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserElderlyCareCompanions and only return the `id`
     * const userElderlyCareCompanionWithIdOnly = await prisma.userElderlyCareCompanion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserElderlyCareCompanionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserElderlyCareCompanionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserElderlyCareCompanion.
     * @param {UserElderlyCareCompanionUpsertArgs} args - Arguments to update or create a UserElderlyCareCompanion.
     * @example
     * // Update or create a UserElderlyCareCompanion
     * const userElderlyCareCompanion = await prisma.userElderlyCareCompanion.upsert({
     *   create: {
     *     // ... data to create a UserElderlyCareCompanion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserElderlyCareCompanion we want to update
     *   }
     * })
     */
    upsert<T extends UserElderlyCareCompanionUpsertArgs>(args: SelectSubset<T, UserElderlyCareCompanionUpsertArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserElderlyCareCompanions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionCountArgs} args - Arguments to filter UserElderlyCareCompanions to count.
     * @example
     * // Count the number of UserElderlyCareCompanions
     * const count = await prisma.userElderlyCareCompanion.count({
     *   where: {
     *     // ... the filter for the UserElderlyCareCompanions we want to count
     *   }
     * })
    **/
    count<T extends UserElderlyCareCompanionCountArgs>(
      args?: Subset<T, UserElderlyCareCompanionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserElderlyCareCompanionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserElderlyCareCompanion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserElderlyCareCompanionAggregateArgs>(args: Subset<T, UserElderlyCareCompanionAggregateArgs>): Prisma.PrismaPromise<GetUserElderlyCareCompanionAggregateType<T>>

    /**
     * Group by UserElderlyCareCompanion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserElderlyCareCompanionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserElderlyCareCompanionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserElderlyCareCompanionGroupByArgs['orderBy'] }
        : { orderBy?: UserElderlyCareCompanionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserElderlyCareCompanionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserElderlyCareCompanionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserElderlyCareCompanion model
   */
  readonly fields: UserElderlyCareCompanionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserElderlyCareCompanion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserElderlyCareCompanionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ElderlyCareCompanionAppointment<T extends UserElderlyCareCompanion$ElderlyCareCompanionAppointmentArgs<ExtArgs> = {}>(args?: Subset<T, UserElderlyCareCompanion$ElderlyCareCompanionAppointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ElderlyCareCompanionRecord<T extends UserElderlyCareCompanion$ElderlyCareCompanionRecordArgs<ExtArgs> = {}>(args?: Subset<T, UserElderlyCareCompanion$ElderlyCareCompanionRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ElderlyCareCompanionMedicationTracking<T extends UserElderlyCareCompanion$ElderlyCareCompanionMedicationTrackingArgs<ExtArgs> = {}>(args?: Subset<T, UserElderlyCareCompanion$ElderlyCareCompanionMedicationTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserElderlyCareCompanion model
   */ 
  interface UserElderlyCareCompanionFieldRefs {
    readonly id: FieldRef<"UserElderlyCareCompanion", 'String'>
    readonly email: FieldRef<"UserElderlyCareCompanion", 'String'>
    readonly name: FieldRef<"UserElderlyCareCompanion", 'String'>
    readonly password: FieldRef<"UserElderlyCareCompanion", 'String'>
    readonly createdAt: FieldRef<"UserElderlyCareCompanion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserElderlyCareCompanion findUnique
   */
  export type UserElderlyCareCompanionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * Filter, which UserElderlyCareCompanion to fetch.
     */
    where: UserElderlyCareCompanionWhereUniqueInput
  }

  /**
   * UserElderlyCareCompanion findUniqueOrThrow
   */
  export type UserElderlyCareCompanionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * Filter, which UserElderlyCareCompanion to fetch.
     */
    where: UserElderlyCareCompanionWhereUniqueInput
  }

  /**
   * UserElderlyCareCompanion findFirst
   */
  export type UserElderlyCareCompanionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * Filter, which UserElderlyCareCompanion to fetch.
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserElderlyCareCompanions to fetch.
     */
    orderBy?: UserElderlyCareCompanionOrderByWithRelationInput | UserElderlyCareCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserElderlyCareCompanions.
     */
    cursor?: UserElderlyCareCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserElderlyCareCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserElderlyCareCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserElderlyCareCompanions.
     */
    distinct?: UserElderlyCareCompanionScalarFieldEnum | UserElderlyCareCompanionScalarFieldEnum[]
  }

  /**
   * UserElderlyCareCompanion findFirstOrThrow
   */
  export type UserElderlyCareCompanionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * Filter, which UserElderlyCareCompanion to fetch.
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserElderlyCareCompanions to fetch.
     */
    orderBy?: UserElderlyCareCompanionOrderByWithRelationInput | UserElderlyCareCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserElderlyCareCompanions.
     */
    cursor?: UserElderlyCareCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserElderlyCareCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserElderlyCareCompanions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserElderlyCareCompanions.
     */
    distinct?: UserElderlyCareCompanionScalarFieldEnum | UserElderlyCareCompanionScalarFieldEnum[]
  }

  /**
   * UserElderlyCareCompanion findMany
   */
  export type UserElderlyCareCompanionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * Filter, which UserElderlyCareCompanions to fetch.
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserElderlyCareCompanions to fetch.
     */
    orderBy?: UserElderlyCareCompanionOrderByWithRelationInput | UserElderlyCareCompanionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserElderlyCareCompanions.
     */
    cursor?: UserElderlyCareCompanionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserElderlyCareCompanions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserElderlyCareCompanions.
     */
    skip?: number
    distinct?: UserElderlyCareCompanionScalarFieldEnum | UserElderlyCareCompanionScalarFieldEnum[]
  }

  /**
   * UserElderlyCareCompanion create
   */
  export type UserElderlyCareCompanionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserElderlyCareCompanion.
     */
    data: XOR<UserElderlyCareCompanionCreateInput, UserElderlyCareCompanionUncheckedCreateInput>
  }

  /**
   * UserElderlyCareCompanion createMany
   */
  export type UserElderlyCareCompanionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserElderlyCareCompanions.
     */
    data: UserElderlyCareCompanionCreateManyInput | UserElderlyCareCompanionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserElderlyCareCompanion createManyAndReturn
   */
  export type UserElderlyCareCompanionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * The data used to create many UserElderlyCareCompanions.
     */
    data: UserElderlyCareCompanionCreateManyInput | UserElderlyCareCompanionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserElderlyCareCompanion update
   */
  export type UserElderlyCareCompanionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserElderlyCareCompanion.
     */
    data: XOR<UserElderlyCareCompanionUpdateInput, UserElderlyCareCompanionUncheckedUpdateInput>
    /**
     * Choose, which UserElderlyCareCompanion to update.
     */
    where: UserElderlyCareCompanionWhereUniqueInput
  }

  /**
   * UserElderlyCareCompanion updateMany
   */
  export type UserElderlyCareCompanionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserElderlyCareCompanions.
     */
    data: XOR<UserElderlyCareCompanionUpdateManyMutationInput, UserElderlyCareCompanionUncheckedUpdateManyInput>
    /**
     * Filter which UserElderlyCareCompanions to update
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * Limit how many UserElderlyCareCompanions to update.
     */
    limit?: number
  }

  /**
   * UserElderlyCareCompanion updateManyAndReturn
   */
  export type UserElderlyCareCompanionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * The data used to update UserElderlyCareCompanions.
     */
    data: XOR<UserElderlyCareCompanionUpdateManyMutationInput, UserElderlyCareCompanionUncheckedUpdateManyInput>
    /**
     * Filter which UserElderlyCareCompanions to update
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * Limit how many UserElderlyCareCompanions to update.
     */
    limit?: number
  }

  /**
   * UserElderlyCareCompanion upsert
   */
  export type UserElderlyCareCompanionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserElderlyCareCompanion to update in case it exists.
     */
    where: UserElderlyCareCompanionWhereUniqueInput
    /**
     * In case the UserElderlyCareCompanion found by the `where` argument doesn't exist, create a new UserElderlyCareCompanion with this data.
     */
    create: XOR<UserElderlyCareCompanionCreateInput, UserElderlyCareCompanionUncheckedCreateInput>
    /**
     * In case the UserElderlyCareCompanion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserElderlyCareCompanionUpdateInput, UserElderlyCareCompanionUncheckedUpdateInput>
  }

  /**
   * UserElderlyCareCompanion delete
   */
  export type UserElderlyCareCompanionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
    /**
     * Filter which UserElderlyCareCompanion to delete.
     */
    where: UserElderlyCareCompanionWhereUniqueInput
  }

  /**
   * UserElderlyCareCompanion deleteMany
   */
  export type UserElderlyCareCompanionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserElderlyCareCompanions to delete
     */
    where?: UserElderlyCareCompanionWhereInput
    /**
     * Limit how many UserElderlyCareCompanions to delete.
     */
    limit?: number
  }

  /**
   * UserElderlyCareCompanion.ElderlyCareCompanionAppointment
   */
  export type UserElderlyCareCompanion$ElderlyCareCompanionAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    where?: ElderlyCareCompanionAppointmentWhereInput
    orderBy?: ElderlyCareCompanionAppointmentOrderByWithRelationInput | ElderlyCareCompanionAppointmentOrderByWithRelationInput[]
    cursor?: ElderlyCareCompanionAppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElderlyCareCompanionAppointmentScalarFieldEnum | ElderlyCareCompanionAppointmentScalarFieldEnum[]
  }

  /**
   * UserElderlyCareCompanion.ElderlyCareCompanionRecord
   */
  export type UserElderlyCareCompanion$ElderlyCareCompanionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    where?: ElderlyCareCompanionRecordWhereInput
    orderBy?: ElderlyCareCompanionRecordOrderByWithRelationInput | ElderlyCareCompanionRecordOrderByWithRelationInput[]
    cursor?: ElderlyCareCompanionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElderlyCareCompanionRecordScalarFieldEnum | ElderlyCareCompanionRecordScalarFieldEnum[]
  }

  /**
   * UserElderlyCareCompanion.ElderlyCareCompanionMedicationTracking
   */
  export type UserElderlyCareCompanion$ElderlyCareCompanionMedicationTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput | ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput[]
    cursor?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElderlyCareCompanionMedicationTrackingScalarFieldEnum | ElderlyCareCompanionMedicationTrackingScalarFieldEnum[]
  }

  /**
   * UserElderlyCareCompanion without action
   */
  export type UserElderlyCareCompanionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserElderlyCareCompanion
     */
    select?: UserElderlyCareCompanionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserElderlyCareCompanion
     */
    omit?: UserElderlyCareCompanionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserElderlyCareCompanionInclude<ExtArgs> | null
  }


  /**
   * Model ElderlyCareCompanionAppointment
   */

  export type AggregateElderlyCareCompanionAppointment = {
    _count: ElderlyCareCompanionAppointmentCountAggregateOutputType | null
    _min: ElderlyCareCompanionAppointmentMinAggregateOutputType | null
    _max: ElderlyCareCompanionAppointmentMaxAggregateOutputType | null
  }

  export type ElderlyCareCompanionAppointmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    dateTime: Date | null
    location: string | null
    medicationDetails: string | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionAppointmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    dateTime: Date | null
    location: string | null
    medicationDetails: string | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionAppointmentCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    dateTime: number
    location: number
    medicationDetails: number
    createdAt: number
    _all: number
  }


  export type ElderlyCareCompanionAppointmentMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    dateTime?: true
    location?: true
    medicationDetails?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionAppointmentMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    dateTime?: true
    location?: true
    medicationDetails?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionAppointmentCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    dateTime?: true
    location?: true
    medicationDetails?: true
    createdAt?: true
    _all?: true
  }

  export type ElderlyCareCompanionAppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionAppointment to aggregate.
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionAppointments to fetch.
     */
    orderBy?: ElderlyCareCompanionAppointmentOrderByWithRelationInput | ElderlyCareCompanionAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElderlyCareCompanionAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElderlyCareCompanionAppointments
    **/
    _count?: true | ElderlyCareCompanionAppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElderlyCareCompanionAppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElderlyCareCompanionAppointmentMaxAggregateInputType
  }

  export type GetElderlyCareCompanionAppointmentAggregateType<T extends ElderlyCareCompanionAppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateElderlyCareCompanionAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElderlyCareCompanionAppointment[P]>
      : GetScalarType<T[P], AggregateElderlyCareCompanionAppointment[P]>
  }




  export type ElderlyCareCompanionAppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionAppointmentWhereInput
    orderBy?: ElderlyCareCompanionAppointmentOrderByWithAggregationInput | ElderlyCareCompanionAppointmentOrderByWithAggregationInput[]
    by: ElderlyCareCompanionAppointmentScalarFieldEnum[] | ElderlyCareCompanionAppointmentScalarFieldEnum
    having?: ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElderlyCareCompanionAppointmentCountAggregateInputType | true
    _min?: ElderlyCareCompanionAppointmentMinAggregateInputType
    _max?: ElderlyCareCompanionAppointmentMaxAggregateInputType
  }

  export type ElderlyCareCompanionAppointmentGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    dateTime: Date
    location: string | null
    medicationDetails: string | null
    createdAt: Date
    _count: ElderlyCareCompanionAppointmentCountAggregateOutputType | null
    _min: ElderlyCareCompanionAppointmentMinAggregateOutputType | null
    _max: ElderlyCareCompanionAppointmentMaxAggregateOutputType | null
  }

  type GetElderlyCareCompanionAppointmentGroupByPayload<T extends ElderlyCareCompanionAppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElderlyCareCompanionAppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElderlyCareCompanionAppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElderlyCareCompanionAppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], ElderlyCareCompanionAppointmentGroupByOutputType[P]>
        }
      >
    >


  export type ElderlyCareCompanionAppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    dateTime?: boolean
    location?: boolean
    medicationDetails?: boolean
    createdAt?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medicationLogs?: boolean | ElderlyCareCompanionAppointment$medicationLogsArgs<ExtArgs>
    _count?: boolean | ElderlyCareCompanionAppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionAppointment"]>

  export type ElderlyCareCompanionAppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    dateTime?: boolean
    location?: boolean
    medicationDetails?: boolean
    createdAt?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionAppointment"]>

  export type ElderlyCareCompanionAppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    dateTime?: boolean
    location?: boolean
    medicationDetails?: boolean
    createdAt?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionAppointment"]>

  export type ElderlyCareCompanionAppointmentSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    dateTime?: boolean
    location?: boolean
    medicationDetails?: boolean
    createdAt?: boolean
  }

  export type ElderlyCareCompanionAppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "dateTime" | "location" | "medicationDetails" | "createdAt", ExtArgs["result"]["elderlyCareCompanionAppointment"]>
  export type ElderlyCareCompanionAppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medicationLogs?: boolean | ElderlyCareCompanionAppointment$medicationLogsArgs<ExtArgs>
    _count?: boolean | ElderlyCareCompanionAppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ElderlyCareCompanionAppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }
  export type ElderlyCareCompanionAppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }

  export type $ElderlyCareCompanionAppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElderlyCareCompanionAppointment"
    objects: {
      user: Prisma.$UserElderlyCareCompanionPayload<ExtArgs>
      medicationLogs: Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      dateTime: Date
      location: string | null
      medicationDetails: string | null
      createdAt: Date
    }, ExtArgs["result"]["elderlyCareCompanionAppointment"]>
    composites: {}
  }

  type ElderlyCareCompanionAppointmentGetPayload<S extends boolean | null | undefined | ElderlyCareCompanionAppointmentDefaultArgs> = $Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload, S>

  type ElderlyCareCompanionAppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElderlyCareCompanionAppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElderlyCareCompanionAppointmentCountAggregateInputType | true
    }

  export interface ElderlyCareCompanionAppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElderlyCareCompanionAppointment'], meta: { name: 'ElderlyCareCompanionAppointment' } }
    /**
     * Find zero or one ElderlyCareCompanionAppointment that matches the filter.
     * @param {ElderlyCareCompanionAppointmentFindUniqueArgs} args - Arguments to find a ElderlyCareCompanionAppointment
     * @example
     * // Get one ElderlyCareCompanionAppointment
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElderlyCareCompanionAppointmentFindUniqueArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentFindUniqueArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElderlyCareCompanionAppointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElderlyCareCompanionAppointmentFindUniqueOrThrowArgs} args - Arguments to find a ElderlyCareCompanionAppointment
     * @example
     * // Get one ElderlyCareCompanionAppointment
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElderlyCareCompanionAppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionAppointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentFindFirstArgs} args - Arguments to find a ElderlyCareCompanionAppointment
     * @example
     * // Get one ElderlyCareCompanionAppointment
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElderlyCareCompanionAppointmentFindFirstArgs>(args?: SelectSubset<T, ElderlyCareCompanionAppointmentFindFirstArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionAppointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentFindFirstOrThrowArgs} args - Arguments to find a ElderlyCareCompanionAppointment
     * @example
     * // Get one ElderlyCareCompanionAppointment
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElderlyCareCompanionAppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ElderlyCareCompanionAppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElderlyCareCompanionAppointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElderlyCareCompanionAppointments
     * const elderlyCareCompanionAppointments = await prisma.elderlyCareCompanionAppointment.findMany()
     * 
     * // Get first 10 ElderlyCareCompanionAppointments
     * const elderlyCareCompanionAppointments = await prisma.elderlyCareCompanionAppointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elderlyCareCompanionAppointmentWithIdOnly = await prisma.elderlyCareCompanionAppointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElderlyCareCompanionAppointmentFindManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionAppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElderlyCareCompanionAppointment.
     * @param {ElderlyCareCompanionAppointmentCreateArgs} args - Arguments to create a ElderlyCareCompanionAppointment.
     * @example
     * // Create one ElderlyCareCompanionAppointment
     * const ElderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.create({
     *   data: {
     *     // ... data to create a ElderlyCareCompanionAppointment
     *   }
     * })
     * 
     */
    create<T extends ElderlyCareCompanionAppointmentCreateArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentCreateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElderlyCareCompanionAppointments.
     * @param {ElderlyCareCompanionAppointmentCreateManyArgs} args - Arguments to create many ElderlyCareCompanionAppointments.
     * @example
     * // Create many ElderlyCareCompanionAppointments
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElderlyCareCompanionAppointmentCreateManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionAppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElderlyCareCompanionAppointments and returns the data saved in the database.
     * @param {ElderlyCareCompanionAppointmentCreateManyAndReturnArgs} args - Arguments to create many ElderlyCareCompanionAppointments.
     * @example
     * // Create many ElderlyCareCompanionAppointments
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElderlyCareCompanionAppointments and only return the `id`
     * const elderlyCareCompanionAppointmentWithIdOnly = await prisma.elderlyCareCompanionAppointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElderlyCareCompanionAppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ElderlyCareCompanionAppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElderlyCareCompanionAppointment.
     * @param {ElderlyCareCompanionAppointmentDeleteArgs} args - Arguments to delete one ElderlyCareCompanionAppointment.
     * @example
     * // Delete one ElderlyCareCompanionAppointment
     * const ElderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.delete({
     *   where: {
     *     // ... filter to delete one ElderlyCareCompanionAppointment
     *   }
     * })
     * 
     */
    delete<T extends ElderlyCareCompanionAppointmentDeleteArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentDeleteArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElderlyCareCompanionAppointment.
     * @param {ElderlyCareCompanionAppointmentUpdateArgs} args - Arguments to update one ElderlyCareCompanionAppointment.
     * @example
     * // Update one ElderlyCareCompanionAppointment
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElderlyCareCompanionAppointmentUpdateArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentUpdateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElderlyCareCompanionAppointments.
     * @param {ElderlyCareCompanionAppointmentDeleteManyArgs} args - Arguments to filter ElderlyCareCompanionAppointments to delete.
     * @example
     * // Delete a few ElderlyCareCompanionAppointments
     * const { count } = await prisma.elderlyCareCompanionAppointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElderlyCareCompanionAppointmentDeleteManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionAppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElderlyCareCompanionAppointments
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElderlyCareCompanionAppointmentUpdateManyArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionAppointments and returns the data updated in the database.
     * @param {ElderlyCareCompanionAppointmentUpdateManyAndReturnArgs} args - Arguments to update many ElderlyCareCompanionAppointments.
     * @example
     * // Update many ElderlyCareCompanionAppointments
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElderlyCareCompanionAppointments and only return the `id`
     * const elderlyCareCompanionAppointmentWithIdOnly = await prisma.elderlyCareCompanionAppointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElderlyCareCompanionAppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElderlyCareCompanionAppointment.
     * @param {ElderlyCareCompanionAppointmentUpsertArgs} args - Arguments to update or create a ElderlyCareCompanionAppointment.
     * @example
     * // Update or create a ElderlyCareCompanionAppointment
     * const elderlyCareCompanionAppointment = await prisma.elderlyCareCompanionAppointment.upsert({
     *   create: {
     *     // ... data to create a ElderlyCareCompanionAppointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionAppointment we want to update
     *   }
     * })
     */
    upsert<T extends ElderlyCareCompanionAppointmentUpsertArgs>(args: SelectSubset<T, ElderlyCareCompanionAppointmentUpsertArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElderlyCareCompanionAppointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentCountArgs} args - Arguments to filter ElderlyCareCompanionAppointments to count.
     * @example
     * // Count the number of ElderlyCareCompanionAppointments
     * const count = await prisma.elderlyCareCompanionAppointment.count({
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionAppointments we want to count
     *   }
     * })
    **/
    count<T extends ElderlyCareCompanionAppointmentCountArgs>(
      args?: Subset<T, ElderlyCareCompanionAppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElderlyCareCompanionAppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElderlyCareCompanionAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElderlyCareCompanionAppointmentAggregateArgs>(args: Subset<T, ElderlyCareCompanionAppointmentAggregateArgs>): Prisma.PrismaPromise<GetElderlyCareCompanionAppointmentAggregateType<T>>

    /**
     * Group by ElderlyCareCompanionAppointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionAppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElderlyCareCompanionAppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElderlyCareCompanionAppointmentGroupByArgs['orderBy'] }
        : { orderBy?: ElderlyCareCompanionAppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElderlyCareCompanionAppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElderlyCareCompanionAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElderlyCareCompanionAppointment model
   */
  readonly fields: ElderlyCareCompanionAppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElderlyCareCompanionAppointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElderlyCareCompanionAppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserElderlyCareCompanionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserElderlyCareCompanionDefaultArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicationLogs<T extends ElderlyCareCompanionAppointment$medicationLogsArgs<ExtArgs> = {}>(args?: Subset<T, ElderlyCareCompanionAppointment$medicationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElderlyCareCompanionAppointment model
   */ 
  interface ElderlyCareCompanionAppointmentFieldRefs {
    readonly id: FieldRef<"ElderlyCareCompanionAppointment", 'String'>
    readonly userId: FieldRef<"ElderlyCareCompanionAppointment", 'String'>
    readonly type: FieldRef<"ElderlyCareCompanionAppointment", 'String'>
    readonly title: FieldRef<"ElderlyCareCompanionAppointment", 'String'>
    readonly dateTime: FieldRef<"ElderlyCareCompanionAppointment", 'DateTime'>
    readonly location: FieldRef<"ElderlyCareCompanionAppointment", 'String'>
    readonly medicationDetails: FieldRef<"ElderlyCareCompanionAppointment", 'String'>
    readonly createdAt: FieldRef<"ElderlyCareCompanionAppointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElderlyCareCompanionAppointment findUnique
   */
  export type ElderlyCareCompanionAppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionAppointment to fetch.
     */
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionAppointment findUniqueOrThrow
   */
  export type ElderlyCareCompanionAppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionAppointment to fetch.
     */
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionAppointment findFirst
   */
  export type ElderlyCareCompanionAppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionAppointment to fetch.
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionAppointments to fetch.
     */
    orderBy?: ElderlyCareCompanionAppointmentOrderByWithRelationInput | ElderlyCareCompanionAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionAppointments.
     */
    cursor?: ElderlyCareCompanionAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionAppointments.
     */
    distinct?: ElderlyCareCompanionAppointmentScalarFieldEnum | ElderlyCareCompanionAppointmentScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionAppointment findFirstOrThrow
   */
  export type ElderlyCareCompanionAppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionAppointment to fetch.
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionAppointments to fetch.
     */
    orderBy?: ElderlyCareCompanionAppointmentOrderByWithRelationInput | ElderlyCareCompanionAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionAppointments.
     */
    cursor?: ElderlyCareCompanionAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionAppointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionAppointments.
     */
    distinct?: ElderlyCareCompanionAppointmentScalarFieldEnum | ElderlyCareCompanionAppointmentScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionAppointment findMany
   */
  export type ElderlyCareCompanionAppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionAppointments to fetch.
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionAppointments to fetch.
     */
    orderBy?: ElderlyCareCompanionAppointmentOrderByWithRelationInput | ElderlyCareCompanionAppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElderlyCareCompanionAppointments.
     */
    cursor?: ElderlyCareCompanionAppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionAppointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionAppointments.
     */
    skip?: number
    distinct?: ElderlyCareCompanionAppointmentScalarFieldEnum | ElderlyCareCompanionAppointmentScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionAppointment create
   */
  export type ElderlyCareCompanionAppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ElderlyCareCompanionAppointment.
     */
    data: XOR<ElderlyCareCompanionAppointmentCreateInput, ElderlyCareCompanionAppointmentUncheckedCreateInput>
  }

  /**
   * ElderlyCareCompanionAppointment createMany
   */
  export type ElderlyCareCompanionAppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElderlyCareCompanionAppointments.
     */
    data: ElderlyCareCompanionAppointmentCreateManyInput | ElderlyCareCompanionAppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionAppointment createManyAndReturn
   */
  export type ElderlyCareCompanionAppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many ElderlyCareCompanionAppointments.
     */
    data: ElderlyCareCompanionAppointmentCreateManyInput | ElderlyCareCompanionAppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionAppointment update
   */
  export type ElderlyCareCompanionAppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ElderlyCareCompanionAppointment.
     */
    data: XOR<ElderlyCareCompanionAppointmentUpdateInput, ElderlyCareCompanionAppointmentUncheckedUpdateInput>
    /**
     * Choose, which ElderlyCareCompanionAppointment to update.
     */
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionAppointment updateMany
   */
  export type ElderlyCareCompanionAppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElderlyCareCompanionAppointments.
     */
    data: XOR<ElderlyCareCompanionAppointmentUpdateManyMutationInput, ElderlyCareCompanionAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionAppointments to update
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * Limit how many ElderlyCareCompanionAppointments to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionAppointment updateManyAndReturn
   */
  export type ElderlyCareCompanionAppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * The data used to update ElderlyCareCompanionAppointments.
     */
    data: XOR<ElderlyCareCompanionAppointmentUpdateManyMutationInput, ElderlyCareCompanionAppointmentUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionAppointments to update
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * Limit how many ElderlyCareCompanionAppointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionAppointment upsert
   */
  export type ElderlyCareCompanionAppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ElderlyCareCompanionAppointment to update in case it exists.
     */
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
    /**
     * In case the ElderlyCareCompanionAppointment found by the `where` argument doesn't exist, create a new ElderlyCareCompanionAppointment with this data.
     */
    create: XOR<ElderlyCareCompanionAppointmentCreateInput, ElderlyCareCompanionAppointmentUncheckedCreateInput>
    /**
     * In case the ElderlyCareCompanionAppointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElderlyCareCompanionAppointmentUpdateInput, ElderlyCareCompanionAppointmentUncheckedUpdateInput>
  }

  /**
   * ElderlyCareCompanionAppointment delete
   */
  export type ElderlyCareCompanionAppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
    /**
     * Filter which ElderlyCareCompanionAppointment to delete.
     */
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionAppointment deleteMany
   */
  export type ElderlyCareCompanionAppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionAppointments to delete
     */
    where?: ElderlyCareCompanionAppointmentWhereInput
    /**
     * Limit how many ElderlyCareCompanionAppointments to delete.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionAppointment.medicationLogs
   */
  export type ElderlyCareCompanionAppointment$medicationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput | ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput[]
    cursor?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElderlyCareCompanionMedicationTrackingScalarFieldEnum | ElderlyCareCompanionMedicationTrackingScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionAppointment without action
   */
  export type ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionAppointment
     */
    select?: ElderlyCareCompanionAppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionAppointment
     */
    omit?: ElderlyCareCompanionAppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionAppointmentInclude<ExtArgs> | null
  }


  /**
   * Model ElderlyCareCompanionClinic
   */

  export type AggregateElderlyCareCompanionClinic = {
    _count: ElderlyCareCompanionClinicCountAggregateOutputType | null
    _min: ElderlyCareCompanionClinicMinAggregateOutputType | null
    _max: ElderlyCareCompanionClinicMaxAggregateOutputType | null
  }

  export type ElderlyCareCompanionClinicMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionClinicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionClinicCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    _all: number
  }


  export type ElderlyCareCompanionClinicMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionClinicMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionClinicCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    _all?: true
  }

  export type ElderlyCareCompanionClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionClinic to aggregate.
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionClinics to fetch.
     */
    orderBy?: ElderlyCareCompanionClinicOrderByWithRelationInput | ElderlyCareCompanionClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElderlyCareCompanionClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionClinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionClinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElderlyCareCompanionClinics
    **/
    _count?: true | ElderlyCareCompanionClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElderlyCareCompanionClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElderlyCareCompanionClinicMaxAggregateInputType
  }

  export type GetElderlyCareCompanionClinicAggregateType<T extends ElderlyCareCompanionClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateElderlyCareCompanionClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElderlyCareCompanionClinic[P]>
      : GetScalarType<T[P], AggregateElderlyCareCompanionClinic[P]>
  }




  export type ElderlyCareCompanionClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionClinicWhereInput
    orderBy?: ElderlyCareCompanionClinicOrderByWithAggregationInput | ElderlyCareCompanionClinicOrderByWithAggregationInput[]
    by: ElderlyCareCompanionClinicScalarFieldEnum[] | ElderlyCareCompanionClinicScalarFieldEnum
    having?: ElderlyCareCompanionClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElderlyCareCompanionClinicCountAggregateInputType | true
    _min?: ElderlyCareCompanionClinicMinAggregateInputType
    _max?: ElderlyCareCompanionClinicMaxAggregateInputType
  }

  export type ElderlyCareCompanionClinicGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string
    createdAt: Date
    _count: ElderlyCareCompanionClinicCountAggregateOutputType | null
    _min: ElderlyCareCompanionClinicMinAggregateOutputType | null
    _max: ElderlyCareCompanionClinicMaxAggregateOutputType | null
  }

  type GetElderlyCareCompanionClinicGroupByPayload<T extends ElderlyCareCompanionClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElderlyCareCompanionClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElderlyCareCompanionClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElderlyCareCompanionClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ElderlyCareCompanionClinicGroupByOutputType[P]>
        }
      >
    >


  export type ElderlyCareCompanionClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["elderlyCareCompanionClinic"]>

  export type ElderlyCareCompanionClinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["elderlyCareCompanionClinic"]>

  export type ElderlyCareCompanionClinicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["elderlyCareCompanionClinic"]>

  export type ElderlyCareCompanionClinicSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }

  export type ElderlyCareCompanionClinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "createdAt", ExtArgs["result"]["elderlyCareCompanionClinic"]>

  export type $ElderlyCareCompanionClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElderlyCareCompanionClinic"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string
      createdAt: Date
    }, ExtArgs["result"]["elderlyCareCompanionClinic"]>
    composites: {}
  }

  type ElderlyCareCompanionClinicGetPayload<S extends boolean | null | undefined | ElderlyCareCompanionClinicDefaultArgs> = $Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload, S>

  type ElderlyCareCompanionClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElderlyCareCompanionClinicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElderlyCareCompanionClinicCountAggregateInputType | true
    }

  export interface ElderlyCareCompanionClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElderlyCareCompanionClinic'], meta: { name: 'ElderlyCareCompanionClinic' } }
    /**
     * Find zero or one ElderlyCareCompanionClinic that matches the filter.
     * @param {ElderlyCareCompanionClinicFindUniqueArgs} args - Arguments to find a ElderlyCareCompanionClinic
     * @example
     * // Get one ElderlyCareCompanionClinic
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElderlyCareCompanionClinicFindUniqueArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicFindUniqueArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElderlyCareCompanionClinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElderlyCareCompanionClinicFindUniqueOrThrowArgs} args - Arguments to find a ElderlyCareCompanionClinic
     * @example
     * // Get one ElderlyCareCompanionClinic
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElderlyCareCompanionClinicFindUniqueOrThrowArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionClinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicFindFirstArgs} args - Arguments to find a ElderlyCareCompanionClinic
     * @example
     * // Get one ElderlyCareCompanionClinic
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElderlyCareCompanionClinicFindFirstArgs>(args?: SelectSubset<T, ElderlyCareCompanionClinicFindFirstArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionClinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicFindFirstOrThrowArgs} args - Arguments to find a ElderlyCareCompanionClinic
     * @example
     * // Get one ElderlyCareCompanionClinic
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElderlyCareCompanionClinicFindFirstOrThrowArgs>(args?: SelectSubset<T, ElderlyCareCompanionClinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElderlyCareCompanionClinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElderlyCareCompanionClinics
     * const elderlyCareCompanionClinics = await prisma.elderlyCareCompanionClinic.findMany()
     * 
     * // Get first 10 ElderlyCareCompanionClinics
     * const elderlyCareCompanionClinics = await prisma.elderlyCareCompanionClinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elderlyCareCompanionClinicWithIdOnly = await prisma.elderlyCareCompanionClinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElderlyCareCompanionClinicFindManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionClinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElderlyCareCompanionClinic.
     * @param {ElderlyCareCompanionClinicCreateArgs} args - Arguments to create a ElderlyCareCompanionClinic.
     * @example
     * // Create one ElderlyCareCompanionClinic
     * const ElderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.create({
     *   data: {
     *     // ... data to create a ElderlyCareCompanionClinic
     *   }
     * })
     * 
     */
    create<T extends ElderlyCareCompanionClinicCreateArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicCreateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElderlyCareCompanionClinics.
     * @param {ElderlyCareCompanionClinicCreateManyArgs} args - Arguments to create many ElderlyCareCompanionClinics.
     * @example
     * // Create many ElderlyCareCompanionClinics
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElderlyCareCompanionClinicCreateManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionClinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElderlyCareCompanionClinics and returns the data saved in the database.
     * @param {ElderlyCareCompanionClinicCreateManyAndReturnArgs} args - Arguments to create many ElderlyCareCompanionClinics.
     * @example
     * // Create many ElderlyCareCompanionClinics
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElderlyCareCompanionClinics and only return the `id`
     * const elderlyCareCompanionClinicWithIdOnly = await prisma.elderlyCareCompanionClinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElderlyCareCompanionClinicCreateManyAndReturnArgs>(args?: SelectSubset<T, ElderlyCareCompanionClinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElderlyCareCompanionClinic.
     * @param {ElderlyCareCompanionClinicDeleteArgs} args - Arguments to delete one ElderlyCareCompanionClinic.
     * @example
     * // Delete one ElderlyCareCompanionClinic
     * const ElderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.delete({
     *   where: {
     *     // ... filter to delete one ElderlyCareCompanionClinic
     *   }
     * })
     * 
     */
    delete<T extends ElderlyCareCompanionClinicDeleteArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicDeleteArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElderlyCareCompanionClinic.
     * @param {ElderlyCareCompanionClinicUpdateArgs} args - Arguments to update one ElderlyCareCompanionClinic.
     * @example
     * // Update one ElderlyCareCompanionClinic
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElderlyCareCompanionClinicUpdateArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicUpdateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElderlyCareCompanionClinics.
     * @param {ElderlyCareCompanionClinicDeleteManyArgs} args - Arguments to filter ElderlyCareCompanionClinics to delete.
     * @example
     * // Delete a few ElderlyCareCompanionClinics
     * const { count } = await prisma.elderlyCareCompanionClinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElderlyCareCompanionClinicDeleteManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionClinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionClinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElderlyCareCompanionClinics
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElderlyCareCompanionClinicUpdateManyArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionClinics and returns the data updated in the database.
     * @param {ElderlyCareCompanionClinicUpdateManyAndReturnArgs} args - Arguments to update many ElderlyCareCompanionClinics.
     * @example
     * // Update many ElderlyCareCompanionClinics
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElderlyCareCompanionClinics and only return the `id`
     * const elderlyCareCompanionClinicWithIdOnly = await prisma.elderlyCareCompanionClinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElderlyCareCompanionClinicUpdateManyAndReturnArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElderlyCareCompanionClinic.
     * @param {ElderlyCareCompanionClinicUpsertArgs} args - Arguments to update or create a ElderlyCareCompanionClinic.
     * @example
     * // Update or create a ElderlyCareCompanionClinic
     * const elderlyCareCompanionClinic = await prisma.elderlyCareCompanionClinic.upsert({
     *   create: {
     *     // ... data to create a ElderlyCareCompanionClinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionClinic we want to update
     *   }
     * })
     */
    upsert<T extends ElderlyCareCompanionClinicUpsertArgs>(args: SelectSubset<T, ElderlyCareCompanionClinicUpsertArgs<ExtArgs>>): Prisma__ElderlyCareCompanionClinicClient<$Result.GetResult<Prisma.$ElderlyCareCompanionClinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElderlyCareCompanionClinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicCountArgs} args - Arguments to filter ElderlyCareCompanionClinics to count.
     * @example
     * // Count the number of ElderlyCareCompanionClinics
     * const count = await prisma.elderlyCareCompanionClinic.count({
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionClinics we want to count
     *   }
     * })
    **/
    count<T extends ElderlyCareCompanionClinicCountArgs>(
      args?: Subset<T, ElderlyCareCompanionClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElderlyCareCompanionClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElderlyCareCompanionClinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElderlyCareCompanionClinicAggregateArgs>(args: Subset<T, ElderlyCareCompanionClinicAggregateArgs>): Prisma.PrismaPromise<GetElderlyCareCompanionClinicAggregateType<T>>

    /**
     * Group by ElderlyCareCompanionClinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElderlyCareCompanionClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElderlyCareCompanionClinicGroupByArgs['orderBy'] }
        : { orderBy?: ElderlyCareCompanionClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElderlyCareCompanionClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElderlyCareCompanionClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElderlyCareCompanionClinic model
   */
  readonly fields: ElderlyCareCompanionClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElderlyCareCompanionClinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElderlyCareCompanionClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElderlyCareCompanionClinic model
   */ 
  interface ElderlyCareCompanionClinicFieldRefs {
    readonly id: FieldRef<"ElderlyCareCompanionClinic", 'String'>
    readonly name: FieldRef<"ElderlyCareCompanionClinic", 'String'>
    readonly address: FieldRef<"ElderlyCareCompanionClinic", 'String'>
    readonly phone: FieldRef<"ElderlyCareCompanionClinic", 'String'>
    readonly createdAt: FieldRef<"ElderlyCareCompanionClinic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElderlyCareCompanionClinic findUnique
   */
  export type ElderlyCareCompanionClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionClinic to fetch.
     */
    where: ElderlyCareCompanionClinicWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionClinic findUniqueOrThrow
   */
  export type ElderlyCareCompanionClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionClinic to fetch.
     */
    where: ElderlyCareCompanionClinicWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionClinic findFirst
   */
  export type ElderlyCareCompanionClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionClinic to fetch.
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionClinics to fetch.
     */
    orderBy?: ElderlyCareCompanionClinicOrderByWithRelationInput | ElderlyCareCompanionClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionClinics.
     */
    cursor?: ElderlyCareCompanionClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionClinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionClinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionClinics.
     */
    distinct?: ElderlyCareCompanionClinicScalarFieldEnum | ElderlyCareCompanionClinicScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionClinic findFirstOrThrow
   */
  export type ElderlyCareCompanionClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionClinic to fetch.
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionClinics to fetch.
     */
    orderBy?: ElderlyCareCompanionClinicOrderByWithRelationInput | ElderlyCareCompanionClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionClinics.
     */
    cursor?: ElderlyCareCompanionClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionClinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionClinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionClinics.
     */
    distinct?: ElderlyCareCompanionClinicScalarFieldEnum | ElderlyCareCompanionClinicScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionClinic findMany
   */
  export type ElderlyCareCompanionClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionClinics to fetch.
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionClinics to fetch.
     */
    orderBy?: ElderlyCareCompanionClinicOrderByWithRelationInput | ElderlyCareCompanionClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElderlyCareCompanionClinics.
     */
    cursor?: ElderlyCareCompanionClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionClinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionClinics.
     */
    skip?: number
    distinct?: ElderlyCareCompanionClinicScalarFieldEnum | ElderlyCareCompanionClinicScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionClinic create
   */
  export type ElderlyCareCompanionClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * The data needed to create a ElderlyCareCompanionClinic.
     */
    data: XOR<ElderlyCareCompanionClinicCreateInput, ElderlyCareCompanionClinicUncheckedCreateInput>
  }

  /**
   * ElderlyCareCompanionClinic createMany
   */
  export type ElderlyCareCompanionClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElderlyCareCompanionClinics.
     */
    data: ElderlyCareCompanionClinicCreateManyInput | ElderlyCareCompanionClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionClinic createManyAndReturn
   */
  export type ElderlyCareCompanionClinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * The data used to create many ElderlyCareCompanionClinics.
     */
    data: ElderlyCareCompanionClinicCreateManyInput | ElderlyCareCompanionClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionClinic update
   */
  export type ElderlyCareCompanionClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * The data needed to update a ElderlyCareCompanionClinic.
     */
    data: XOR<ElderlyCareCompanionClinicUpdateInput, ElderlyCareCompanionClinicUncheckedUpdateInput>
    /**
     * Choose, which ElderlyCareCompanionClinic to update.
     */
    where: ElderlyCareCompanionClinicWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionClinic updateMany
   */
  export type ElderlyCareCompanionClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElderlyCareCompanionClinics.
     */
    data: XOR<ElderlyCareCompanionClinicUpdateManyMutationInput, ElderlyCareCompanionClinicUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionClinics to update
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * Limit how many ElderlyCareCompanionClinics to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionClinic updateManyAndReturn
   */
  export type ElderlyCareCompanionClinicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * The data used to update ElderlyCareCompanionClinics.
     */
    data: XOR<ElderlyCareCompanionClinicUpdateManyMutationInput, ElderlyCareCompanionClinicUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionClinics to update
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * Limit how many ElderlyCareCompanionClinics to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionClinic upsert
   */
  export type ElderlyCareCompanionClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * The filter to search for the ElderlyCareCompanionClinic to update in case it exists.
     */
    where: ElderlyCareCompanionClinicWhereUniqueInput
    /**
     * In case the ElderlyCareCompanionClinic found by the `where` argument doesn't exist, create a new ElderlyCareCompanionClinic with this data.
     */
    create: XOR<ElderlyCareCompanionClinicCreateInput, ElderlyCareCompanionClinicUncheckedCreateInput>
    /**
     * In case the ElderlyCareCompanionClinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElderlyCareCompanionClinicUpdateInput, ElderlyCareCompanionClinicUncheckedUpdateInput>
  }

  /**
   * ElderlyCareCompanionClinic delete
   */
  export type ElderlyCareCompanionClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
    /**
     * Filter which ElderlyCareCompanionClinic to delete.
     */
    where: ElderlyCareCompanionClinicWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionClinic deleteMany
   */
  export type ElderlyCareCompanionClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionClinics to delete
     */
    where?: ElderlyCareCompanionClinicWhereInput
    /**
     * Limit how many ElderlyCareCompanionClinics to delete.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionClinic without action
   */
  export type ElderlyCareCompanionClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionClinic
     */
    select?: ElderlyCareCompanionClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionClinic
     */
    omit?: ElderlyCareCompanionClinicOmit<ExtArgs> | null
  }


  /**
   * Model ElderlyCareCompanionStore
   */

  export type AggregateElderlyCareCompanionStore = {
    _count: ElderlyCareCompanionStoreCountAggregateOutputType | null
    _min: ElderlyCareCompanionStoreMinAggregateOutputType | null
    _max: ElderlyCareCompanionStoreMaxAggregateOutputType | null
  }

  export type ElderlyCareCompanionStoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionStoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionStoreCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    createdAt: number
    _all: number
  }


  export type ElderlyCareCompanionStoreMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionStoreMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionStoreCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    createdAt?: true
    _all?: true
  }

  export type ElderlyCareCompanionStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionStore to aggregate.
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionStores to fetch.
     */
    orderBy?: ElderlyCareCompanionStoreOrderByWithRelationInput | ElderlyCareCompanionStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElderlyCareCompanionStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElderlyCareCompanionStores
    **/
    _count?: true | ElderlyCareCompanionStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElderlyCareCompanionStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElderlyCareCompanionStoreMaxAggregateInputType
  }

  export type GetElderlyCareCompanionStoreAggregateType<T extends ElderlyCareCompanionStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateElderlyCareCompanionStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElderlyCareCompanionStore[P]>
      : GetScalarType<T[P], AggregateElderlyCareCompanionStore[P]>
  }




  export type ElderlyCareCompanionStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionStoreWhereInput
    orderBy?: ElderlyCareCompanionStoreOrderByWithAggregationInput | ElderlyCareCompanionStoreOrderByWithAggregationInput[]
    by: ElderlyCareCompanionStoreScalarFieldEnum[] | ElderlyCareCompanionStoreScalarFieldEnum
    having?: ElderlyCareCompanionStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElderlyCareCompanionStoreCountAggregateInputType | true
    _min?: ElderlyCareCompanionStoreMinAggregateInputType
    _max?: ElderlyCareCompanionStoreMaxAggregateInputType
  }

  export type ElderlyCareCompanionStoreGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string
    createdAt: Date
    _count: ElderlyCareCompanionStoreCountAggregateOutputType | null
    _min: ElderlyCareCompanionStoreMinAggregateOutputType | null
    _max: ElderlyCareCompanionStoreMaxAggregateOutputType | null
  }

  type GetElderlyCareCompanionStoreGroupByPayload<T extends ElderlyCareCompanionStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElderlyCareCompanionStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElderlyCareCompanionStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElderlyCareCompanionStoreGroupByOutputType[P]>
            : GetScalarType<T[P], ElderlyCareCompanionStoreGroupByOutputType[P]>
        }
      >
    >


  export type ElderlyCareCompanionStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["elderlyCareCompanionStore"]>

  export type ElderlyCareCompanionStoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["elderlyCareCompanionStore"]>

  export type ElderlyCareCompanionStoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["elderlyCareCompanionStore"]>

  export type ElderlyCareCompanionStoreSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    createdAt?: boolean
  }

  export type ElderlyCareCompanionStoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "createdAt", ExtArgs["result"]["elderlyCareCompanionStore"]>

  export type $ElderlyCareCompanionStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElderlyCareCompanionStore"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string
      createdAt: Date
    }, ExtArgs["result"]["elderlyCareCompanionStore"]>
    composites: {}
  }

  type ElderlyCareCompanionStoreGetPayload<S extends boolean | null | undefined | ElderlyCareCompanionStoreDefaultArgs> = $Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload, S>

  type ElderlyCareCompanionStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElderlyCareCompanionStoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElderlyCareCompanionStoreCountAggregateInputType | true
    }

  export interface ElderlyCareCompanionStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElderlyCareCompanionStore'], meta: { name: 'ElderlyCareCompanionStore' } }
    /**
     * Find zero or one ElderlyCareCompanionStore that matches the filter.
     * @param {ElderlyCareCompanionStoreFindUniqueArgs} args - Arguments to find a ElderlyCareCompanionStore
     * @example
     * // Get one ElderlyCareCompanionStore
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElderlyCareCompanionStoreFindUniqueArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreFindUniqueArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElderlyCareCompanionStore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElderlyCareCompanionStoreFindUniqueOrThrowArgs} args - Arguments to find a ElderlyCareCompanionStore
     * @example
     * // Get one ElderlyCareCompanionStore
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElderlyCareCompanionStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreFindFirstArgs} args - Arguments to find a ElderlyCareCompanionStore
     * @example
     * // Get one ElderlyCareCompanionStore
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElderlyCareCompanionStoreFindFirstArgs>(args?: SelectSubset<T, ElderlyCareCompanionStoreFindFirstArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreFindFirstOrThrowArgs} args - Arguments to find a ElderlyCareCompanionStore
     * @example
     * // Get one ElderlyCareCompanionStore
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElderlyCareCompanionStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ElderlyCareCompanionStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElderlyCareCompanionStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElderlyCareCompanionStores
     * const elderlyCareCompanionStores = await prisma.elderlyCareCompanionStore.findMany()
     * 
     * // Get first 10 ElderlyCareCompanionStores
     * const elderlyCareCompanionStores = await prisma.elderlyCareCompanionStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elderlyCareCompanionStoreWithIdOnly = await prisma.elderlyCareCompanionStore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElderlyCareCompanionStoreFindManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElderlyCareCompanionStore.
     * @param {ElderlyCareCompanionStoreCreateArgs} args - Arguments to create a ElderlyCareCompanionStore.
     * @example
     * // Create one ElderlyCareCompanionStore
     * const ElderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.create({
     *   data: {
     *     // ... data to create a ElderlyCareCompanionStore
     *   }
     * })
     * 
     */
    create<T extends ElderlyCareCompanionStoreCreateArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreCreateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElderlyCareCompanionStores.
     * @param {ElderlyCareCompanionStoreCreateManyArgs} args - Arguments to create many ElderlyCareCompanionStores.
     * @example
     * // Create many ElderlyCareCompanionStores
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElderlyCareCompanionStoreCreateManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElderlyCareCompanionStores and returns the data saved in the database.
     * @param {ElderlyCareCompanionStoreCreateManyAndReturnArgs} args - Arguments to create many ElderlyCareCompanionStores.
     * @example
     * // Create many ElderlyCareCompanionStores
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElderlyCareCompanionStores and only return the `id`
     * const elderlyCareCompanionStoreWithIdOnly = await prisma.elderlyCareCompanionStore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElderlyCareCompanionStoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ElderlyCareCompanionStoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElderlyCareCompanionStore.
     * @param {ElderlyCareCompanionStoreDeleteArgs} args - Arguments to delete one ElderlyCareCompanionStore.
     * @example
     * // Delete one ElderlyCareCompanionStore
     * const ElderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.delete({
     *   where: {
     *     // ... filter to delete one ElderlyCareCompanionStore
     *   }
     * })
     * 
     */
    delete<T extends ElderlyCareCompanionStoreDeleteArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreDeleteArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElderlyCareCompanionStore.
     * @param {ElderlyCareCompanionStoreUpdateArgs} args - Arguments to update one ElderlyCareCompanionStore.
     * @example
     * // Update one ElderlyCareCompanionStore
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElderlyCareCompanionStoreUpdateArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreUpdateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElderlyCareCompanionStores.
     * @param {ElderlyCareCompanionStoreDeleteManyArgs} args - Arguments to filter ElderlyCareCompanionStores to delete.
     * @example
     * // Delete a few ElderlyCareCompanionStores
     * const { count } = await prisma.elderlyCareCompanionStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElderlyCareCompanionStoreDeleteManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElderlyCareCompanionStores
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElderlyCareCompanionStoreUpdateManyArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionStores and returns the data updated in the database.
     * @param {ElderlyCareCompanionStoreUpdateManyAndReturnArgs} args - Arguments to update many ElderlyCareCompanionStores.
     * @example
     * // Update many ElderlyCareCompanionStores
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElderlyCareCompanionStores and only return the `id`
     * const elderlyCareCompanionStoreWithIdOnly = await prisma.elderlyCareCompanionStore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElderlyCareCompanionStoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElderlyCareCompanionStore.
     * @param {ElderlyCareCompanionStoreUpsertArgs} args - Arguments to update or create a ElderlyCareCompanionStore.
     * @example
     * // Update or create a ElderlyCareCompanionStore
     * const elderlyCareCompanionStore = await prisma.elderlyCareCompanionStore.upsert({
     *   create: {
     *     // ... data to create a ElderlyCareCompanionStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionStore we want to update
     *   }
     * })
     */
    upsert<T extends ElderlyCareCompanionStoreUpsertArgs>(args: SelectSubset<T, ElderlyCareCompanionStoreUpsertArgs<ExtArgs>>): Prisma__ElderlyCareCompanionStoreClient<$Result.GetResult<Prisma.$ElderlyCareCompanionStorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElderlyCareCompanionStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreCountArgs} args - Arguments to filter ElderlyCareCompanionStores to count.
     * @example
     * // Count the number of ElderlyCareCompanionStores
     * const count = await prisma.elderlyCareCompanionStore.count({
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionStores we want to count
     *   }
     * })
    **/
    count<T extends ElderlyCareCompanionStoreCountArgs>(
      args?: Subset<T, ElderlyCareCompanionStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElderlyCareCompanionStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElderlyCareCompanionStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElderlyCareCompanionStoreAggregateArgs>(args: Subset<T, ElderlyCareCompanionStoreAggregateArgs>): Prisma.PrismaPromise<GetElderlyCareCompanionStoreAggregateType<T>>

    /**
     * Group by ElderlyCareCompanionStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElderlyCareCompanionStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElderlyCareCompanionStoreGroupByArgs['orderBy'] }
        : { orderBy?: ElderlyCareCompanionStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElderlyCareCompanionStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElderlyCareCompanionStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElderlyCareCompanionStore model
   */
  readonly fields: ElderlyCareCompanionStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElderlyCareCompanionStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElderlyCareCompanionStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElderlyCareCompanionStore model
   */ 
  interface ElderlyCareCompanionStoreFieldRefs {
    readonly id: FieldRef<"ElderlyCareCompanionStore", 'String'>
    readonly name: FieldRef<"ElderlyCareCompanionStore", 'String'>
    readonly address: FieldRef<"ElderlyCareCompanionStore", 'String'>
    readonly phone: FieldRef<"ElderlyCareCompanionStore", 'String'>
    readonly createdAt: FieldRef<"ElderlyCareCompanionStore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElderlyCareCompanionStore findUnique
   */
  export type ElderlyCareCompanionStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionStore to fetch.
     */
    where: ElderlyCareCompanionStoreWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionStore findUniqueOrThrow
   */
  export type ElderlyCareCompanionStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionStore to fetch.
     */
    where: ElderlyCareCompanionStoreWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionStore findFirst
   */
  export type ElderlyCareCompanionStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionStore to fetch.
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionStores to fetch.
     */
    orderBy?: ElderlyCareCompanionStoreOrderByWithRelationInput | ElderlyCareCompanionStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionStores.
     */
    cursor?: ElderlyCareCompanionStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionStores.
     */
    distinct?: ElderlyCareCompanionStoreScalarFieldEnum | ElderlyCareCompanionStoreScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionStore findFirstOrThrow
   */
  export type ElderlyCareCompanionStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionStore to fetch.
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionStores to fetch.
     */
    orderBy?: ElderlyCareCompanionStoreOrderByWithRelationInput | ElderlyCareCompanionStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionStores.
     */
    cursor?: ElderlyCareCompanionStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionStores.
     */
    distinct?: ElderlyCareCompanionStoreScalarFieldEnum | ElderlyCareCompanionStoreScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionStore findMany
   */
  export type ElderlyCareCompanionStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionStores to fetch.
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionStores to fetch.
     */
    orderBy?: ElderlyCareCompanionStoreOrderByWithRelationInput | ElderlyCareCompanionStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElderlyCareCompanionStores.
     */
    cursor?: ElderlyCareCompanionStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionStores.
     */
    skip?: number
    distinct?: ElderlyCareCompanionStoreScalarFieldEnum | ElderlyCareCompanionStoreScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionStore create
   */
  export type ElderlyCareCompanionStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * The data needed to create a ElderlyCareCompanionStore.
     */
    data: XOR<ElderlyCareCompanionStoreCreateInput, ElderlyCareCompanionStoreUncheckedCreateInput>
  }

  /**
   * ElderlyCareCompanionStore createMany
   */
  export type ElderlyCareCompanionStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElderlyCareCompanionStores.
     */
    data: ElderlyCareCompanionStoreCreateManyInput | ElderlyCareCompanionStoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionStore createManyAndReturn
   */
  export type ElderlyCareCompanionStoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * The data used to create many ElderlyCareCompanionStores.
     */
    data: ElderlyCareCompanionStoreCreateManyInput | ElderlyCareCompanionStoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionStore update
   */
  export type ElderlyCareCompanionStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * The data needed to update a ElderlyCareCompanionStore.
     */
    data: XOR<ElderlyCareCompanionStoreUpdateInput, ElderlyCareCompanionStoreUncheckedUpdateInput>
    /**
     * Choose, which ElderlyCareCompanionStore to update.
     */
    where: ElderlyCareCompanionStoreWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionStore updateMany
   */
  export type ElderlyCareCompanionStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElderlyCareCompanionStores.
     */
    data: XOR<ElderlyCareCompanionStoreUpdateManyMutationInput, ElderlyCareCompanionStoreUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionStores to update
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * Limit how many ElderlyCareCompanionStores to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionStore updateManyAndReturn
   */
  export type ElderlyCareCompanionStoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * The data used to update ElderlyCareCompanionStores.
     */
    data: XOR<ElderlyCareCompanionStoreUpdateManyMutationInput, ElderlyCareCompanionStoreUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionStores to update
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * Limit how many ElderlyCareCompanionStores to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionStore upsert
   */
  export type ElderlyCareCompanionStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * The filter to search for the ElderlyCareCompanionStore to update in case it exists.
     */
    where: ElderlyCareCompanionStoreWhereUniqueInput
    /**
     * In case the ElderlyCareCompanionStore found by the `where` argument doesn't exist, create a new ElderlyCareCompanionStore with this data.
     */
    create: XOR<ElderlyCareCompanionStoreCreateInput, ElderlyCareCompanionStoreUncheckedCreateInput>
    /**
     * In case the ElderlyCareCompanionStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElderlyCareCompanionStoreUpdateInput, ElderlyCareCompanionStoreUncheckedUpdateInput>
  }

  /**
   * ElderlyCareCompanionStore delete
   */
  export type ElderlyCareCompanionStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
    /**
     * Filter which ElderlyCareCompanionStore to delete.
     */
    where: ElderlyCareCompanionStoreWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionStore deleteMany
   */
  export type ElderlyCareCompanionStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionStores to delete
     */
    where?: ElderlyCareCompanionStoreWhereInput
    /**
     * Limit how many ElderlyCareCompanionStores to delete.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionStore without action
   */
  export type ElderlyCareCompanionStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionStore
     */
    select?: ElderlyCareCompanionStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionStore
     */
    omit?: ElderlyCareCompanionStoreOmit<ExtArgs> | null
  }


  /**
   * Model ElderlyCareCompanionRecord
   */

  export type AggregateElderlyCareCompanionRecord = {
    _count: ElderlyCareCompanionRecordCountAggregateOutputType | null
    _min: ElderlyCareCompanionRecordMinAggregateOutputType | null
    _max: ElderlyCareCompanionRecordMaxAggregateOutputType | null
  }

  export type ElderlyCareCompanionRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    recordType: string | null
    details: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    recordType: string | null
    details: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type ElderlyCareCompanionRecordCountAggregateOutputType = {
    id: number
    userId: number
    recordType: number
    details: number
    date: number
    createdAt: number
    _all: number
  }


  export type ElderlyCareCompanionRecordMinAggregateInputType = {
    id?: true
    userId?: true
    recordType?: true
    details?: true
    date?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    recordType?: true
    details?: true
    date?: true
    createdAt?: true
  }

  export type ElderlyCareCompanionRecordCountAggregateInputType = {
    id?: true
    userId?: true
    recordType?: true
    details?: true
    date?: true
    createdAt?: true
    _all?: true
  }

  export type ElderlyCareCompanionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionRecord to aggregate.
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionRecords to fetch.
     */
    orderBy?: ElderlyCareCompanionRecordOrderByWithRelationInput | ElderlyCareCompanionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElderlyCareCompanionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElderlyCareCompanionRecords
    **/
    _count?: true | ElderlyCareCompanionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElderlyCareCompanionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElderlyCareCompanionRecordMaxAggregateInputType
  }

  export type GetElderlyCareCompanionRecordAggregateType<T extends ElderlyCareCompanionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateElderlyCareCompanionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElderlyCareCompanionRecord[P]>
      : GetScalarType<T[P], AggregateElderlyCareCompanionRecord[P]>
  }




  export type ElderlyCareCompanionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionRecordWhereInput
    orderBy?: ElderlyCareCompanionRecordOrderByWithAggregationInput | ElderlyCareCompanionRecordOrderByWithAggregationInput[]
    by: ElderlyCareCompanionRecordScalarFieldEnum[] | ElderlyCareCompanionRecordScalarFieldEnum
    having?: ElderlyCareCompanionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElderlyCareCompanionRecordCountAggregateInputType | true
    _min?: ElderlyCareCompanionRecordMinAggregateInputType
    _max?: ElderlyCareCompanionRecordMaxAggregateInputType
  }

  export type ElderlyCareCompanionRecordGroupByOutputType = {
    id: string
    userId: string
    recordType: string
    details: string
    date: Date
    createdAt: Date
    _count: ElderlyCareCompanionRecordCountAggregateOutputType | null
    _min: ElderlyCareCompanionRecordMinAggregateOutputType | null
    _max: ElderlyCareCompanionRecordMaxAggregateOutputType | null
  }

  type GetElderlyCareCompanionRecordGroupByPayload<T extends ElderlyCareCompanionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElderlyCareCompanionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElderlyCareCompanionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElderlyCareCompanionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ElderlyCareCompanionRecordGroupByOutputType[P]>
        }
      >
    >


  export type ElderlyCareCompanionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recordType?: boolean
    details?: boolean
    date?: boolean
    createdAt?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionRecord"]>

  export type ElderlyCareCompanionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recordType?: boolean
    details?: boolean
    date?: boolean
    createdAt?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionRecord"]>

  export type ElderlyCareCompanionRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recordType?: boolean
    details?: boolean
    date?: boolean
    createdAt?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionRecord"]>

  export type ElderlyCareCompanionRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    recordType?: boolean
    details?: boolean
    date?: boolean
    createdAt?: boolean
  }

  export type ElderlyCareCompanionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "recordType" | "details" | "date" | "createdAt", ExtArgs["result"]["elderlyCareCompanionRecord"]>
  export type ElderlyCareCompanionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }
  export type ElderlyCareCompanionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }
  export type ElderlyCareCompanionRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
  }

  export type $ElderlyCareCompanionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElderlyCareCompanionRecord"
    objects: {
      user: Prisma.$UserElderlyCareCompanionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      recordType: string
      details: string
      date: Date
      createdAt: Date
    }, ExtArgs["result"]["elderlyCareCompanionRecord"]>
    composites: {}
  }

  type ElderlyCareCompanionRecordGetPayload<S extends boolean | null | undefined | ElderlyCareCompanionRecordDefaultArgs> = $Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload, S>

  type ElderlyCareCompanionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElderlyCareCompanionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElderlyCareCompanionRecordCountAggregateInputType | true
    }

  export interface ElderlyCareCompanionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElderlyCareCompanionRecord'], meta: { name: 'ElderlyCareCompanionRecord' } }
    /**
     * Find zero or one ElderlyCareCompanionRecord that matches the filter.
     * @param {ElderlyCareCompanionRecordFindUniqueArgs} args - Arguments to find a ElderlyCareCompanionRecord
     * @example
     * // Get one ElderlyCareCompanionRecord
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElderlyCareCompanionRecordFindUniqueArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordFindUniqueArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElderlyCareCompanionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElderlyCareCompanionRecordFindUniqueOrThrowArgs} args - Arguments to find a ElderlyCareCompanionRecord
     * @example
     * // Get one ElderlyCareCompanionRecord
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElderlyCareCompanionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordFindFirstArgs} args - Arguments to find a ElderlyCareCompanionRecord
     * @example
     * // Get one ElderlyCareCompanionRecord
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElderlyCareCompanionRecordFindFirstArgs>(args?: SelectSubset<T, ElderlyCareCompanionRecordFindFirstArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordFindFirstOrThrowArgs} args - Arguments to find a ElderlyCareCompanionRecord
     * @example
     * // Get one ElderlyCareCompanionRecord
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElderlyCareCompanionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ElderlyCareCompanionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElderlyCareCompanionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElderlyCareCompanionRecords
     * const elderlyCareCompanionRecords = await prisma.elderlyCareCompanionRecord.findMany()
     * 
     * // Get first 10 ElderlyCareCompanionRecords
     * const elderlyCareCompanionRecords = await prisma.elderlyCareCompanionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elderlyCareCompanionRecordWithIdOnly = await prisma.elderlyCareCompanionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElderlyCareCompanionRecordFindManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElderlyCareCompanionRecord.
     * @param {ElderlyCareCompanionRecordCreateArgs} args - Arguments to create a ElderlyCareCompanionRecord.
     * @example
     * // Create one ElderlyCareCompanionRecord
     * const ElderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.create({
     *   data: {
     *     // ... data to create a ElderlyCareCompanionRecord
     *   }
     * })
     * 
     */
    create<T extends ElderlyCareCompanionRecordCreateArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordCreateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElderlyCareCompanionRecords.
     * @param {ElderlyCareCompanionRecordCreateManyArgs} args - Arguments to create many ElderlyCareCompanionRecords.
     * @example
     * // Create many ElderlyCareCompanionRecords
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElderlyCareCompanionRecordCreateManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElderlyCareCompanionRecords and returns the data saved in the database.
     * @param {ElderlyCareCompanionRecordCreateManyAndReturnArgs} args - Arguments to create many ElderlyCareCompanionRecords.
     * @example
     * // Create many ElderlyCareCompanionRecords
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElderlyCareCompanionRecords and only return the `id`
     * const elderlyCareCompanionRecordWithIdOnly = await prisma.elderlyCareCompanionRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElderlyCareCompanionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ElderlyCareCompanionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElderlyCareCompanionRecord.
     * @param {ElderlyCareCompanionRecordDeleteArgs} args - Arguments to delete one ElderlyCareCompanionRecord.
     * @example
     * // Delete one ElderlyCareCompanionRecord
     * const ElderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.delete({
     *   where: {
     *     // ... filter to delete one ElderlyCareCompanionRecord
     *   }
     * })
     * 
     */
    delete<T extends ElderlyCareCompanionRecordDeleteArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordDeleteArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElderlyCareCompanionRecord.
     * @param {ElderlyCareCompanionRecordUpdateArgs} args - Arguments to update one ElderlyCareCompanionRecord.
     * @example
     * // Update one ElderlyCareCompanionRecord
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElderlyCareCompanionRecordUpdateArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordUpdateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElderlyCareCompanionRecords.
     * @param {ElderlyCareCompanionRecordDeleteManyArgs} args - Arguments to filter ElderlyCareCompanionRecords to delete.
     * @example
     * // Delete a few ElderlyCareCompanionRecords
     * const { count } = await prisma.elderlyCareCompanionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElderlyCareCompanionRecordDeleteManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElderlyCareCompanionRecords
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElderlyCareCompanionRecordUpdateManyArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionRecords and returns the data updated in the database.
     * @param {ElderlyCareCompanionRecordUpdateManyAndReturnArgs} args - Arguments to update many ElderlyCareCompanionRecords.
     * @example
     * // Update many ElderlyCareCompanionRecords
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElderlyCareCompanionRecords and only return the `id`
     * const elderlyCareCompanionRecordWithIdOnly = await prisma.elderlyCareCompanionRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElderlyCareCompanionRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElderlyCareCompanionRecord.
     * @param {ElderlyCareCompanionRecordUpsertArgs} args - Arguments to update or create a ElderlyCareCompanionRecord.
     * @example
     * // Update or create a ElderlyCareCompanionRecord
     * const elderlyCareCompanionRecord = await prisma.elderlyCareCompanionRecord.upsert({
     *   create: {
     *     // ... data to create a ElderlyCareCompanionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionRecord we want to update
     *   }
     * })
     */
    upsert<T extends ElderlyCareCompanionRecordUpsertArgs>(args: SelectSubset<T, ElderlyCareCompanionRecordUpsertArgs<ExtArgs>>): Prisma__ElderlyCareCompanionRecordClient<$Result.GetResult<Prisma.$ElderlyCareCompanionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElderlyCareCompanionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordCountArgs} args - Arguments to filter ElderlyCareCompanionRecords to count.
     * @example
     * // Count the number of ElderlyCareCompanionRecords
     * const count = await prisma.elderlyCareCompanionRecord.count({
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionRecords we want to count
     *   }
     * })
    **/
    count<T extends ElderlyCareCompanionRecordCountArgs>(
      args?: Subset<T, ElderlyCareCompanionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElderlyCareCompanionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElderlyCareCompanionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElderlyCareCompanionRecordAggregateArgs>(args: Subset<T, ElderlyCareCompanionRecordAggregateArgs>): Prisma.PrismaPromise<GetElderlyCareCompanionRecordAggregateType<T>>

    /**
     * Group by ElderlyCareCompanionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElderlyCareCompanionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElderlyCareCompanionRecordGroupByArgs['orderBy'] }
        : { orderBy?: ElderlyCareCompanionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElderlyCareCompanionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElderlyCareCompanionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElderlyCareCompanionRecord model
   */
  readonly fields: ElderlyCareCompanionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElderlyCareCompanionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElderlyCareCompanionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserElderlyCareCompanionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserElderlyCareCompanionDefaultArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElderlyCareCompanionRecord model
   */ 
  interface ElderlyCareCompanionRecordFieldRefs {
    readonly id: FieldRef<"ElderlyCareCompanionRecord", 'String'>
    readonly userId: FieldRef<"ElderlyCareCompanionRecord", 'String'>
    readonly recordType: FieldRef<"ElderlyCareCompanionRecord", 'String'>
    readonly details: FieldRef<"ElderlyCareCompanionRecord", 'String'>
    readonly date: FieldRef<"ElderlyCareCompanionRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ElderlyCareCompanionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElderlyCareCompanionRecord findUnique
   */
  export type ElderlyCareCompanionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionRecord to fetch.
     */
    where: ElderlyCareCompanionRecordWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionRecord findUniqueOrThrow
   */
  export type ElderlyCareCompanionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionRecord to fetch.
     */
    where: ElderlyCareCompanionRecordWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionRecord findFirst
   */
  export type ElderlyCareCompanionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionRecord to fetch.
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionRecords to fetch.
     */
    orderBy?: ElderlyCareCompanionRecordOrderByWithRelationInput | ElderlyCareCompanionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionRecords.
     */
    cursor?: ElderlyCareCompanionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionRecords.
     */
    distinct?: ElderlyCareCompanionRecordScalarFieldEnum | ElderlyCareCompanionRecordScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionRecord findFirstOrThrow
   */
  export type ElderlyCareCompanionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionRecord to fetch.
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionRecords to fetch.
     */
    orderBy?: ElderlyCareCompanionRecordOrderByWithRelationInput | ElderlyCareCompanionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionRecords.
     */
    cursor?: ElderlyCareCompanionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionRecords.
     */
    distinct?: ElderlyCareCompanionRecordScalarFieldEnum | ElderlyCareCompanionRecordScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionRecord findMany
   */
  export type ElderlyCareCompanionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionRecords to fetch.
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionRecords to fetch.
     */
    orderBy?: ElderlyCareCompanionRecordOrderByWithRelationInput | ElderlyCareCompanionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElderlyCareCompanionRecords.
     */
    cursor?: ElderlyCareCompanionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionRecords.
     */
    skip?: number
    distinct?: ElderlyCareCompanionRecordScalarFieldEnum | ElderlyCareCompanionRecordScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionRecord create
   */
  export type ElderlyCareCompanionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ElderlyCareCompanionRecord.
     */
    data: XOR<ElderlyCareCompanionRecordCreateInput, ElderlyCareCompanionRecordUncheckedCreateInput>
  }

  /**
   * ElderlyCareCompanionRecord createMany
   */
  export type ElderlyCareCompanionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElderlyCareCompanionRecords.
     */
    data: ElderlyCareCompanionRecordCreateManyInput | ElderlyCareCompanionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionRecord createManyAndReturn
   */
  export type ElderlyCareCompanionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ElderlyCareCompanionRecords.
     */
    data: ElderlyCareCompanionRecordCreateManyInput | ElderlyCareCompanionRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionRecord update
   */
  export type ElderlyCareCompanionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ElderlyCareCompanionRecord.
     */
    data: XOR<ElderlyCareCompanionRecordUpdateInput, ElderlyCareCompanionRecordUncheckedUpdateInput>
    /**
     * Choose, which ElderlyCareCompanionRecord to update.
     */
    where: ElderlyCareCompanionRecordWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionRecord updateMany
   */
  export type ElderlyCareCompanionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElderlyCareCompanionRecords.
     */
    data: XOR<ElderlyCareCompanionRecordUpdateManyMutationInput, ElderlyCareCompanionRecordUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionRecords to update
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * Limit how many ElderlyCareCompanionRecords to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionRecord updateManyAndReturn
   */
  export type ElderlyCareCompanionRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * The data used to update ElderlyCareCompanionRecords.
     */
    data: XOR<ElderlyCareCompanionRecordUpdateManyMutationInput, ElderlyCareCompanionRecordUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionRecords to update
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * Limit how many ElderlyCareCompanionRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionRecord upsert
   */
  export type ElderlyCareCompanionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ElderlyCareCompanionRecord to update in case it exists.
     */
    where: ElderlyCareCompanionRecordWhereUniqueInput
    /**
     * In case the ElderlyCareCompanionRecord found by the `where` argument doesn't exist, create a new ElderlyCareCompanionRecord with this data.
     */
    create: XOR<ElderlyCareCompanionRecordCreateInput, ElderlyCareCompanionRecordUncheckedCreateInput>
    /**
     * In case the ElderlyCareCompanionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElderlyCareCompanionRecordUpdateInput, ElderlyCareCompanionRecordUncheckedUpdateInput>
  }

  /**
   * ElderlyCareCompanionRecord delete
   */
  export type ElderlyCareCompanionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
    /**
     * Filter which ElderlyCareCompanionRecord to delete.
     */
    where: ElderlyCareCompanionRecordWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionRecord deleteMany
   */
  export type ElderlyCareCompanionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionRecords to delete
     */
    where?: ElderlyCareCompanionRecordWhereInput
    /**
     * Limit how many ElderlyCareCompanionRecords to delete.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionRecord without action
   */
  export type ElderlyCareCompanionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionRecord
     */
    select?: ElderlyCareCompanionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionRecord
     */
    omit?: ElderlyCareCompanionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionRecordInclude<ExtArgs> | null
  }


  /**
   * Model ElderlyCareCompanionMedicationTracking
   */

  export type AggregateElderlyCareCompanionMedicationTracking = {
    _count: ElderlyCareCompanionMedicationTrackingCountAggregateOutputType | null
    _min: ElderlyCareCompanionMedicationTrackingMinAggregateOutputType | null
    _max: ElderlyCareCompanionMedicationTrackingMaxAggregateOutputType | null
  }

  export type ElderlyCareCompanionMedicationTrackingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    medicationId: string | null
    status: string | null
    dateTime: Date | null
  }

  export type ElderlyCareCompanionMedicationTrackingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    medicationId: string | null
    status: string | null
    dateTime: Date | null
  }

  export type ElderlyCareCompanionMedicationTrackingCountAggregateOutputType = {
    id: number
    userId: number
    medicationId: number
    status: number
    dateTime: number
    _all: number
  }


  export type ElderlyCareCompanionMedicationTrackingMinAggregateInputType = {
    id?: true
    userId?: true
    medicationId?: true
    status?: true
    dateTime?: true
  }

  export type ElderlyCareCompanionMedicationTrackingMaxAggregateInputType = {
    id?: true
    userId?: true
    medicationId?: true
    status?: true
    dateTime?: true
  }

  export type ElderlyCareCompanionMedicationTrackingCountAggregateInputType = {
    id?: true
    userId?: true
    medicationId?: true
    status?: true
    dateTime?: true
    _all?: true
  }

  export type ElderlyCareCompanionMedicationTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionMedicationTracking to aggregate.
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionMedicationTrackings to fetch.
     */
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput | ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionMedicationTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionMedicationTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElderlyCareCompanionMedicationTrackings
    **/
    _count?: true | ElderlyCareCompanionMedicationTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElderlyCareCompanionMedicationTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElderlyCareCompanionMedicationTrackingMaxAggregateInputType
  }

  export type GetElderlyCareCompanionMedicationTrackingAggregateType<T extends ElderlyCareCompanionMedicationTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateElderlyCareCompanionMedicationTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElderlyCareCompanionMedicationTracking[P]>
      : GetScalarType<T[P], AggregateElderlyCareCompanionMedicationTracking[P]>
  }




  export type ElderlyCareCompanionMedicationTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithAggregationInput | ElderlyCareCompanionMedicationTrackingOrderByWithAggregationInput[]
    by: ElderlyCareCompanionMedicationTrackingScalarFieldEnum[] | ElderlyCareCompanionMedicationTrackingScalarFieldEnum
    having?: ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElderlyCareCompanionMedicationTrackingCountAggregateInputType | true
    _min?: ElderlyCareCompanionMedicationTrackingMinAggregateInputType
    _max?: ElderlyCareCompanionMedicationTrackingMaxAggregateInputType
  }

  export type ElderlyCareCompanionMedicationTrackingGroupByOutputType = {
    id: string
    userId: string
    medicationId: string
    status: string
    dateTime: Date
    _count: ElderlyCareCompanionMedicationTrackingCountAggregateOutputType | null
    _min: ElderlyCareCompanionMedicationTrackingMinAggregateOutputType | null
    _max: ElderlyCareCompanionMedicationTrackingMaxAggregateOutputType | null
  }

  type GetElderlyCareCompanionMedicationTrackingGroupByPayload<T extends ElderlyCareCompanionMedicationTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElderlyCareCompanionMedicationTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElderlyCareCompanionMedicationTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElderlyCareCompanionMedicationTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], ElderlyCareCompanionMedicationTrackingGroupByOutputType[P]>
        }
      >
    >


  export type ElderlyCareCompanionMedicationTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    medicationId?: boolean
    status?: boolean
    dateTime?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medication?: boolean | ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionMedicationTracking"]>

  export type ElderlyCareCompanionMedicationTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    medicationId?: boolean
    status?: boolean
    dateTime?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medication?: boolean | ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionMedicationTracking"]>

  export type ElderlyCareCompanionMedicationTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    medicationId?: boolean
    status?: boolean
    dateTime?: boolean
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medication?: boolean | ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elderlyCareCompanionMedicationTracking"]>

  export type ElderlyCareCompanionMedicationTrackingSelectScalar = {
    id?: boolean
    userId?: boolean
    medicationId?: boolean
    status?: boolean
    dateTime?: boolean
  }

  export type ElderlyCareCompanionMedicationTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "medicationId" | "status" | "dateTime", ExtArgs["result"]["elderlyCareCompanionMedicationTracking"]>
  export type ElderlyCareCompanionMedicationTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medication?: boolean | ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>
  }
  export type ElderlyCareCompanionMedicationTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medication?: boolean | ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>
  }
  export type ElderlyCareCompanionMedicationTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserElderlyCareCompanionDefaultArgs<ExtArgs>
    medication?: boolean | ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>
  }

  export type $ElderlyCareCompanionMedicationTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElderlyCareCompanionMedicationTracking"
    objects: {
      user: Prisma.$UserElderlyCareCompanionPayload<ExtArgs>
      medication: Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      medicationId: string
      status: string
      dateTime: Date
    }, ExtArgs["result"]["elderlyCareCompanionMedicationTracking"]>
    composites: {}
  }

  type ElderlyCareCompanionMedicationTrackingGetPayload<S extends boolean | null | undefined | ElderlyCareCompanionMedicationTrackingDefaultArgs> = $Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload, S>

  type ElderlyCareCompanionMedicationTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElderlyCareCompanionMedicationTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElderlyCareCompanionMedicationTrackingCountAggregateInputType | true
    }

  export interface ElderlyCareCompanionMedicationTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElderlyCareCompanionMedicationTracking'], meta: { name: 'ElderlyCareCompanionMedicationTracking' } }
    /**
     * Find zero or one ElderlyCareCompanionMedicationTracking that matches the filter.
     * @param {ElderlyCareCompanionMedicationTrackingFindUniqueArgs} args - Arguments to find a ElderlyCareCompanionMedicationTracking
     * @example
     * // Get one ElderlyCareCompanionMedicationTracking
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElderlyCareCompanionMedicationTrackingFindUniqueArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingFindUniqueArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElderlyCareCompanionMedicationTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElderlyCareCompanionMedicationTrackingFindUniqueOrThrowArgs} args - Arguments to find a ElderlyCareCompanionMedicationTracking
     * @example
     * // Get one ElderlyCareCompanionMedicationTracking
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElderlyCareCompanionMedicationTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionMedicationTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingFindFirstArgs} args - Arguments to find a ElderlyCareCompanionMedicationTracking
     * @example
     * // Get one ElderlyCareCompanionMedicationTracking
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElderlyCareCompanionMedicationTrackingFindFirstArgs>(args?: SelectSubset<T, ElderlyCareCompanionMedicationTrackingFindFirstArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElderlyCareCompanionMedicationTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingFindFirstOrThrowArgs} args - Arguments to find a ElderlyCareCompanionMedicationTracking
     * @example
     * // Get one ElderlyCareCompanionMedicationTracking
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElderlyCareCompanionMedicationTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, ElderlyCareCompanionMedicationTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElderlyCareCompanionMedicationTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElderlyCareCompanionMedicationTrackings
     * const elderlyCareCompanionMedicationTrackings = await prisma.elderlyCareCompanionMedicationTracking.findMany()
     * 
     * // Get first 10 ElderlyCareCompanionMedicationTrackings
     * const elderlyCareCompanionMedicationTrackings = await prisma.elderlyCareCompanionMedicationTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elderlyCareCompanionMedicationTrackingWithIdOnly = await prisma.elderlyCareCompanionMedicationTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElderlyCareCompanionMedicationTrackingFindManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionMedicationTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElderlyCareCompanionMedicationTracking.
     * @param {ElderlyCareCompanionMedicationTrackingCreateArgs} args - Arguments to create a ElderlyCareCompanionMedicationTracking.
     * @example
     * // Create one ElderlyCareCompanionMedicationTracking
     * const ElderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.create({
     *   data: {
     *     // ... data to create a ElderlyCareCompanionMedicationTracking
     *   }
     * })
     * 
     */
    create<T extends ElderlyCareCompanionMedicationTrackingCreateArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingCreateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElderlyCareCompanionMedicationTrackings.
     * @param {ElderlyCareCompanionMedicationTrackingCreateManyArgs} args - Arguments to create many ElderlyCareCompanionMedicationTrackings.
     * @example
     * // Create many ElderlyCareCompanionMedicationTrackings
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElderlyCareCompanionMedicationTrackingCreateManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionMedicationTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElderlyCareCompanionMedicationTrackings and returns the data saved in the database.
     * @param {ElderlyCareCompanionMedicationTrackingCreateManyAndReturnArgs} args - Arguments to create many ElderlyCareCompanionMedicationTrackings.
     * @example
     * // Create many ElderlyCareCompanionMedicationTrackings
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElderlyCareCompanionMedicationTrackings and only return the `id`
     * const elderlyCareCompanionMedicationTrackingWithIdOnly = await prisma.elderlyCareCompanionMedicationTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElderlyCareCompanionMedicationTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, ElderlyCareCompanionMedicationTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElderlyCareCompanionMedicationTracking.
     * @param {ElderlyCareCompanionMedicationTrackingDeleteArgs} args - Arguments to delete one ElderlyCareCompanionMedicationTracking.
     * @example
     * // Delete one ElderlyCareCompanionMedicationTracking
     * const ElderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.delete({
     *   where: {
     *     // ... filter to delete one ElderlyCareCompanionMedicationTracking
     *   }
     * })
     * 
     */
    delete<T extends ElderlyCareCompanionMedicationTrackingDeleteArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingDeleteArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElderlyCareCompanionMedicationTracking.
     * @param {ElderlyCareCompanionMedicationTrackingUpdateArgs} args - Arguments to update one ElderlyCareCompanionMedicationTracking.
     * @example
     * // Update one ElderlyCareCompanionMedicationTracking
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElderlyCareCompanionMedicationTrackingUpdateArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingUpdateArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElderlyCareCompanionMedicationTrackings.
     * @param {ElderlyCareCompanionMedicationTrackingDeleteManyArgs} args - Arguments to filter ElderlyCareCompanionMedicationTrackings to delete.
     * @example
     * // Delete a few ElderlyCareCompanionMedicationTrackings
     * const { count } = await prisma.elderlyCareCompanionMedicationTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElderlyCareCompanionMedicationTrackingDeleteManyArgs>(args?: SelectSubset<T, ElderlyCareCompanionMedicationTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionMedicationTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElderlyCareCompanionMedicationTrackings
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElderlyCareCompanionMedicationTrackingUpdateManyArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElderlyCareCompanionMedicationTrackings and returns the data updated in the database.
     * @param {ElderlyCareCompanionMedicationTrackingUpdateManyAndReturnArgs} args - Arguments to update many ElderlyCareCompanionMedicationTrackings.
     * @example
     * // Update many ElderlyCareCompanionMedicationTrackings
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElderlyCareCompanionMedicationTrackings and only return the `id`
     * const elderlyCareCompanionMedicationTrackingWithIdOnly = await prisma.elderlyCareCompanionMedicationTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElderlyCareCompanionMedicationTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElderlyCareCompanionMedicationTracking.
     * @param {ElderlyCareCompanionMedicationTrackingUpsertArgs} args - Arguments to update or create a ElderlyCareCompanionMedicationTracking.
     * @example
     * // Update or create a ElderlyCareCompanionMedicationTracking
     * const elderlyCareCompanionMedicationTracking = await prisma.elderlyCareCompanionMedicationTracking.upsert({
     *   create: {
     *     // ... data to create a ElderlyCareCompanionMedicationTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionMedicationTracking we want to update
     *   }
     * })
     */
    upsert<T extends ElderlyCareCompanionMedicationTrackingUpsertArgs>(args: SelectSubset<T, ElderlyCareCompanionMedicationTrackingUpsertArgs<ExtArgs>>): Prisma__ElderlyCareCompanionMedicationTrackingClient<$Result.GetResult<Prisma.$ElderlyCareCompanionMedicationTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElderlyCareCompanionMedicationTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingCountArgs} args - Arguments to filter ElderlyCareCompanionMedicationTrackings to count.
     * @example
     * // Count the number of ElderlyCareCompanionMedicationTrackings
     * const count = await prisma.elderlyCareCompanionMedicationTracking.count({
     *   where: {
     *     // ... the filter for the ElderlyCareCompanionMedicationTrackings we want to count
     *   }
     * })
    **/
    count<T extends ElderlyCareCompanionMedicationTrackingCountArgs>(
      args?: Subset<T, ElderlyCareCompanionMedicationTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElderlyCareCompanionMedicationTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElderlyCareCompanionMedicationTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElderlyCareCompanionMedicationTrackingAggregateArgs>(args: Subset<T, ElderlyCareCompanionMedicationTrackingAggregateArgs>): Prisma.PrismaPromise<GetElderlyCareCompanionMedicationTrackingAggregateType<T>>

    /**
     * Group by ElderlyCareCompanionMedicationTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElderlyCareCompanionMedicationTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElderlyCareCompanionMedicationTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElderlyCareCompanionMedicationTrackingGroupByArgs['orderBy'] }
        : { orderBy?: ElderlyCareCompanionMedicationTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElderlyCareCompanionMedicationTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElderlyCareCompanionMedicationTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElderlyCareCompanionMedicationTracking model
   */
  readonly fields: ElderlyCareCompanionMedicationTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElderlyCareCompanionMedicationTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElderlyCareCompanionMedicationTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserElderlyCareCompanionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserElderlyCareCompanionDefaultArgs<ExtArgs>>): Prisma__UserElderlyCareCompanionClient<$Result.GetResult<Prisma.$UserElderlyCareCompanionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medication<T extends ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ElderlyCareCompanionAppointmentDefaultArgs<ExtArgs>>): Prisma__ElderlyCareCompanionAppointmentClient<$Result.GetResult<Prisma.$ElderlyCareCompanionAppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElderlyCareCompanionMedicationTracking model
   */ 
  interface ElderlyCareCompanionMedicationTrackingFieldRefs {
    readonly id: FieldRef<"ElderlyCareCompanionMedicationTracking", 'String'>
    readonly userId: FieldRef<"ElderlyCareCompanionMedicationTracking", 'String'>
    readonly medicationId: FieldRef<"ElderlyCareCompanionMedicationTracking", 'String'>
    readonly status: FieldRef<"ElderlyCareCompanionMedicationTracking", 'String'>
    readonly dateTime: FieldRef<"ElderlyCareCompanionMedicationTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElderlyCareCompanionMedicationTracking findUnique
   */
  export type ElderlyCareCompanionMedicationTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionMedicationTracking to fetch.
     */
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionMedicationTracking findUniqueOrThrow
   */
  export type ElderlyCareCompanionMedicationTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionMedicationTracking to fetch.
     */
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionMedicationTracking findFirst
   */
  export type ElderlyCareCompanionMedicationTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionMedicationTracking to fetch.
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionMedicationTrackings to fetch.
     */
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput | ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionMedicationTrackings.
     */
    cursor?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionMedicationTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionMedicationTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionMedicationTrackings.
     */
    distinct?: ElderlyCareCompanionMedicationTrackingScalarFieldEnum | ElderlyCareCompanionMedicationTrackingScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionMedicationTracking findFirstOrThrow
   */
  export type ElderlyCareCompanionMedicationTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionMedicationTracking to fetch.
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionMedicationTrackings to fetch.
     */
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput | ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElderlyCareCompanionMedicationTrackings.
     */
    cursor?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionMedicationTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionMedicationTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElderlyCareCompanionMedicationTrackings.
     */
    distinct?: ElderlyCareCompanionMedicationTrackingScalarFieldEnum | ElderlyCareCompanionMedicationTrackingScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionMedicationTracking findMany
   */
  export type ElderlyCareCompanionMedicationTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * Filter, which ElderlyCareCompanionMedicationTrackings to fetch.
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElderlyCareCompanionMedicationTrackings to fetch.
     */
    orderBy?: ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput | ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElderlyCareCompanionMedicationTrackings.
     */
    cursor?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElderlyCareCompanionMedicationTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElderlyCareCompanionMedicationTrackings.
     */
    skip?: number
    distinct?: ElderlyCareCompanionMedicationTrackingScalarFieldEnum | ElderlyCareCompanionMedicationTrackingScalarFieldEnum[]
  }

  /**
   * ElderlyCareCompanionMedicationTracking create
   */
  export type ElderlyCareCompanionMedicationTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a ElderlyCareCompanionMedicationTracking.
     */
    data: XOR<ElderlyCareCompanionMedicationTrackingCreateInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateInput>
  }

  /**
   * ElderlyCareCompanionMedicationTracking createMany
   */
  export type ElderlyCareCompanionMedicationTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElderlyCareCompanionMedicationTrackings.
     */
    data: ElderlyCareCompanionMedicationTrackingCreateManyInput | ElderlyCareCompanionMedicationTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElderlyCareCompanionMedicationTracking createManyAndReturn
   */
  export type ElderlyCareCompanionMedicationTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many ElderlyCareCompanionMedicationTrackings.
     */
    data: ElderlyCareCompanionMedicationTrackingCreateManyInput | ElderlyCareCompanionMedicationTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionMedicationTracking update
   */
  export type ElderlyCareCompanionMedicationTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a ElderlyCareCompanionMedicationTracking.
     */
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateInput>
    /**
     * Choose, which ElderlyCareCompanionMedicationTracking to update.
     */
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionMedicationTracking updateMany
   */
  export type ElderlyCareCompanionMedicationTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElderlyCareCompanionMedicationTrackings.
     */
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateManyMutationInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionMedicationTrackings to update
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * Limit how many ElderlyCareCompanionMedicationTrackings to update.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionMedicationTracking updateManyAndReturn
   */
  export type ElderlyCareCompanionMedicationTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * The data used to update ElderlyCareCompanionMedicationTrackings.
     */
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateManyMutationInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyInput>
    /**
     * Filter which ElderlyCareCompanionMedicationTrackings to update
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * Limit how many ElderlyCareCompanionMedicationTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElderlyCareCompanionMedicationTracking upsert
   */
  export type ElderlyCareCompanionMedicationTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the ElderlyCareCompanionMedicationTracking to update in case it exists.
     */
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    /**
     * In case the ElderlyCareCompanionMedicationTracking found by the `where` argument doesn't exist, create a new ElderlyCareCompanionMedicationTracking with this data.
     */
    create: XOR<ElderlyCareCompanionMedicationTrackingCreateInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateInput>
    /**
     * In case the ElderlyCareCompanionMedicationTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElderlyCareCompanionMedicationTrackingUpdateInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateInput>
  }

  /**
   * ElderlyCareCompanionMedicationTracking delete
   */
  export type ElderlyCareCompanionMedicationTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
    /**
     * Filter which ElderlyCareCompanionMedicationTracking to delete.
     */
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
  }

  /**
   * ElderlyCareCompanionMedicationTracking deleteMany
   */
  export type ElderlyCareCompanionMedicationTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElderlyCareCompanionMedicationTrackings to delete
     */
    where?: ElderlyCareCompanionMedicationTrackingWhereInput
    /**
     * Limit how many ElderlyCareCompanionMedicationTrackings to delete.
     */
    limit?: number
  }

  /**
   * ElderlyCareCompanionMedicationTracking without action
   */
  export type ElderlyCareCompanionMedicationTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElderlyCareCompanionMedicationTracking
     */
    select?: ElderlyCareCompanionMedicationTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElderlyCareCompanionMedicationTracking
     */
    omit?: ElderlyCareCompanionMedicationTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElderlyCareCompanionMedicationTrackingInclude<ExtArgs> | null
  }


  /**
   * Model UserEduSeeker
   */

  export type AggregateUserEduSeeker = {
    _count: UserEduSeekerCountAggregateOutputType | null
    _min: UserEduSeekerMinAggregateOutputType | null
    _max: UserEduSeekerMaxAggregateOutputType | null
  }

  export type UserEduSeekerMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserEduSeekerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserEduSeekerCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserEduSeekerMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserEduSeekerMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserEduSeekerCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserEduSeekerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEduSeeker to aggregate.
     */
    where?: UserEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEduSeekers to fetch.
     */
    orderBy?: UserEduSeekerOrderByWithRelationInput | UserEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEduSeekers
    **/
    _count?: true | UserEduSeekerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEduSeekerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEduSeekerMaxAggregateInputType
  }

  export type GetUserEduSeekerAggregateType<T extends UserEduSeekerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEduSeeker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEduSeeker[P]>
      : GetScalarType<T[P], AggregateUserEduSeeker[P]>
  }




  export type UserEduSeekerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserEduSeekerWhereInput
    orderBy?: UserEduSeekerOrderByWithAggregationInput | UserEduSeekerOrderByWithAggregationInput[]
    by: UserEduSeekerScalarFieldEnum[] | UserEduSeekerScalarFieldEnum
    having?: UserEduSeekerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEduSeekerCountAggregateInputType | true
    _min?: UserEduSeekerMinAggregateInputType
    _max?: UserEduSeekerMaxAggregateInputType
  }

  export type UserEduSeekerGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserEduSeekerCountAggregateOutputType | null
    _min: UserEduSeekerMinAggregateOutputType | null
    _max: UserEduSeekerMaxAggregateOutputType | null
  }

  type GetUserEduSeekerGroupByPayload<T extends UserEduSeekerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserEduSeekerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEduSeekerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEduSeekerGroupByOutputType[P]>
            : GetScalarType<T[P], UserEduSeekerGroupByOutputType[P]>
        }
      >
    >


  export type UserEduSeekerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    platforms?: boolean | UserEduSeeker$platformsArgs<ExtArgs>
    reviews?: boolean | UserEduSeeker$reviewsArgs<ExtArgs>
    _count?: boolean | UserEduSeekerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userEduSeeker"]>

  export type UserEduSeekerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userEduSeeker"]>

  export type UserEduSeekerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userEduSeeker"]>

  export type UserEduSeekerSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserEduSeekerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userEduSeeker"]>
  export type UserEduSeekerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platforms?: boolean | UserEduSeeker$platformsArgs<ExtArgs>
    reviews?: boolean | UserEduSeeker$reviewsArgs<ExtArgs>
    _count?: boolean | UserEduSeekerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserEduSeekerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserEduSeekerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserEduSeekerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserEduSeeker"
    objects: {
      platforms: Prisma.$PlatformEduSeekerPayload<ExtArgs>[]
      reviews: Prisma.$ReviewEduSeekerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userEduSeeker"]>
    composites: {}
  }

  type UserEduSeekerGetPayload<S extends boolean | null | undefined | UserEduSeekerDefaultArgs> = $Result.GetResult<Prisma.$UserEduSeekerPayload, S>

  type UserEduSeekerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserEduSeekerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserEduSeekerCountAggregateInputType | true
    }

  export interface UserEduSeekerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEduSeeker'], meta: { name: 'UserEduSeeker' } }
    /**
     * Find zero or one UserEduSeeker that matches the filter.
     * @param {UserEduSeekerFindUniqueArgs} args - Arguments to find a UserEduSeeker
     * @example
     * // Get one UserEduSeeker
     * const userEduSeeker = await prisma.userEduSeeker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserEduSeekerFindUniqueArgs>(args: SelectSubset<T, UserEduSeekerFindUniqueArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserEduSeeker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserEduSeekerFindUniqueOrThrowArgs} args - Arguments to find a UserEduSeeker
     * @example
     * // Get one UserEduSeeker
     * const userEduSeeker = await prisma.userEduSeeker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserEduSeekerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserEduSeekerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEduSeeker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerFindFirstArgs} args - Arguments to find a UserEduSeeker
     * @example
     * // Get one UserEduSeeker
     * const userEduSeeker = await prisma.userEduSeeker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserEduSeekerFindFirstArgs>(args?: SelectSubset<T, UserEduSeekerFindFirstArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserEduSeeker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerFindFirstOrThrowArgs} args - Arguments to find a UserEduSeeker
     * @example
     * // Get one UserEduSeeker
     * const userEduSeeker = await prisma.userEduSeeker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserEduSeekerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserEduSeekerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserEduSeekers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEduSeekers
     * const userEduSeekers = await prisma.userEduSeeker.findMany()
     * 
     * // Get first 10 UserEduSeekers
     * const userEduSeekers = await prisma.userEduSeeker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userEduSeekerWithIdOnly = await prisma.userEduSeeker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserEduSeekerFindManyArgs>(args?: SelectSubset<T, UserEduSeekerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserEduSeeker.
     * @param {UserEduSeekerCreateArgs} args - Arguments to create a UserEduSeeker.
     * @example
     * // Create one UserEduSeeker
     * const UserEduSeeker = await prisma.userEduSeeker.create({
     *   data: {
     *     // ... data to create a UserEduSeeker
     *   }
     * })
     * 
     */
    create<T extends UserEduSeekerCreateArgs>(args: SelectSubset<T, UserEduSeekerCreateArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserEduSeekers.
     * @param {UserEduSeekerCreateManyArgs} args - Arguments to create many UserEduSeekers.
     * @example
     * // Create many UserEduSeekers
     * const userEduSeeker = await prisma.userEduSeeker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserEduSeekerCreateManyArgs>(args?: SelectSubset<T, UserEduSeekerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserEduSeekers and returns the data saved in the database.
     * @param {UserEduSeekerCreateManyAndReturnArgs} args - Arguments to create many UserEduSeekers.
     * @example
     * // Create many UserEduSeekers
     * const userEduSeeker = await prisma.userEduSeeker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserEduSeekers and only return the `id`
     * const userEduSeekerWithIdOnly = await prisma.userEduSeeker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserEduSeekerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserEduSeekerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserEduSeeker.
     * @param {UserEduSeekerDeleteArgs} args - Arguments to delete one UserEduSeeker.
     * @example
     * // Delete one UserEduSeeker
     * const UserEduSeeker = await prisma.userEduSeeker.delete({
     *   where: {
     *     // ... filter to delete one UserEduSeeker
     *   }
     * })
     * 
     */
    delete<T extends UserEduSeekerDeleteArgs>(args: SelectSubset<T, UserEduSeekerDeleteArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserEduSeeker.
     * @param {UserEduSeekerUpdateArgs} args - Arguments to update one UserEduSeeker.
     * @example
     * // Update one UserEduSeeker
     * const userEduSeeker = await prisma.userEduSeeker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserEduSeekerUpdateArgs>(args: SelectSubset<T, UserEduSeekerUpdateArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserEduSeekers.
     * @param {UserEduSeekerDeleteManyArgs} args - Arguments to filter UserEduSeekers to delete.
     * @example
     * // Delete a few UserEduSeekers
     * const { count } = await prisma.userEduSeeker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserEduSeekerDeleteManyArgs>(args?: SelectSubset<T, UserEduSeekerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEduSeekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEduSeekers
     * const userEduSeeker = await prisma.userEduSeeker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserEduSeekerUpdateManyArgs>(args: SelectSubset<T, UserEduSeekerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEduSeekers and returns the data updated in the database.
     * @param {UserEduSeekerUpdateManyAndReturnArgs} args - Arguments to update many UserEduSeekers.
     * @example
     * // Update many UserEduSeekers
     * const userEduSeeker = await prisma.userEduSeeker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserEduSeekers and only return the `id`
     * const userEduSeekerWithIdOnly = await prisma.userEduSeeker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserEduSeekerUpdateManyAndReturnArgs>(args: SelectSubset<T, UserEduSeekerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserEduSeeker.
     * @param {UserEduSeekerUpsertArgs} args - Arguments to update or create a UserEduSeeker.
     * @example
     * // Update or create a UserEduSeeker
     * const userEduSeeker = await prisma.userEduSeeker.upsert({
     *   create: {
     *     // ... data to create a UserEduSeeker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEduSeeker we want to update
     *   }
     * })
     */
    upsert<T extends UserEduSeekerUpsertArgs>(args: SelectSubset<T, UserEduSeekerUpsertArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserEduSeekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerCountArgs} args - Arguments to filter UserEduSeekers to count.
     * @example
     * // Count the number of UserEduSeekers
     * const count = await prisma.userEduSeeker.count({
     *   where: {
     *     // ... the filter for the UserEduSeekers we want to count
     *   }
     * })
    **/
    count<T extends UserEduSeekerCountArgs>(
      args?: Subset<T, UserEduSeekerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEduSeekerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEduSeeker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEduSeekerAggregateArgs>(args: Subset<T, UserEduSeekerAggregateArgs>): Prisma.PrismaPromise<GetUserEduSeekerAggregateType<T>>

    /**
     * Group by UserEduSeeker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEduSeekerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEduSeekerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEduSeekerGroupByArgs['orderBy'] }
        : { orderBy?: UserEduSeekerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEduSeekerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEduSeekerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserEduSeeker model
   */
  readonly fields: UserEduSeekerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEduSeeker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserEduSeekerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    platforms<T extends UserEduSeeker$platformsArgs<ExtArgs> = {}>(args?: Subset<T, UserEduSeeker$platformsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends UserEduSeeker$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, UserEduSeeker$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserEduSeeker model
   */ 
  interface UserEduSeekerFieldRefs {
    readonly id: FieldRef<"UserEduSeeker", 'String'>
    readonly email: FieldRef<"UserEduSeeker", 'String'>
    readonly name: FieldRef<"UserEduSeeker", 'String'>
    readonly password: FieldRef<"UserEduSeeker", 'String'>
    readonly createdAt: FieldRef<"UserEduSeeker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserEduSeeker findUnique
   */
  export type UserEduSeekerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which UserEduSeeker to fetch.
     */
    where: UserEduSeekerWhereUniqueInput
  }

  /**
   * UserEduSeeker findUniqueOrThrow
   */
  export type UserEduSeekerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which UserEduSeeker to fetch.
     */
    where: UserEduSeekerWhereUniqueInput
  }

  /**
   * UserEduSeeker findFirst
   */
  export type UserEduSeekerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which UserEduSeeker to fetch.
     */
    where?: UserEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEduSeekers to fetch.
     */
    orderBy?: UserEduSeekerOrderByWithRelationInput | UserEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEduSeekers.
     */
    cursor?: UserEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEduSeekers.
     */
    distinct?: UserEduSeekerScalarFieldEnum | UserEduSeekerScalarFieldEnum[]
  }

  /**
   * UserEduSeeker findFirstOrThrow
   */
  export type UserEduSeekerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which UserEduSeeker to fetch.
     */
    where?: UserEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEduSeekers to fetch.
     */
    orderBy?: UserEduSeekerOrderByWithRelationInput | UserEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEduSeekers.
     */
    cursor?: UserEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEduSeekers.
     */
    distinct?: UserEduSeekerScalarFieldEnum | UserEduSeekerScalarFieldEnum[]
  }

  /**
   * UserEduSeeker findMany
   */
  export type UserEduSeekerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which UserEduSeekers to fetch.
     */
    where?: UserEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEduSeekers to fetch.
     */
    orderBy?: UserEduSeekerOrderByWithRelationInput | UserEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEduSeekers.
     */
    cursor?: UserEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEduSeekers.
     */
    skip?: number
    distinct?: UserEduSeekerScalarFieldEnum | UserEduSeekerScalarFieldEnum[]
  }

  /**
   * UserEduSeeker create
   */
  export type UserEduSeekerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEduSeeker.
     */
    data: XOR<UserEduSeekerCreateInput, UserEduSeekerUncheckedCreateInput>
  }

  /**
   * UserEduSeeker createMany
   */
  export type UserEduSeekerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEduSeekers.
     */
    data: UserEduSeekerCreateManyInput | UserEduSeekerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEduSeeker createManyAndReturn
   */
  export type UserEduSeekerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * The data used to create many UserEduSeekers.
     */
    data: UserEduSeekerCreateManyInput | UserEduSeekerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserEduSeeker update
   */
  export type UserEduSeekerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEduSeeker.
     */
    data: XOR<UserEduSeekerUpdateInput, UserEduSeekerUncheckedUpdateInput>
    /**
     * Choose, which UserEduSeeker to update.
     */
    where: UserEduSeekerWhereUniqueInput
  }

  /**
   * UserEduSeeker updateMany
   */
  export type UserEduSeekerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEduSeekers.
     */
    data: XOR<UserEduSeekerUpdateManyMutationInput, UserEduSeekerUncheckedUpdateManyInput>
    /**
     * Filter which UserEduSeekers to update
     */
    where?: UserEduSeekerWhereInput
    /**
     * Limit how many UserEduSeekers to update.
     */
    limit?: number
  }

  /**
   * UserEduSeeker updateManyAndReturn
   */
  export type UserEduSeekerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * The data used to update UserEduSeekers.
     */
    data: XOR<UserEduSeekerUpdateManyMutationInput, UserEduSeekerUncheckedUpdateManyInput>
    /**
     * Filter which UserEduSeekers to update
     */
    where?: UserEduSeekerWhereInput
    /**
     * Limit how many UserEduSeekers to update.
     */
    limit?: number
  }

  /**
   * UserEduSeeker upsert
   */
  export type UserEduSeekerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEduSeeker to update in case it exists.
     */
    where: UserEduSeekerWhereUniqueInput
    /**
     * In case the UserEduSeeker found by the `where` argument doesn't exist, create a new UserEduSeeker with this data.
     */
    create: XOR<UserEduSeekerCreateInput, UserEduSeekerUncheckedCreateInput>
    /**
     * In case the UserEduSeeker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEduSeekerUpdateInput, UserEduSeekerUncheckedUpdateInput>
  }

  /**
   * UserEduSeeker delete
   */
  export type UserEduSeekerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
    /**
     * Filter which UserEduSeeker to delete.
     */
    where: UserEduSeekerWhereUniqueInput
  }

  /**
   * UserEduSeeker deleteMany
   */
  export type UserEduSeekerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEduSeekers to delete
     */
    where?: UserEduSeekerWhereInput
    /**
     * Limit how many UserEduSeekers to delete.
     */
    limit?: number
  }

  /**
   * UserEduSeeker.platforms
   */
  export type UserEduSeeker$platformsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    where?: PlatformEduSeekerWhereInput
    orderBy?: PlatformEduSeekerOrderByWithRelationInput | PlatformEduSeekerOrderByWithRelationInput[]
    cursor?: PlatformEduSeekerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformEduSeekerScalarFieldEnum | PlatformEduSeekerScalarFieldEnum[]
  }

  /**
   * UserEduSeeker.reviews
   */
  export type UserEduSeeker$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    where?: ReviewEduSeekerWhereInput
    orderBy?: ReviewEduSeekerOrderByWithRelationInput | ReviewEduSeekerOrderByWithRelationInput[]
    cursor?: ReviewEduSeekerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewEduSeekerScalarFieldEnum | ReviewEduSeekerScalarFieldEnum[]
  }

  /**
   * UserEduSeeker without action
   */
  export type UserEduSeekerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEduSeeker
     */
    select?: UserEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserEduSeeker
     */
    omit?: UserEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserEduSeekerInclude<ExtArgs> | null
  }


  /**
   * Model PlatformEduSeeker
   */

  export type AggregatePlatformEduSeeker = {
    _count: PlatformEduSeekerCountAggregateOutputType | null
    _min: PlatformEduSeekerMinAggregateOutputType | null
    _max: PlatformEduSeekerMaxAggregateOutputType | null
  }

  export type PlatformEduSeekerMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    url: string | null
    submittedBy: string | null
    createdAt: Date | null
    validated: boolean | null
  }

  export type PlatformEduSeekerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    url: string | null
    submittedBy: string | null
    createdAt: Date | null
    validated: boolean | null
  }

  export type PlatformEduSeekerCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    url: number
    submittedBy: number
    createdAt: number
    validated: number
    _all: number
  }


  export type PlatformEduSeekerMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    url?: true
    submittedBy?: true
    createdAt?: true
    validated?: true
  }

  export type PlatformEduSeekerMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    url?: true
    submittedBy?: true
    createdAt?: true
    validated?: true
  }

  export type PlatformEduSeekerCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    url?: true
    submittedBy?: true
    createdAt?: true
    validated?: true
    _all?: true
  }

  export type PlatformEduSeekerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformEduSeeker to aggregate.
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformEduSeekers to fetch.
     */
    orderBy?: PlatformEduSeekerOrderByWithRelationInput | PlatformEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformEduSeekers
    **/
    _count?: true | PlatformEduSeekerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformEduSeekerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformEduSeekerMaxAggregateInputType
  }

  export type GetPlatformEduSeekerAggregateType<T extends PlatformEduSeekerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformEduSeeker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformEduSeeker[P]>
      : GetScalarType<T[P], AggregatePlatformEduSeeker[P]>
  }




  export type PlatformEduSeekerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformEduSeekerWhereInput
    orderBy?: PlatformEduSeekerOrderByWithAggregationInput | PlatformEduSeekerOrderByWithAggregationInput[]
    by: PlatformEduSeekerScalarFieldEnum[] | PlatformEduSeekerScalarFieldEnum
    having?: PlatformEduSeekerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformEduSeekerCountAggregateInputType | true
    _min?: PlatformEduSeekerMinAggregateInputType
    _max?: PlatformEduSeekerMaxAggregateInputType
  }

  export type PlatformEduSeekerGroupByOutputType = {
    id: string
    name: string
    description: string
    category: string
    url: string
    submittedBy: string
    createdAt: Date
    validated: boolean
    _count: PlatformEduSeekerCountAggregateOutputType | null
    _min: PlatformEduSeekerMinAggregateOutputType | null
    _max: PlatformEduSeekerMaxAggregateOutputType | null
  }

  type GetPlatformEduSeekerGroupByPayload<T extends PlatformEduSeekerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformEduSeekerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformEduSeekerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformEduSeekerGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformEduSeekerGroupByOutputType[P]>
        }
      >
    >


  export type PlatformEduSeekerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    url?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    validated?: boolean
    submitter?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
    reviews?: boolean | PlatformEduSeeker$reviewsArgs<ExtArgs>
    _count?: boolean | PlatformEduSeekerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformEduSeeker"]>

  export type PlatformEduSeekerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    url?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    validated?: boolean
    submitter?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformEduSeeker"]>

  export type PlatformEduSeekerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    url?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    validated?: boolean
    submitter?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformEduSeeker"]>

  export type PlatformEduSeekerSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    url?: boolean
    submittedBy?: boolean
    createdAt?: boolean
    validated?: boolean
  }

  export type PlatformEduSeekerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "url" | "submittedBy" | "createdAt" | "validated", ExtArgs["result"]["platformEduSeeker"]>
  export type PlatformEduSeekerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
    reviews?: boolean | PlatformEduSeeker$reviewsArgs<ExtArgs>
    _count?: boolean | PlatformEduSeekerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlatformEduSeekerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }
  export type PlatformEduSeekerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submitter?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }

  export type $PlatformEduSeekerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformEduSeeker"
    objects: {
      submitter: Prisma.$UserEduSeekerPayload<ExtArgs>
      reviews: Prisma.$ReviewEduSeekerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: string
      url: string
      submittedBy: string
      createdAt: Date
      validated: boolean
    }, ExtArgs["result"]["platformEduSeeker"]>
    composites: {}
  }

  type PlatformEduSeekerGetPayload<S extends boolean | null | undefined | PlatformEduSeekerDefaultArgs> = $Result.GetResult<Prisma.$PlatformEduSeekerPayload, S>

  type PlatformEduSeekerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformEduSeekerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformEduSeekerCountAggregateInputType | true
    }

  export interface PlatformEduSeekerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformEduSeeker'], meta: { name: 'PlatformEduSeeker' } }
    /**
     * Find zero or one PlatformEduSeeker that matches the filter.
     * @param {PlatformEduSeekerFindUniqueArgs} args - Arguments to find a PlatformEduSeeker
     * @example
     * // Get one PlatformEduSeeker
     * const platformEduSeeker = await prisma.platformEduSeeker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformEduSeekerFindUniqueArgs>(args: SelectSubset<T, PlatformEduSeekerFindUniqueArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformEduSeeker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformEduSeekerFindUniqueOrThrowArgs} args - Arguments to find a PlatformEduSeeker
     * @example
     * // Get one PlatformEduSeeker
     * const platformEduSeeker = await prisma.platformEduSeeker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformEduSeekerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformEduSeekerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformEduSeeker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerFindFirstArgs} args - Arguments to find a PlatformEduSeeker
     * @example
     * // Get one PlatformEduSeeker
     * const platformEduSeeker = await prisma.platformEduSeeker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformEduSeekerFindFirstArgs>(args?: SelectSubset<T, PlatformEduSeekerFindFirstArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformEduSeeker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerFindFirstOrThrowArgs} args - Arguments to find a PlatformEduSeeker
     * @example
     * // Get one PlatformEduSeeker
     * const platformEduSeeker = await prisma.platformEduSeeker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformEduSeekerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformEduSeekerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformEduSeekers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformEduSeekers
     * const platformEduSeekers = await prisma.platformEduSeeker.findMany()
     * 
     * // Get first 10 PlatformEduSeekers
     * const platformEduSeekers = await prisma.platformEduSeeker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformEduSeekerWithIdOnly = await prisma.platformEduSeeker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformEduSeekerFindManyArgs>(args?: SelectSubset<T, PlatformEduSeekerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformEduSeeker.
     * @param {PlatformEduSeekerCreateArgs} args - Arguments to create a PlatformEduSeeker.
     * @example
     * // Create one PlatformEduSeeker
     * const PlatformEduSeeker = await prisma.platformEduSeeker.create({
     *   data: {
     *     // ... data to create a PlatformEduSeeker
     *   }
     * })
     * 
     */
    create<T extends PlatformEduSeekerCreateArgs>(args: SelectSubset<T, PlatformEduSeekerCreateArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformEduSeekers.
     * @param {PlatformEduSeekerCreateManyArgs} args - Arguments to create many PlatformEduSeekers.
     * @example
     * // Create many PlatformEduSeekers
     * const platformEduSeeker = await prisma.platformEduSeeker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformEduSeekerCreateManyArgs>(args?: SelectSubset<T, PlatformEduSeekerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformEduSeekers and returns the data saved in the database.
     * @param {PlatformEduSeekerCreateManyAndReturnArgs} args - Arguments to create many PlatformEduSeekers.
     * @example
     * // Create many PlatformEduSeekers
     * const platformEduSeeker = await prisma.platformEduSeeker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformEduSeekers and only return the `id`
     * const platformEduSeekerWithIdOnly = await prisma.platformEduSeeker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformEduSeekerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformEduSeekerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformEduSeeker.
     * @param {PlatformEduSeekerDeleteArgs} args - Arguments to delete one PlatformEduSeeker.
     * @example
     * // Delete one PlatformEduSeeker
     * const PlatformEduSeeker = await prisma.platformEduSeeker.delete({
     *   where: {
     *     // ... filter to delete one PlatformEduSeeker
     *   }
     * })
     * 
     */
    delete<T extends PlatformEduSeekerDeleteArgs>(args: SelectSubset<T, PlatformEduSeekerDeleteArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformEduSeeker.
     * @param {PlatformEduSeekerUpdateArgs} args - Arguments to update one PlatformEduSeeker.
     * @example
     * // Update one PlatformEduSeeker
     * const platformEduSeeker = await prisma.platformEduSeeker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformEduSeekerUpdateArgs>(args: SelectSubset<T, PlatformEduSeekerUpdateArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformEduSeekers.
     * @param {PlatformEduSeekerDeleteManyArgs} args - Arguments to filter PlatformEduSeekers to delete.
     * @example
     * // Delete a few PlatformEduSeekers
     * const { count } = await prisma.platformEduSeeker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformEduSeekerDeleteManyArgs>(args?: SelectSubset<T, PlatformEduSeekerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformEduSeekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformEduSeekers
     * const platformEduSeeker = await prisma.platformEduSeeker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformEduSeekerUpdateManyArgs>(args: SelectSubset<T, PlatformEduSeekerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformEduSeekers and returns the data updated in the database.
     * @param {PlatformEduSeekerUpdateManyAndReturnArgs} args - Arguments to update many PlatformEduSeekers.
     * @example
     * // Update many PlatformEduSeekers
     * const platformEduSeeker = await prisma.platformEduSeeker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformEduSeekers and only return the `id`
     * const platformEduSeekerWithIdOnly = await prisma.platformEduSeeker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformEduSeekerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformEduSeekerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformEduSeeker.
     * @param {PlatformEduSeekerUpsertArgs} args - Arguments to update or create a PlatformEduSeeker.
     * @example
     * // Update or create a PlatformEduSeeker
     * const platformEduSeeker = await prisma.platformEduSeeker.upsert({
     *   create: {
     *     // ... data to create a PlatformEduSeeker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformEduSeeker we want to update
     *   }
     * })
     */
    upsert<T extends PlatformEduSeekerUpsertArgs>(args: SelectSubset<T, PlatformEduSeekerUpsertArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformEduSeekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerCountArgs} args - Arguments to filter PlatformEduSeekers to count.
     * @example
     * // Count the number of PlatformEduSeekers
     * const count = await prisma.platformEduSeeker.count({
     *   where: {
     *     // ... the filter for the PlatformEduSeekers we want to count
     *   }
     * })
    **/
    count<T extends PlatformEduSeekerCountArgs>(
      args?: Subset<T, PlatformEduSeekerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformEduSeekerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformEduSeeker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformEduSeekerAggregateArgs>(args: Subset<T, PlatformEduSeekerAggregateArgs>): Prisma.PrismaPromise<GetPlatformEduSeekerAggregateType<T>>

    /**
     * Group by PlatformEduSeeker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformEduSeekerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformEduSeekerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformEduSeekerGroupByArgs['orderBy'] }
        : { orderBy?: PlatformEduSeekerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformEduSeekerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformEduSeekerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformEduSeeker model
   */
  readonly fields: PlatformEduSeekerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformEduSeeker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformEduSeekerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submitter<T extends UserEduSeekerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserEduSeekerDefaultArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews<T extends PlatformEduSeeker$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, PlatformEduSeeker$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformEduSeeker model
   */ 
  interface PlatformEduSeekerFieldRefs {
    readonly id: FieldRef<"PlatformEduSeeker", 'String'>
    readonly name: FieldRef<"PlatformEduSeeker", 'String'>
    readonly description: FieldRef<"PlatformEduSeeker", 'String'>
    readonly category: FieldRef<"PlatformEduSeeker", 'String'>
    readonly url: FieldRef<"PlatformEduSeeker", 'String'>
    readonly submittedBy: FieldRef<"PlatformEduSeeker", 'String'>
    readonly createdAt: FieldRef<"PlatformEduSeeker", 'DateTime'>
    readonly validated: FieldRef<"PlatformEduSeeker", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PlatformEduSeeker findUnique
   */
  export type PlatformEduSeekerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which PlatformEduSeeker to fetch.
     */
    where: PlatformEduSeekerWhereUniqueInput
  }

  /**
   * PlatformEduSeeker findUniqueOrThrow
   */
  export type PlatformEduSeekerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which PlatformEduSeeker to fetch.
     */
    where: PlatformEduSeekerWhereUniqueInput
  }

  /**
   * PlatformEduSeeker findFirst
   */
  export type PlatformEduSeekerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which PlatformEduSeeker to fetch.
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformEduSeekers to fetch.
     */
    orderBy?: PlatformEduSeekerOrderByWithRelationInput | PlatformEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformEduSeekers.
     */
    cursor?: PlatformEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformEduSeekers.
     */
    distinct?: PlatformEduSeekerScalarFieldEnum | PlatformEduSeekerScalarFieldEnum[]
  }

  /**
   * PlatformEduSeeker findFirstOrThrow
   */
  export type PlatformEduSeekerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which PlatformEduSeeker to fetch.
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformEduSeekers to fetch.
     */
    orderBy?: PlatformEduSeekerOrderByWithRelationInput | PlatformEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformEduSeekers.
     */
    cursor?: PlatformEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformEduSeekers.
     */
    distinct?: PlatformEduSeekerScalarFieldEnum | PlatformEduSeekerScalarFieldEnum[]
  }

  /**
   * PlatformEduSeeker findMany
   */
  export type PlatformEduSeekerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which PlatformEduSeekers to fetch.
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformEduSeekers to fetch.
     */
    orderBy?: PlatformEduSeekerOrderByWithRelationInput | PlatformEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformEduSeekers.
     */
    cursor?: PlatformEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformEduSeekers.
     */
    skip?: number
    distinct?: PlatformEduSeekerScalarFieldEnum | PlatformEduSeekerScalarFieldEnum[]
  }

  /**
   * PlatformEduSeeker create
   */
  export type PlatformEduSeekerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformEduSeeker.
     */
    data: XOR<PlatformEduSeekerCreateInput, PlatformEduSeekerUncheckedCreateInput>
  }

  /**
   * PlatformEduSeeker createMany
   */
  export type PlatformEduSeekerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformEduSeekers.
     */
    data: PlatformEduSeekerCreateManyInput | PlatformEduSeekerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformEduSeeker createManyAndReturn
   */
  export type PlatformEduSeekerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformEduSeekers.
     */
    data: PlatformEduSeekerCreateManyInput | PlatformEduSeekerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformEduSeeker update
   */
  export type PlatformEduSeekerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformEduSeeker.
     */
    data: XOR<PlatformEduSeekerUpdateInput, PlatformEduSeekerUncheckedUpdateInput>
    /**
     * Choose, which PlatformEduSeeker to update.
     */
    where: PlatformEduSeekerWhereUniqueInput
  }

  /**
   * PlatformEduSeeker updateMany
   */
  export type PlatformEduSeekerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformEduSeekers.
     */
    data: XOR<PlatformEduSeekerUpdateManyMutationInput, PlatformEduSeekerUncheckedUpdateManyInput>
    /**
     * Filter which PlatformEduSeekers to update
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * Limit how many PlatformEduSeekers to update.
     */
    limit?: number
  }

  /**
   * PlatformEduSeeker updateManyAndReturn
   */
  export type PlatformEduSeekerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * The data used to update PlatformEduSeekers.
     */
    data: XOR<PlatformEduSeekerUpdateManyMutationInput, PlatformEduSeekerUncheckedUpdateManyInput>
    /**
     * Filter which PlatformEduSeekers to update
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * Limit how many PlatformEduSeekers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformEduSeeker upsert
   */
  export type PlatformEduSeekerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformEduSeeker to update in case it exists.
     */
    where: PlatformEduSeekerWhereUniqueInput
    /**
     * In case the PlatformEduSeeker found by the `where` argument doesn't exist, create a new PlatformEduSeeker with this data.
     */
    create: XOR<PlatformEduSeekerCreateInput, PlatformEduSeekerUncheckedCreateInput>
    /**
     * In case the PlatformEduSeeker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformEduSeekerUpdateInput, PlatformEduSeekerUncheckedUpdateInput>
  }

  /**
   * PlatformEduSeeker delete
   */
  export type PlatformEduSeekerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
    /**
     * Filter which PlatformEduSeeker to delete.
     */
    where: PlatformEduSeekerWhereUniqueInput
  }

  /**
   * PlatformEduSeeker deleteMany
   */
  export type PlatformEduSeekerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformEduSeekers to delete
     */
    where?: PlatformEduSeekerWhereInput
    /**
     * Limit how many PlatformEduSeekers to delete.
     */
    limit?: number
  }

  /**
   * PlatformEduSeeker.reviews
   */
  export type PlatformEduSeeker$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    where?: ReviewEduSeekerWhereInput
    orderBy?: ReviewEduSeekerOrderByWithRelationInput | ReviewEduSeekerOrderByWithRelationInput[]
    cursor?: ReviewEduSeekerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewEduSeekerScalarFieldEnum | ReviewEduSeekerScalarFieldEnum[]
  }

  /**
   * PlatformEduSeeker without action
   */
  export type PlatformEduSeekerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformEduSeeker
     */
    select?: PlatformEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformEduSeeker
     */
    omit?: PlatformEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformEduSeekerInclude<ExtArgs> | null
  }


  /**
   * Model ReviewEduSeeker
   */

  export type AggregateReviewEduSeeker = {
    _count: ReviewEduSeekerCountAggregateOutputType | null
    _avg: ReviewEduSeekerAvgAggregateOutputType | null
    _sum: ReviewEduSeekerSumAggregateOutputType | null
    _min: ReviewEduSeekerMinAggregateOutputType | null
    _max: ReviewEduSeekerMaxAggregateOutputType | null
  }

  export type ReviewEduSeekerAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewEduSeekerSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewEduSeekerMinAggregateOutputType = {
    id: string | null
    platformId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type ReviewEduSeekerMaxAggregateOutputType = {
    id: string | null
    platformId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    validated: boolean | null
    createdAt: Date | null
  }

  export type ReviewEduSeekerCountAggregateOutputType = {
    id: number
    platformId: number
    userId: number
    rating: number
    comment: number
    validated: number
    createdAt: number
    _all: number
  }


  export type ReviewEduSeekerAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewEduSeekerSumAggregateInputType = {
    rating?: true
  }

  export type ReviewEduSeekerMinAggregateInputType = {
    id?: true
    platformId?: true
    userId?: true
    rating?: true
    comment?: true
    validated?: true
    createdAt?: true
  }

  export type ReviewEduSeekerMaxAggregateInputType = {
    id?: true
    platformId?: true
    userId?: true
    rating?: true
    comment?: true
    validated?: true
    createdAt?: true
  }

  export type ReviewEduSeekerCountAggregateInputType = {
    id?: true
    platformId?: true
    userId?: true
    rating?: true
    comment?: true
    validated?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewEduSeekerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewEduSeeker to aggregate.
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewEduSeekers to fetch.
     */
    orderBy?: ReviewEduSeekerOrderByWithRelationInput | ReviewEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewEduSeekers
    **/
    _count?: true | ReviewEduSeekerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewEduSeekerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewEduSeekerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewEduSeekerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewEduSeekerMaxAggregateInputType
  }

  export type GetReviewEduSeekerAggregateType<T extends ReviewEduSeekerAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewEduSeeker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewEduSeeker[P]>
      : GetScalarType<T[P], AggregateReviewEduSeeker[P]>
  }




  export type ReviewEduSeekerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewEduSeekerWhereInput
    orderBy?: ReviewEduSeekerOrderByWithAggregationInput | ReviewEduSeekerOrderByWithAggregationInput[]
    by: ReviewEduSeekerScalarFieldEnum[] | ReviewEduSeekerScalarFieldEnum
    having?: ReviewEduSeekerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewEduSeekerCountAggregateInputType | true
    _avg?: ReviewEduSeekerAvgAggregateInputType
    _sum?: ReviewEduSeekerSumAggregateInputType
    _min?: ReviewEduSeekerMinAggregateInputType
    _max?: ReviewEduSeekerMaxAggregateInputType
  }

  export type ReviewEduSeekerGroupByOutputType = {
    id: string
    platformId: string
    userId: string
    rating: number
    comment: string
    validated: boolean
    createdAt: Date
    _count: ReviewEduSeekerCountAggregateOutputType | null
    _avg: ReviewEduSeekerAvgAggregateOutputType | null
    _sum: ReviewEduSeekerSumAggregateOutputType | null
    _min: ReviewEduSeekerMinAggregateOutputType | null
    _max: ReviewEduSeekerMaxAggregateOutputType | null
  }

  type GetReviewEduSeekerGroupByPayload<T extends ReviewEduSeekerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewEduSeekerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewEduSeekerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewEduSeekerGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewEduSeekerGroupByOutputType[P]>
        }
      >
    >


  export type ReviewEduSeekerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
    platform?: boolean | PlatformEduSeekerDefaultArgs<ExtArgs>
    user?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewEduSeeker"]>

  export type ReviewEduSeekerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
    platform?: boolean | PlatformEduSeekerDefaultArgs<ExtArgs>
    user?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewEduSeeker"]>

  export type ReviewEduSeekerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
    platform?: boolean | PlatformEduSeekerDefaultArgs<ExtArgs>
    user?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewEduSeeker"]>

  export type ReviewEduSeekerSelectScalar = {
    id?: boolean
    platformId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    validated?: boolean
    createdAt?: boolean
  }

  export type ReviewEduSeekerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platformId" | "userId" | "rating" | "comment" | "validated" | "createdAt", ExtArgs["result"]["reviewEduSeeker"]>
  export type ReviewEduSeekerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformEduSeekerDefaultArgs<ExtArgs>
    user?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }
  export type ReviewEduSeekerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformEduSeekerDefaultArgs<ExtArgs>
    user?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }
  export type ReviewEduSeekerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformEduSeekerDefaultArgs<ExtArgs>
    user?: boolean | UserEduSeekerDefaultArgs<ExtArgs>
  }

  export type $ReviewEduSeekerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewEduSeeker"
    objects: {
      platform: Prisma.$PlatformEduSeekerPayload<ExtArgs>
      user: Prisma.$UserEduSeekerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platformId: string
      userId: string
      rating: number
      comment: string
      validated: boolean
      createdAt: Date
    }, ExtArgs["result"]["reviewEduSeeker"]>
    composites: {}
  }

  type ReviewEduSeekerGetPayload<S extends boolean | null | undefined | ReviewEduSeekerDefaultArgs> = $Result.GetResult<Prisma.$ReviewEduSeekerPayload, S>

  type ReviewEduSeekerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewEduSeekerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewEduSeekerCountAggregateInputType | true
    }

  export interface ReviewEduSeekerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewEduSeeker'], meta: { name: 'ReviewEduSeeker' } }
    /**
     * Find zero or one ReviewEduSeeker that matches the filter.
     * @param {ReviewEduSeekerFindUniqueArgs} args - Arguments to find a ReviewEduSeeker
     * @example
     * // Get one ReviewEduSeeker
     * const reviewEduSeeker = await prisma.reviewEduSeeker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewEduSeekerFindUniqueArgs>(args: SelectSubset<T, ReviewEduSeekerFindUniqueArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewEduSeeker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewEduSeekerFindUniqueOrThrowArgs} args - Arguments to find a ReviewEduSeeker
     * @example
     * // Get one ReviewEduSeeker
     * const reviewEduSeeker = await prisma.reviewEduSeeker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewEduSeekerFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewEduSeekerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewEduSeeker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerFindFirstArgs} args - Arguments to find a ReviewEduSeeker
     * @example
     * // Get one ReviewEduSeeker
     * const reviewEduSeeker = await prisma.reviewEduSeeker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewEduSeekerFindFirstArgs>(args?: SelectSubset<T, ReviewEduSeekerFindFirstArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewEduSeeker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerFindFirstOrThrowArgs} args - Arguments to find a ReviewEduSeeker
     * @example
     * // Get one ReviewEduSeeker
     * const reviewEduSeeker = await prisma.reviewEduSeeker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewEduSeekerFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewEduSeekerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewEduSeekers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewEduSeekers
     * const reviewEduSeekers = await prisma.reviewEduSeeker.findMany()
     * 
     * // Get first 10 ReviewEduSeekers
     * const reviewEduSeekers = await prisma.reviewEduSeeker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewEduSeekerWithIdOnly = await prisma.reviewEduSeeker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewEduSeekerFindManyArgs>(args?: SelectSubset<T, ReviewEduSeekerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewEduSeeker.
     * @param {ReviewEduSeekerCreateArgs} args - Arguments to create a ReviewEduSeeker.
     * @example
     * // Create one ReviewEduSeeker
     * const ReviewEduSeeker = await prisma.reviewEduSeeker.create({
     *   data: {
     *     // ... data to create a ReviewEduSeeker
     *   }
     * })
     * 
     */
    create<T extends ReviewEduSeekerCreateArgs>(args: SelectSubset<T, ReviewEduSeekerCreateArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewEduSeekers.
     * @param {ReviewEduSeekerCreateManyArgs} args - Arguments to create many ReviewEduSeekers.
     * @example
     * // Create many ReviewEduSeekers
     * const reviewEduSeeker = await prisma.reviewEduSeeker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewEduSeekerCreateManyArgs>(args?: SelectSubset<T, ReviewEduSeekerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewEduSeekers and returns the data saved in the database.
     * @param {ReviewEduSeekerCreateManyAndReturnArgs} args - Arguments to create many ReviewEduSeekers.
     * @example
     * // Create many ReviewEduSeekers
     * const reviewEduSeeker = await prisma.reviewEduSeeker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewEduSeekers and only return the `id`
     * const reviewEduSeekerWithIdOnly = await prisma.reviewEduSeeker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewEduSeekerCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewEduSeekerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewEduSeeker.
     * @param {ReviewEduSeekerDeleteArgs} args - Arguments to delete one ReviewEduSeeker.
     * @example
     * // Delete one ReviewEduSeeker
     * const ReviewEduSeeker = await prisma.reviewEduSeeker.delete({
     *   where: {
     *     // ... filter to delete one ReviewEduSeeker
     *   }
     * })
     * 
     */
    delete<T extends ReviewEduSeekerDeleteArgs>(args: SelectSubset<T, ReviewEduSeekerDeleteArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewEduSeeker.
     * @param {ReviewEduSeekerUpdateArgs} args - Arguments to update one ReviewEduSeeker.
     * @example
     * // Update one ReviewEduSeeker
     * const reviewEduSeeker = await prisma.reviewEduSeeker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewEduSeekerUpdateArgs>(args: SelectSubset<T, ReviewEduSeekerUpdateArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewEduSeekers.
     * @param {ReviewEduSeekerDeleteManyArgs} args - Arguments to filter ReviewEduSeekers to delete.
     * @example
     * // Delete a few ReviewEduSeekers
     * const { count } = await prisma.reviewEduSeeker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewEduSeekerDeleteManyArgs>(args?: SelectSubset<T, ReviewEduSeekerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewEduSeekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewEduSeekers
     * const reviewEduSeeker = await prisma.reviewEduSeeker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewEduSeekerUpdateManyArgs>(args: SelectSubset<T, ReviewEduSeekerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewEduSeekers and returns the data updated in the database.
     * @param {ReviewEduSeekerUpdateManyAndReturnArgs} args - Arguments to update many ReviewEduSeekers.
     * @example
     * // Update many ReviewEduSeekers
     * const reviewEduSeeker = await prisma.reviewEduSeeker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewEduSeekers and only return the `id`
     * const reviewEduSeekerWithIdOnly = await prisma.reviewEduSeeker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewEduSeekerUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewEduSeekerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewEduSeeker.
     * @param {ReviewEduSeekerUpsertArgs} args - Arguments to update or create a ReviewEduSeeker.
     * @example
     * // Update or create a ReviewEduSeeker
     * const reviewEduSeeker = await prisma.reviewEduSeeker.upsert({
     *   create: {
     *     // ... data to create a ReviewEduSeeker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewEduSeeker we want to update
     *   }
     * })
     */
    upsert<T extends ReviewEduSeekerUpsertArgs>(args: SelectSubset<T, ReviewEduSeekerUpsertArgs<ExtArgs>>): Prisma__ReviewEduSeekerClient<$Result.GetResult<Prisma.$ReviewEduSeekerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewEduSeekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerCountArgs} args - Arguments to filter ReviewEduSeekers to count.
     * @example
     * // Count the number of ReviewEduSeekers
     * const count = await prisma.reviewEduSeeker.count({
     *   where: {
     *     // ... the filter for the ReviewEduSeekers we want to count
     *   }
     * })
    **/
    count<T extends ReviewEduSeekerCountArgs>(
      args?: Subset<T, ReviewEduSeekerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewEduSeekerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewEduSeeker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewEduSeekerAggregateArgs>(args: Subset<T, ReviewEduSeekerAggregateArgs>): Prisma.PrismaPromise<GetReviewEduSeekerAggregateType<T>>

    /**
     * Group by ReviewEduSeeker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewEduSeekerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewEduSeekerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewEduSeekerGroupByArgs['orderBy'] }
        : { orderBy?: ReviewEduSeekerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewEduSeekerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewEduSeekerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewEduSeeker model
   */
  readonly fields: ReviewEduSeekerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewEduSeeker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewEduSeekerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    platform<T extends PlatformEduSeekerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformEduSeekerDefaultArgs<ExtArgs>>): Prisma__PlatformEduSeekerClient<$Result.GetResult<Prisma.$PlatformEduSeekerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserEduSeekerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserEduSeekerDefaultArgs<ExtArgs>>): Prisma__UserEduSeekerClient<$Result.GetResult<Prisma.$UserEduSeekerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewEduSeeker model
   */ 
  interface ReviewEduSeekerFieldRefs {
    readonly id: FieldRef<"ReviewEduSeeker", 'String'>
    readonly platformId: FieldRef<"ReviewEduSeeker", 'String'>
    readonly userId: FieldRef<"ReviewEduSeeker", 'String'>
    readonly rating: FieldRef<"ReviewEduSeeker", 'Int'>
    readonly comment: FieldRef<"ReviewEduSeeker", 'String'>
    readonly validated: FieldRef<"ReviewEduSeeker", 'Boolean'>
    readonly createdAt: FieldRef<"ReviewEduSeeker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewEduSeeker findUnique
   */
  export type ReviewEduSeekerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewEduSeeker to fetch.
     */
    where: ReviewEduSeekerWhereUniqueInput
  }

  /**
   * ReviewEduSeeker findUniqueOrThrow
   */
  export type ReviewEduSeekerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewEduSeeker to fetch.
     */
    where: ReviewEduSeekerWhereUniqueInput
  }

  /**
   * ReviewEduSeeker findFirst
   */
  export type ReviewEduSeekerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewEduSeeker to fetch.
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewEduSeekers to fetch.
     */
    orderBy?: ReviewEduSeekerOrderByWithRelationInput | ReviewEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewEduSeekers.
     */
    cursor?: ReviewEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewEduSeekers.
     */
    distinct?: ReviewEduSeekerScalarFieldEnum | ReviewEduSeekerScalarFieldEnum[]
  }

  /**
   * ReviewEduSeeker findFirstOrThrow
   */
  export type ReviewEduSeekerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewEduSeeker to fetch.
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewEduSeekers to fetch.
     */
    orderBy?: ReviewEduSeekerOrderByWithRelationInput | ReviewEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewEduSeekers.
     */
    cursor?: ReviewEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewEduSeekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewEduSeekers.
     */
    distinct?: ReviewEduSeekerScalarFieldEnum | ReviewEduSeekerScalarFieldEnum[]
  }

  /**
   * ReviewEduSeeker findMany
   */
  export type ReviewEduSeekerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * Filter, which ReviewEduSeekers to fetch.
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewEduSeekers to fetch.
     */
    orderBy?: ReviewEduSeekerOrderByWithRelationInput | ReviewEduSeekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewEduSeekers.
     */
    cursor?: ReviewEduSeekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewEduSeekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewEduSeekers.
     */
    skip?: number
    distinct?: ReviewEduSeekerScalarFieldEnum | ReviewEduSeekerScalarFieldEnum[]
  }

  /**
   * ReviewEduSeeker create
   */
  export type ReviewEduSeekerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewEduSeeker.
     */
    data: XOR<ReviewEduSeekerCreateInput, ReviewEduSeekerUncheckedCreateInput>
  }

  /**
   * ReviewEduSeeker createMany
   */
  export type ReviewEduSeekerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewEduSeekers.
     */
    data: ReviewEduSeekerCreateManyInput | ReviewEduSeekerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewEduSeeker createManyAndReturn
   */
  export type ReviewEduSeekerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewEduSeekers.
     */
    data: ReviewEduSeekerCreateManyInput | ReviewEduSeekerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewEduSeeker update
   */
  export type ReviewEduSeekerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewEduSeeker.
     */
    data: XOR<ReviewEduSeekerUpdateInput, ReviewEduSeekerUncheckedUpdateInput>
    /**
     * Choose, which ReviewEduSeeker to update.
     */
    where: ReviewEduSeekerWhereUniqueInput
  }

  /**
   * ReviewEduSeeker updateMany
   */
  export type ReviewEduSeekerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewEduSeekers.
     */
    data: XOR<ReviewEduSeekerUpdateManyMutationInput, ReviewEduSeekerUncheckedUpdateManyInput>
    /**
     * Filter which ReviewEduSeekers to update
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * Limit how many ReviewEduSeekers to update.
     */
    limit?: number
  }

  /**
   * ReviewEduSeeker updateManyAndReturn
   */
  export type ReviewEduSeekerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * The data used to update ReviewEduSeekers.
     */
    data: XOR<ReviewEduSeekerUpdateManyMutationInput, ReviewEduSeekerUncheckedUpdateManyInput>
    /**
     * Filter which ReviewEduSeekers to update
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * Limit how many ReviewEduSeekers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewEduSeeker upsert
   */
  export type ReviewEduSeekerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewEduSeeker to update in case it exists.
     */
    where: ReviewEduSeekerWhereUniqueInput
    /**
     * In case the ReviewEduSeeker found by the `where` argument doesn't exist, create a new ReviewEduSeeker with this data.
     */
    create: XOR<ReviewEduSeekerCreateInput, ReviewEduSeekerUncheckedCreateInput>
    /**
     * In case the ReviewEduSeeker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewEduSeekerUpdateInput, ReviewEduSeekerUncheckedUpdateInput>
  }

  /**
   * ReviewEduSeeker delete
   */
  export type ReviewEduSeekerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
    /**
     * Filter which ReviewEduSeeker to delete.
     */
    where: ReviewEduSeekerWhereUniqueInput
  }

  /**
   * ReviewEduSeeker deleteMany
   */
  export type ReviewEduSeekerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewEduSeekers to delete
     */
    where?: ReviewEduSeekerWhereInput
    /**
     * Limit how many ReviewEduSeekers to delete.
     */
    limit?: number
  }

  /**
   * ReviewEduSeeker without action
   */
  export type ReviewEduSeekerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewEduSeeker
     */
    select?: ReviewEduSeekerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewEduSeeker
     */
    omit?: ReviewEduSeekerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewEduSeekerInclude<ExtArgs> | null
  }


  /**
   * Model UserFinanceManager
   */

  export type AggregateUserFinanceManager = {
    _count: UserFinanceManagerCountAggregateOutputType | null
    _min: UserFinanceManagerMinAggregateOutputType | null
    _max: UserFinanceManagerMaxAggregateOutputType | null
  }

  export type UserFinanceManagerMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserFinanceManagerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserFinanceManagerCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserFinanceManagerMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserFinanceManagerMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserFinanceManagerCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserFinanceManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinanceManager to aggregate.
     */
    where?: UserFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinanceManagers to fetch.
     */
    orderBy?: UserFinanceManagerOrderByWithRelationInput | UserFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFinanceManagers
    **/
    _count?: true | UserFinanceManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFinanceManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFinanceManagerMaxAggregateInputType
  }

  export type GetUserFinanceManagerAggregateType<T extends UserFinanceManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFinanceManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFinanceManager[P]>
      : GetScalarType<T[P], AggregateUserFinanceManager[P]>
  }




  export type UserFinanceManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFinanceManagerWhereInput
    orderBy?: UserFinanceManagerOrderByWithAggregationInput | UserFinanceManagerOrderByWithAggregationInput[]
    by: UserFinanceManagerScalarFieldEnum[] | UserFinanceManagerScalarFieldEnum
    having?: UserFinanceManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFinanceManagerCountAggregateInputType | true
    _min?: UserFinanceManagerMinAggregateInputType
    _max?: UserFinanceManagerMaxAggregateInputType
  }

  export type UserFinanceManagerGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserFinanceManagerCountAggregateOutputType | null
    _min: UserFinanceManagerMinAggregateOutputType | null
    _max: UserFinanceManagerMaxAggregateOutputType | null
  }

  type GetUserFinanceManagerGroupByPayload<T extends UserFinanceManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFinanceManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFinanceManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFinanceManagerGroupByOutputType[P]>
            : GetScalarType<T[P], UserFinanceManagerGroupByOutputType[P]>
        }
      >
    >


  export type UserFinanceManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    transactions?: boolean | UserFinanceManager$transactionsArgs<ExtArgs>
    goals?: boolean | UserFinanceManager$goalsArgs<ExtArgs>
    _count?: boolean | UserFinanceManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFinanceManager"]>

  export type UserFinanceManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFinanceManager"]>

  export type UserFinanceManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userFinanceManager"]>

  export type UserFinanceManagerSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserFinanceManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userFinanceManager"]>
  export type UserFinanceManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | UserFinanceManager$transactionsArgs<ExtArgs>
    goals?: boolean | UserFinanceManager$goalsArgs<ExtArgs>
    _count?: boolean | UserFinanceManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserFinanceManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserFinanceManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserFinanceManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFinanceManager"
    objects: {
      transactions: Prisma.$TransactionFinanceManagerPayload<ExtArgs>[]
      goals: Prisma.$GoalFinanceManagerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userFinanceManager"]>
    composites: {}
  }

  type UserFinanceManagerGetPayload<S extends boolean | null | undefined | UserFinanceManagerDefaultArgs> = $Result.GetResult<Prisma.$UserFinanceManagerPayload, S>

  type UserFinanceManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFinanceManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFinanceManagerCountAggregateInputType | true
    }

  export interface UserFinanceManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFinanceManager'], meta: { name: 'UserFinanceManager' } }
    /**
     * Find zero or one UserFinanceManager that matches the filter.
     * @param {UserFinanceManagerFindUniqueArgs} args - Arguments to find a UserFinanceManager
     * @example
     * // Get one UserFinanceManager
     * const userFinanceManager = await prisma.userFinanceManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFinanceManagerFindUniqueArgs>(args: SelectSubset<T, UserFinanceManagerFindUniqueArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFinanceManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFinanceManagerFindUniqueOrThrowArgs} args - Arguments to find a UserFinanceManager
     * @example
     * // Get one UserFinanceManager
     * const userFinanceManager = await prisma.userFinanceManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFinanceManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFinanceManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinanceManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerFindFirstArgs} args - Arguments to find a UserFinanceManager
     * @example
     * // Get one UserFinanceManager
     * const userFinanceManager = await prisma.userFinanceManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFinanceManagerFindFirstArgs>(args?: SelectSubset<T, UserFinanceManagerFindFirstArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFinanceManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerFindFirstOrThrowArgs} args - Arguments to find a UserFinanceManager
     * @example
     * // Get one UserFinanceManager
     * const userFinanceManager = await prisma.userFinanceManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFinanceManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFinanceManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFinanceManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFinanceManagers
     * const userFinanceManagers = await prisma.userFinanceManager.findMany()
     * 
     * // Get first 10 UserFinanceManagers
     * const userFinanceManagers = await prisma.userFinanceManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFinanceManagerWithIdOnly = await prisma.userFinanceManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFinanceManagerFindManyArgs>(args?: SelectSubset<T, UserFinanceManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFinanceManager.
     * @param {UserFinanceManagerCreateArgs} args - Arguments to create a UserFinanceManager.
     * @example
     * // Create one UserFinanceManager
     * const UserFinanceManager = await prisma.userFinanceManager.create({
     *   data: {
     *     // ... data to create a UserFinanceManager
     *   }
     * })
     * 
     */
    create<T extends UserFinanceManagerCreateArgs>(args: SelectSubset<T, UserFinanceManagerCreateArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFinanceManagers.
     * @param {UserFinanceManagerCreateManyArgs} args - Arguments to create many UserFinanceManagers.
     * @example
     * // Create many UserFinanceManagers
     * const userFinanceManager = await prisma.userFinanceManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFinanceManagerCreateManyArgs>(args?: SelectSubset<T, UserFinanceManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFinanceManagers and returns the data saved in the database.
     * @param {UserFinanceManagerCreateManyAndReturnArgs} args - Arguments to create many UserFinanceManagers.
     * @example
     * // Create many UserFinanceManagers
     * const userFinanceManager = await prisma.userFinanceManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFinanceManagers and only return the `id`
     * const userFinanceManagerWithIdOnly = await prisma.userFinanceManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFinanceManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFinanceManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFinanceManager.
     * @param {UserFinanceManagerDeleteArgs} args - Arguments to delete one UserFinanceManager.
     * @example
     * // Delete one UserFinanceManager
     * const UserFinanceManager = await prisma.userFinanceManager.delete({
     *   where: {
     *     // ... filter to delete one UserFinanceManager
     *   }
     * })
     * 
     */
    delete<T extends UserFinanceManagerDeleteArgs>(args: SelectSubset<T, UserFinanceManagerDeleteArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFinanceManager.
     * @param {UserFinanceManagerUpdateArgs} args - Arguments to update one UserFinanceManager.
     * @example
     * // Update one UserFinanceManager
     * const userFinanceManager = await prisma.userFinanceManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFinanceManagerUpdateArgs>(args: SelectSubset<T, UserFinanceManagerUpdateArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFinanceManagers.
     * @param {UserFinanceManagerDeleteManyArgs} args - Arguments to filter UserFinanceManagers to delete.
     * @example
     * // Delete a few UserFinanceManagers
     * const { count } = await prisma.userFinanceManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFinanceManagerDeleteManyArgs>(args?: SelectSubset<T, UserFinanceManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinanceManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFinanceManagers
     * const userFinanceManager = await prisma.userFinanceManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFinanceManagerUpdateManyArgs>(args: SelectSubset<T, UserFinanceManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFinanceManagers and returns the data updated in the database.
     * @param {UserFinanceManagerUpdateManyAndReturnArgs} args - Arguments to update many UserFinanceManagers.
     * @example
     * // Update many UserFinanceManagers
     * const userFinanceManager = await prisma.userFinanceManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFinanceManagers and only return the `id`
     * const userFinanceManagerWithIdOnly = await prisma.userFinanceManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFinanceManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFinanceManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFinanceManager.
     * @param {UserFinanceManagerUpsertArgs} args - Arguments to update or create a UserFinanceManager.
     * @example
     * // Update or create a UserFinanceManager
     * const userFinanceManager = await prisma.userFinanceManager.upsert({
     *   create: {
     *     // ... data to create a UserFinanceManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFinanceManager we want to update
     *   }
     * })
     */
    upsert<T extends UserFinanceManagerUpsertArgs>(args: SelectSubset<T, UserFinanceManagerUpsertArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFinanceManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerCountArgs} args - Arguments to filter UserFinanceManagers to count.
     * @example
     * // Count the number of UserFinanceManagers
     * const count = await prisma.userFinanceManager.count({
     *   where: {
     *     // ... the filter for the UserFinanceManagers we want to count
     *   }
     * })
    **/
    count<T extends UserFinanceManagerCountArgs>(
      args?: Subset<T, UserFinanceManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFinanceManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFinanceManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFinanceManagerAggregateArgs>(args: Subset<T, UserFinanceManagerAggregateArgs>): Prisma.PrismaPromise<GetUserFinanceManagerAggregateType<T>>

    /**
     * Group by UserFinanceManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFinanceManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFinanceManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFinanceManagerGroupByArgs['orderBy'] }
        : { orderBy?: UserFinanceManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFinanceManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFinanceManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFinanceManager model
   */
  readonly fields: UserFinanceManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFinanceManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFinanceManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends UserFinanceManager$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, UserFinanceManager$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    goals<T extends UserFinanceManager$goalsArgs<ExtArgs> = {}>(args?: Subset<T, UserFinanceManager$goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFinanceManager model
   */ 
  interface UserFinanceManagerFieldRefs {
    readonly id: FieldRef<"UserFinanceManager", 'String'>
    readonly email: FieldRef<"UserFinanceManager", 'String'>
    readonly name: FieldRef<"UserFinanceManager", 'String'>
    readonly password: FieldRef<"UserFinanceManager", 'String'>
    readonly createdAt: FieldRef<"UserFinanceManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFinanceManager findUnique
   */
  export type UserFinanceManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which UserFinanceManager to fetch.
     */
    where: UserFinanceManagerWhereUniqueInput
  }

  /**
   * UserFinanceManager findUniqueOrThrow
   */
  export type UserFinanceManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which UserFinanceManager to fetch.
     */
    where: UserFinanceManagerWhereUniqueInput
  }

  /**
   * UserFinanceManager findFirst
   */
  export type UserFinanceManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which UserFinanceManager to fetch.
     */
    where?: UserFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinanceManagers to fetch.
     */
    orderBy?: UserFinanceManagerOrderByWithRelationInput | UserFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinanceManagers.
     */
    cursor?: UserFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinanceManagers.
     */
    distinct?: UserFinanceManagerScalarFieldEnum | UserFinanceManagerScalarFieldEnum[]
  }

  /**
   * UserFinanceManager findFirstOrThrow
   */
  export type UserFinanceManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which UserFinanceManager to fetch.
     */
    where?: UserFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinanceManagers to fetch.
     */
    orderBy?: UserFinanceManagerOrderByWithRelationInput | UserFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFinanceManagers.
     */
    cursor?: UserFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFinanceManagers.
     */
    distinct?: UserFinanceManagerScalarFieldEnum | UserFinanceManagerScalarFieldEnum[]
  }

  /**
   * UserFinanceManager findMany
   */
  export type UserFinanceManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which UserFinanceManagers to fetch.
     */
    where?: UserFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFinanceManagers to fetch.
     */
    orderBy?: UserFinanceManagerOrderByWithRelationInput | UserFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFinanceManagers.
     */
    cursor?: UserFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFinanceManagers.
     */
    skip?: number
    distinct?: UserFinanceManagerScalarFieldEnum | UserFinanceManagerScalarFieldEnum[]
  }

  /**
   * UserFinanceManager create
   */
  export type UserFinanceManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFinanceManager.
     */
    data: XOR<UserFinanceManagerCreateInput, UserFinanceManagerUncheckedCreateInput>
  }

  /**
   * UserFinanceManager createMany
   */
  export type UserFinanceManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFinanceManagers.
     */
    data: UserFinanceManagerCreateManyInput | UserFinanceManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFinanceManager createManyAndReturn
   */
  export type UserFinanceManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * The data used to create many UserFinanceManagers.
     */
    data: UserFinanceManagerCreateManyInput | UserFinanceManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFinanceManager update
   */
  export type UserFinanceManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFinanceManager.
     */
    data: XOR<UserFinanceManagerUpdateInput, UserFinanceManagerUncheckedUpdateInput>
    /**
     * Choose, which UserFinanceManager to update.
     */
    where: UserFinanceManagerWhereUniqueInput
  }

  /**
   * UserFinanceManager updateMany
   */
  export type UserFinanceManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFinanceManagers.
     */
    data: XOR<UserFinanceManagerUpdateManyMutationInput, UserFinanceManagerUncheckedUpdateManyInput>
    /**
     * Filter which UserFinanceManagers to update
     */
    where?: UserFinanceManagerWhereInput
    /**
     * Limit how many UserFinanceManagers to update.
     */
    limit?: number
  }

  /**
   * UserFinanceManager updateManyAndReturn
   */
  export type UserFinanceManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * The data used to update UserFinanceManagers.
     */
    data: XOR<UserFinanceManagerUpdateManyMutationInput, UserFinanceManagerUncheckedUpdateManyInput>
    /**
     * Filter which UserFinanceManagers to update
     */
    where?: UserFinanceManagerWhereInput
    /**
     * Limit how many UserFinanceManagers to update.
     */
    limit?: number
  }

  /**
   * UserFinanceManager upsert
   */
  export type UserFinanceManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFinanceManager to update in case it exists.
     */
    where: UserFinanceManagerWhereUniqueInput
    /**
     * In case the UserFinanceManager found by the `where` argument doesn't exist, create a new UserFinanceManager with this data.
     */
    create: XOR<UserFinanceManagerCreateInput, UserFinanceManagerUncheckedCreateInput>
    /**
     * In case the UserFinanceManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFinanceManagerUpdateInput, UserFinanceManagerUncheckedUpdateInput>
  }

  /**
   * UserFinanceManager delete
   */
  export type UserFinanceManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter which UserFinanceManager to delete.
     */
    where: UserFinanceManagerWhereUniqueInput
  }

  /**
   * UserFinanceManager deleteMany
   */
  export type UserFinanceManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFinanceManagers to delete
     */
    where?: UserFinanceManagerWhereInput
    /**
     * Limit how many UserFinanceManagers to delete.
     */
    limit?: number
  }

  /**
   * UserFinanceManager.transactions
   */
  export type UserFinanceManager$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    where?: TransactionFinanceManagerWhereInput
    orderBy?: TransactionFinanceManagerOrderByWithRelationInput | TransactionFinanceManagerOrderByWithRelationInput[]
    cursor?: TransactionFinanceManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionFinanceManagerScalarFieldEnum | TransactionFinanceManagerScalarFieldEnum[]
  }

  /**
   * UserFinanceManager.goals
   */
  export type UserFinanceManager$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    where?: GoalFinanceManagerWhereInput
    orderBy?: GoalFinanceManagerOrderByWithRelationInput | GoalFinanceManagerOrderByWithRelationInput[]
    cursor?: GoalFinanceManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalFinanceManagerScalarFieldEnum | GoalFinanceManagerScalarFieldEnum[]
  }

  /**
   * UserFinanceManager without action
   */
  export type UserFinanceManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFinanceManager
     */
    select?: UserFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFinanceManager
     */
    omit?: UserFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFinanceManagerInclude<ExtArgs> | null
  }


  /**
   * Model TransactionFinanceManager
   */

  export type AggregateTransactionFinanceManager = {
    _count: TransactionFinanceManagerCountAggregateOutputType | null
    _avg: TransactionFinanceManagerAvgAggregateOutputType | null
    _sum: TransactionFinanceManagerSumAggregateOutputType | null
    _min: TransactionFinanceManagerMinAggregateOutputType | null
    _max: TransactionFinanceManagerMaxAggregateOutputType | null
  }

  export type TransactionFinanceManagerAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionFinanceManagerSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionFinanceManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    type: string | null
    category: string | null
    source: string | null
    date: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionFinanceManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    type: string | null
    category: string | null
    source: string | null
    date: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionFinanceManagerCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    type: number
    category: number
    source: number
    date: number
    description: number
    createdAt: number
    _all: number
  }


  export type TransactionFinanceManagerAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionFinanceManagerSumAggregateInputType = {
    amount?: true
  }

  export type TransactionFinanceManagerMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    category?: true
    source?: true
    date?: true
    description?: true
    createdAt?: true
  }

  export type TransactionFinanceManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    category?: true
    source?: true
    date?: true
    description?: true
    createdAt?: true
  }

  export type TransactionFinanceManagerCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    category?: true
    source?: true
    date?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionFinanceManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionFinanceManager to aggregate.
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFinanceManagers to fetch.
     */
    orderBy?: TransactionFinanceManagerOrderByWithRelationInput | TransactionFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionFinanceManagers
    **/
    _count?: true | TransactionFinanceManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionFinanceManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionFinanceManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionFinanceManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionFinanceManagerMaxAggregateInputType
  }

  export type GetTransactionFinanceManagerAggregateType<T extends TransactionFinanceManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionFinanceManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionFinanceManager[P]>
      : GetScalarType<T[P], AggregateTransactionFinanceManager[P]>
  }




  export type TransactionFinanceManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionFinanceManagerWhereInput
    orderBy?: TransactionFinanceManagerOrderByWithAggregationInput | TransactionFinanceManagerOrderByWithAggregationInput[]
    by: TransactionFinanceManagerScalarFieldEnum[] | TransactionFinanceManagerScalarFieldEnum
    having?: TransactionFinanceManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionFinanceManagerCountAggregateInputType | true
    _avg?: TransactionFinanceManagerAvgAggregateInputType
    _sum?: TransactionFinanceManagerSumAggregateInputType
    _min?: TransactionFinanceManagerMinAggregateInputType
    _max?: TransactionFinanceManagerMaxAggregateInputType
  }

  export type TransactionFinanceManagerGroupByOutputType = {
    id: string
    userId: string
    amount: Decimal
    type: string
    category: string | null
    source: string | null
    date: Date
    description: string
    createdAt: Date
    _count: TransactionFinanceManagerCountAggregateOutputType | null
    _avg: TransactionFinanceManagerAvgAggregateOutputType | null
    _sum: TransactionFinanceManagerSumAggregateOutputType | null
    _min: TransactionFinanceManagerMinAggregateOutputType | null
    _max: TransactionFinanceManagerMaxAggregateOutputType | null
  }

  type GetTransactionFinanceManagerGroupByPayload<T extends TransactionFinanceManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionFinanceManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionFinanceManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionFinanceManagerGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionFinanceManagerGroupByOutputType[P]>
        }
      >
    >


  export type TransactionFinanceManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    category?: boolean
    source?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFinanceManager"]>

  export type TransactionFinanceManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    category?: boolean
    source?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFinanceManager"]>

  export type TransactionFinanceManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    category?: boolean
    source?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFinanceManager"]>

  export type TransactionFinanceManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    category?: boolean
    source?: boolean
    date?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type TransactionFinanceManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "type" | "category" | "source" | "date" | "description" | "createdAt", ExtArgs["result"]["transactionFinanceManager"]>
  export type TransactionFinanceManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }
  export type TransactionFinanceManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }
  export type TransactionFinanceManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }

  export type $TransactionFinanceManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionFinanceManager"
    objects: {
      user: Prisma.$UserFinanceManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: Prisma.Decimal
      type: string
      category: string | null
      source: string | null
      date: Date
      description: string
      createdAt: Date
    }, ExtArgs["result"]["transactionFinanceManager"]>
    composites: {}
  }

  type TransactionFinanceManagerGetPayload<S extends boolean | null | undefined | TransactionFinanceManagerDefaultArgs> = $Result.GetResult<Prisma.$TransactionFinanceManagerPayload, S>

  type TransactionFinanceManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFinanceManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionFinanceManagerCountAggregateInputType | true
    }

  export interface TransactionFinanceManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionFinanceManager'], meta: { name: 'TransactionFinanceManager' } }
    /**
     * Find zero or one TransactionFinanceManager that matches the filter.
     * @param {TransactionFinanceManagerFindUniqueArgs} args - Arguments to find a TransactionFinanceManager
     * @example
     * // Get one TransactionFinanceManager
     * const transactionFinanceManager = await prisma.transactionFinanceManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFinanceManagerFindUniqueArgs>(args: SelectSubset<T, TransactionFinanceManagerFindUniqueArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionFinanceManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFinanceManagerFindUniqueOrThrowArgs} args - Arguments to find a TransactionFinanceManager
     * @example
     * // Get one TransactionFinanceManager
     * const transactionFinanceManager = await prisma.transactionFinanceManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFinanceManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFinanceManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionFinanceManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerFindFirstArgs} args - Arguments to find a TransactionFinanceManager
     * @example
     * // Get one TransactionFinanceManager
     * const transactionFinanceManager = await prisma.transactionFinanceManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFinanceManagerFindFirstArgs>(args?: SelectSubset<T, TransactionFinanceManagerFindFirstArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionFinanceManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerFindFirstOrThrowArgs} args - Arguments to find a TransactionFinanceManager
     * @example
     * // Get one TransactionFinanceManager
     * const transactionFinanceManager = await prisma.transactionFinanceManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFinanceManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFinanceManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionFinanceManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionFinanceManagers
     * const transactionFinanceManagers = await prisma.transactionFinanceManager.findMany()
     * 
     * // Get first 10 TransactionFinanceManagers
     * const transactionFinanceManagers = await prisma.transactionFinanceManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionFinanceManagerWithIdOnly = await prisma.transactionFinanceManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFinanceManagerFindManyArgs>(args?: SelectSubset<T, TransactionFinanceManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionFinanceManager.
     * @param {TransactionFinanceManagerCreateArgs} args - Arguments to create a TransactionFinanceManager.
     * @example
     * // Create one TransactionFinanceManager
     * const TransactionFinanceManager = await prisma.transactionFinanceManager.create({
     *   data: {
     *     // ... data to create a TransactionFinanceManager
     *   }
     * })
     * 
     */
    create<T extends TransactionFinanceManagerCreateArgs>(args: SelectSubset<T, TransactionFinanceManagerCreateArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionFinanceManagers.
     * @param {TransactionFinanceManagerCreateManyArgs} args - Arguments to create many TransactionFinanceManagers.
     * @example
     * // Create many TransactionFinanceManagers
     * const transactionFinanceManager = await prisma.transactionFinanceManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionFinanceManagerCreateManyArgs>(args?: SelectSubset<T, TransactionFinanceManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionFinanceManagers and returns the data saved in the database.
     * @param {TransactionFinanceManagerCreateManyAndReturnArgs} args - Arguments to create many TransactionFinanceManagers.
     * @example
     * // Create many TransactionFinanceManagers
     * const transactionFinanceManager = await prisma.transactionFinanceManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionFinanceManagers and only return the `id`
     * const transactionFinanceManagerWithIdOnly = await prisma.transactionFinanceManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionFinanceManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionFinanceManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionFinanceManager.
     * @param {TransactionFinanceManagerDeleteArgs} args - Arguments to delete one TransactionFinanceManager.
     * @example
     * // Delete one TransactionFinanceManager
     * const TransactionFinanceManager = await prisma.transactionFinanceManager.delete({
     *   where: {
     *     // ... filter to delete one TransactionFinanceManager
     *   }
     * })
     * 
     */
    delete<T extends TransactionFinanceManagerDeleteArgs>(args: SelectSubset<T, TransactionFinanceManagerDeleteArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionFinanceManager.
     * @param {TransactionFinanceManagerUpdateArgs} args - Arguments to update one TransactionFinanceManager.
     * @example
     * // Update one TransactionFinanceManager
     * const transactionFinanceManager = await prisma.transactionFinanceManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionFinanceManagerUpdateArgs>(args: SelectSubset<T, TransactionFinanceManagerUpdateArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionFinanceManagers.
     * @param {TransactionFinanceManagerDeleteManyArgs} args - Arguments to filter TransactionFinanceManagers to delete.
     * @example
     * // Delete a few TransactionFinanceManagers
     * const { count } = await prisma.transactionFinanceManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionFinanceManagerDeleteManyArgs>(args?: SelectSubset<T, TransactionFinanceManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionFinanceManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionFinanceManagers
     * const transactionFinanceManager = await prisma.transactionFinanceManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionFinanceManagerUpdateManyArgs>(args: SelectSubset<T, TransactionFinanceManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionFinanceManagers and returns the data updated in the database.
     * @param {TransactionFinanceManagerUpdateManyAndReturnArgs} args - Arguments to update many TransactionFinanceManagers.
     * @example
     * // Update many TransactionFinanceManagers
     * const transactionFinanceManager = await prisma.transactionFinanceManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionFinanceManagers and only return the `id`
     * const transactionFinanceManagerWithIdOnly = await prisma.transactionFinanceManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionFinanceManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionFinanceManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionFinanceManager.
     * @param {TransactionFinanceManagerUpsertArgs} args - Arguments to update or create a TransactionFinanceManager.
     * @example
     * // Update or create a TransactionFinanceManager
     * const transactionFinanceManager = await prisma.transactionFinanceManager.upsert({
     *   create: {
     *     // ... data to create a TransactionFinanceManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionFinanceManager we want to update
     *   }
     * })
     */
    upsert<T extends TransactionFinanceManagerUpsertArgs>(args: SelectSubset<T, TransactionFinanceManagerUpsertArgs<ExtArgs>>): Prisma__TransactionFinanceManagerClient<$Result.GetResult<Prisma.$TransactionFinanceManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionFinanceManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerCountArgs} args - Arguments to filter TransactionFinanceManagers to count.
     * @example
     * // Count the number of TransactionFinanceManagers
     * const count = await prisma.transactionFinanceManager.count({
     *   where: {
     *     // ... the filter for the TransactionFinanceManagers we want to count
     *   }
     * })
    **/
    count<T extends TransactionFinanceManagerCountArgs>(
      args?: Subset<T, TransactionFinanceManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionFinanceManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionFinanceManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionFinanceManagerAggregateArgs>(args: Subset<T, TransactionFinanceManagerAggregateArgs>): Prisma.PrismaPromise<GetTransactionFinanceManagerAggregateType<T>>

    /**
     * Group by TransactionFinanceManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFinanceManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionFinanceManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionFinanceManagerGroupByArgs['orderBy'] }
        : { orderBy?: TransactionFinanceManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionFinanceManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionFinanceManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionFinanceManager model
   */
  readonly fields: TransactionFinanceManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionFinanceManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionFinanceManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFinanceManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFinanceManagerDefaultArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionFinanceManager model
   */ 
  interface TransactionFinanceManagerFieldRefs {
    readonly id: FieldRef<"TransactionFinanceManager", 'String'>
    readonly userId: FieldRef<"TransactionFinanceManager", 'String'>
    readonly amount: FieldRef<"TransactionFinanceManager", 'Decimal'>
    readonly type: FieldRef<"TransactionFinanceManager", 'String'>
    readonly category: FieldRef<"TransactionFinanceManager", 'String'>
    readonly source: FieldRef<"TransactionFinanceManager", 'String'>
    readonly date: FieldRef<"TransactionFinanceManager", 'DateTime'>
    readonly description: FieldRef<"TransactionFinanceManager", 'String'>
    readonly createdAt: FieldRef<"TransactionFinanceManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionFinanceManager findUnique
   */
  export type TransactionFinanceManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFinanceManager to fetch.
     */
    where: TransactionFinanceManagerWhereUniqueInput
  }

  /**
   * TransactionFinanceManager findUniqueOrThrow
   */
  export type TransactionFinanceManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFinanceManager to fetch.
     */
    where: TransactionFinanceManagerWhereUniqueInput
  }

  /**
   * TransactionFinanceManager findFirst
   */
  export type TransactionFinanceManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFinanceManager to fetch.
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFinanceManagers to fetch.
     */
    orderBy?: TransactionFinanceManagerOrderByWithRelationInput | TransactionFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionFinanceManagers.
     */
    cursor?: TransactionFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionFinanceManagers.
     */
    distinct?: TransactionFinanceManagerScalarFieldEnum | TransactionFinanceManagerScalarFieldEnum[]
  }

  /**
   * TransactionFinanceManager findFirstOrThrow
   */
  export type TransactionFinanceManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFinanceManager to fetch.
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFinanceManagers to fetch.
     */
    orderBy?: TransactionFinanceManagerOrderByWithRelationInput | TransactionFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionFinanceManagers.
     */
    cursor?: TransactionFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionFinanceManagers.
     */
    distinct?: TransactionFinanceManagerScalarFieldEnum | TransactionFinanceManagerScalarFieldEnum[]
  }

  /**
   * TransactionFinanceManager findMany
   */
  export type TransactionFinanceManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFinanceManagers to fetch.
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFinanceManagers to fetch.
     */
    orderBy?: TransactionFinanceManagerOrderByWithRelationInput | TransactionFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionFinanceManagers.
     */
    cursor?: TransactionFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFinanceManagers.
     */
    skip?: number
    distinct?: TransactionFinanceManagerScalarFieldEnum | TransactionFinanceManagerScalarFieldEnum[]
  }

  /**
   * TransactionFinanceManager create
   */
  export type TransactionFinanceManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionFinanceManager.
     */
    data: XOR<TransactionFinanceManagerCreateInput, TransactionFinanceManagerUncheckedCreateInput>
  }

  /**
   * TransactionFinanceManager createMany
   */
  export type TransactionFinanceManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionFinanceManagers.
     */
    data: TransactionFinanceManagerCreateManyInput | TransactionFinanceManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionFinanceManager createManyAndReturn
   */
  export type TransactionFinanceManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionFinanceManagers.
     */
    data: TransactionFinanceManagerCreateManyInput | TransactionFinanceManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionFinanceManager update
   */
  export type TransactionFinanceManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionFinanceManager.
     */
    data: XOR<TransactionFinanceManagerUpdateInput, TransactionFinanceManagerUncheckedUpdateInput>
    /**
     * Choose, which TransactionFinanceManager to update.
     */
    where: TransactionFinanceManagerWhereUniqueInput
  }

  /**
   * TransactionFinanceManager updateMany
   */
  export type TransactionFinanceManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionFinanceManagers.
     */
    data: XOR<TransactionFinanceManagerUpdateManyMutationInput, TransactionFinanceManagerUncheckedUpdateManyInput>
    /**
     * Filter which TransactionFinanceManagers to update
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * Limit how many TransactionFinanceManagers to update.
     */
    limit?: number
  }

  /**
   * TransactionFinanceManager updateManyAndReturn
   */
  export type TransactionFinanceManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * The data used to update TransactionFinanceManagers.
     */
    data: XOR<TransactionFinanceManagerUpdateManyMutationInput, TransactionFinanceManagerUncheckedUpdateManyInput>
    /**
     * Filter which TransactionFinanceManagers to update
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * Limit how many TransactionFinanceManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionFinanceManager upsert
   */
  export type TransactionFinanceManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionFinanceManager to update in case it exists.
     */
    where: TransactionFinanceManagerWhereUniqueInput
    /**
     * In case the TransactionFinanceManager found by the `where` argument doesn't exist, create a new TransactionFinanceManager with this data.
     */
    create: XOR<TransactionFinanceManagerCreateInput, TransactionFinanceManagerUncheckedCreateInput>
    /**
     * In case the TransactionFinanceManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionFinanceManagerUpdateInput, TransactionFinanceManagerUncheckedUpdateInput>
  }

  /**
   * TransactionFinanceManager delete
   */
  export type TransactionFinanceManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter which TransactionFinanceManager to delete.
     */
    where: TransactionFinanceManagerWhereUniqueInput
  }

  /**
   * TransactionFinanceManager deleteMany
   */
  export type TransactionFinanceManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionFinanceManagers to delete
     */
    where?: TransactionFinanceManagerWhereInput
    /**
     * Limit how many TransactionFinanceManagers to delete.
     */
    limit?: number
  }

  /**
   * TransactionFinanceManager without action
   */
  export type TransactionFinanceManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFinanceManager
     */
    select?: TransactionFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFinanceManager
     */
    omit?: TransactionFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFinanceManagerInclude<ExtArgs> | null
  }


  /**
   * Model GoalFinanceManager
   */

  export type AggregateGoalFinanceManager = {
    _count: GoalFinanceManagerCountAggregateOutputType | null
    _avg: GoalFinanceManagerAvgAggregateOutputType | null
    _sum: GoalFinanceManagerSumAggregateOutputType | null
    _min: GoalFinanceManagerMinAggregateOutputType | null
    _max: GoalFinanceManagerMaxAggregateOutputType | null
  }

  export type GoalFinanceManagerAvgAggregateOutputType = {
    targetAmount: Decimal | null
  }

  export type GoalFinanceManagerSumAggregateOutputType = {
    targetAmount: Decimal | null
  }

  export type GoalFinanceManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    targetAmount: Decimal | null
    deadline: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type GoalFinanceManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    targetAmount: Decimal | null
    deadline: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type GoalFinanceManagerCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    targetAmount: number
    deadline: number
    description: number
    createdAt: number
    _all: number
  }


  export type GoalFinanceManagerAvgAggregateInputType = {
    targetAmount?: true
  }

  export type GoalFinanceManagerSumAggregateInputType = {
    targetAmount?: true
  }

  export type GoalFinanceManagerMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    targetAmount?: true
    deadline?: true
    description?: true
    createdAt?: true
  }

  export type GoalFinanceManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    targetAmount?: true
    deadline?: true
    description?: true
    createdAt?: true
  }

  export type GoalFinanceManagerCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    targetAmount?: true
    deadline?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type GoalFinanceManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalFinanceManager to aggregate.
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalFinanceManagers to fetch.
     */
    orderBy?: GoalFinanceManagerOrderByWithRelationInput | GoalFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoalFinanceManagers
    **/
    _count?: true | GoalFinanceManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalFinanceManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalFinanceManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalFinanceManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalFinanceManagerMaxAggregateInputType
  }

  export type GetGoalFinanceManagerAggregateType<T extends GoalFinanceManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateGoalFinanceManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoalFinanceManager[P]>
      : GetScalarType<T[P], AggregateGoalFinanceManager[P]>
  }




  export type GoalFinanceManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalFinanceManagerWhereInput
    orderBy?: GoalFinanceManagerOrderByWithAggregationInput | GoalFinanceManagerOrderByWithAggregationInput[]
    by: GoalFinanceManagerScalarFieldEnum[] | GoalFinanceManagerScalarFieldEnum
    having?: GoalFinanceManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalFinanceManagerCountAggregateInputType | true
    _avg?: GoalFinanceManagerAvgAggregateInputType
    _sum?: GoalFinanceManagerSumAggregateInputType
    _min?: GoalFinanceManagerMinAggregateInputType
    _max?: GoalFinanceManagerMaxAggregateInputType
  }

  export type GoalFinanceManagerGroupByOutputType = {
    id: string
    userId: string
    title: string
    targetAmount: Decimal
    deadline: Date
    description: string
    createdAt: Date
    _count: GoalFinanceManagerCountAggregateOutputType | null
    _avg: GoalFinanceManagerAvgAggregateOutputType | null
    _sum: GoalFinanceManagerSumAggregateOutputType | null
    _min: GoalFinanceManagerMinAggregateOutputType | null
    _max: GoalFinanceManagerMaxAggregateOutputType | null
  }

  type GetGoalFinanceManagerGroupByPayload<T extends GoalFinanceManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalFinanceManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalFinanceManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalFinanceManagerGroupByOutputType[P]>
            : GetScalarType<T[P], GoalFinanceManagerGroupByOutputType[P]>
        }
      >
    >


  export type GoalFinanceManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    deadline?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalFinanceManager"]>

  export type GoalFinanceManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    deadline?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalFinanceManager"]>

  export type GoalFinanceManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    deadline?: boolean
    description?: boolean
    createdAt?: boolean
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalFinanceManager"]>

  export type GoalFinanceManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    targetAmount?: boolean
    deadline?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type GoalFinanceManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "targetAmount" | "deadline" | "description" | "createdAt", ExtArgs["result"]["goalFinanceManager"]>
  export type GoalFinanceManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }
  export type GoalFinanceManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }
  export type GoalFinanceManagerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserFinanceManagerDefaultArgs<ExtArgs>
  }

  export type $GoalFinanceManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoalFinanceManager"
    objects: {
      user: Prisma.$UserFinanceManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      targetAmount: Prisma.Decimal
      deadline: Date
      description: string
      createdAt: Date
    }, ExtArgs["result"]["goalFinanceManager"]>
    composites: {}
  }

  type GoalFinanceManagerGetPayload<S extends boolean | null | undefined | GoalFinanceManagerDefaultArgs> = $Result.GetResult<Prisma.$GoalFinanceManagerPayload, S>

  type GoalFinanceManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoalFinanceManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoalFinanceManagerCountAggregateInputType | true
    }

  export interface GoalFinanceManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoalFinanceManager'], meta: { name: 'GoalFinanceManager' } }
    /**
     * Find zero or one GoalFinanceManager that matches the filter.
     * @param {GoalFinanceManagerFindUniqueArgs} args - Arguments to find a GoalFinanceManager
     * @example
     * // Get one GoalFinanceManager
     * const goalFinanceManager = await prisma.goalFinanceManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFinanceManagerFindUniqueArgs>(args: SelectSubset<T, GoalFinanceManagerFindUniqueArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GoalFinanceManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFinanceManagerFindUniqueOrThrowArgs} args - Arguments to find a GoalFinanceManager
     * @example
     * // Get one GoalFinanceManager
     * const goalFinanceManager = await prisma.goalFinanceManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFinanceManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalFinanceManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoalFinanceManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerFindFirstArgs} args - Arguments to find a GoalFinanceManager
     * @example
     * // Get one GoalFinanceManager
     * const goalFinanceManager = await prisma.goalFinanceManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFinanceManagerFindFirstArgs>(args?: SelectSubset<T, GoalFinanceManagerFindFirstArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoalFinanceManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerFindFirstOrThrowArgs} args - Arguments to find a GoalFinanceManager
     * @example
     * // Get one GoalFinanceManager
     * const goalFinanceManager = await prisma.goalFinanceManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFinanceManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalFinanceManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GoalFinanceManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoalFinanceManagers
     * const goalFinanceManagers = await prisma.goalFinanceManager.findMany()
     * 
     * // Get first 10 GoalFinanceManagers
     * const goalFinanceManagers = await prisma.goalFinanceManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalFinanceManagerWithIdOnly = await prisma.goalFinanceManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalFinanceManagerFindManyArgs>(args?: SelectSubset<T, GoalFinanceManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GoalFinanceManager.
     * @param {GoalFinanceManagerCreateArgs} args - Arguments to create a GoalFinanceManager.
     * @example
     * // Create one GoalFinanceManager
     * const GoalFinanceManager = await prisma.goalFinanceManager.create({
     *   data: {
     *     // ... data to create a GoalFinanceManager
     *   }
     * })
     * 
     */
    create<T extends GoalFinanceManagerCreateArgs>(args: SelectSubset<T, GoalFinanceManagerCreateArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GoalFinanceManagers.
     * @param {GoalFinanceManagerCreateManyArgs} args - Arguments to create many GoalFinanceManagers.
     * @example
     * // Create many GoalFinanceManagers
     * const goalFinanceManager = await prisma.goalFinanceManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalFinanceManagerCreateManyArgs>(args?: SelectSubset<T, GoalFinanceManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoalFinanceManagers and returns the data saved in the database.
     * @param {GoalFinanceManagerCreateManyAndReturnArgs} args - Arguments to create many GoalFinanceManagers.
     * @example
     * // Create many GoalFinanceManagers
     * const goalFinanceManager = await prisma.goalFinanceManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoalFinanceManagers and only return the `id`
     * const goalFinanceManagerWithIdOnly = await prisma.goalFinanceManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalFinanceManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalFinanceManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GoalFinanceManager.
     * @param {GoalFinanceManagerDeleteArgs} args - Arguments to delete one GoalFinanceManager.
     * @example
     * // Delete one GoalFinanceManager
     * const GoalFinanceManager = await prisma.goalFinanceManager.delete({
     *   where: {
     *     // ... filter to delete one GoalFinanceManager
     *   }
     * })
     * 
     */
    delete<T extends GoalFinanceManagerDeleteArgs>(args: SelectSubset<T, GoalFinanceManagerDeleteArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GoalFinanceManager.
     * @param {GoalFinanceManagerUpdateArgs} args - Arguments to update one GoalFinanceManager.
     * @example
     * // Update one GoalFinanceManager
     * const goalFinanceManager = await prisma.goalFinanceManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalFinanceManagerUpdateArgs>(args: SelectSubset<T, GoalFinanceManagerUpdateArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GoalFinanceManagers.
     * @param {GoalFinanceManagerDeleteManyArgs} args - Arguments to filter GoalFinanceManagers to delete.
     * @example
     * // Delete a few GoalFinanceManagers
     * const { count } = await prisma.goalFinanceManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalFinanceManagerDeleteManyArgs>(args?: SelectSubset<T, GoalFinanceManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalFinanceManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoalFinanceManagers
     * const goalFinanceManager = await prisma.goalFinanceManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalFinanceManagerUpdateManyArgs>(args: SelectSubset<T, GoalFinanceManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalFinanceManagers and returns the data updated in the database.
     * @param {GoalFinanceManagerUpdateManyAndReturnArgs} args - Arguments to update many GoalFinanceManagers.
     * @example
     * // Update many GoalFinanceManagers
     * const goalFinanceManager = await prisma.goalFinanceManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GoalFinanceManagers and only return the `id`
     * const goalFinanceManagerWithIdOnly = await prisma.goalFinanceManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoalFinanceManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, GoalFinanceManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GoalFinanceManager.
     * @param {GoalFinanceManagerUpsertArgs} args - Arguments to update or create a GoalFinanceManager.
     * @example
     * // Update or create a GoalFinanceManager
     * const goalFinanceManager = await prisma.goalFinanceManager.upsert({
     *   create: {
     *     // ... data to create a GoalFinanceManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoalFinanceManager we want to update
     *   }
     * })
     */
    upsert<T extends GoalFinanceManagerUpsertArgs>(args: SelectSubset<T, GoalFinanceManagerUpsertArgs<ExtArgs>>): Prisma__GoalFinanceManagerClient<$Result.GetResult<Prisma.$GoalFinanceManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GoalFinanceManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerCountArgs} args - Arguments to filter GoalFinanceManagers to count.
     * @example
     * // Count the number of GoalFinanceManagers
     * const count = await prisma.goalFinanceManager.count({
     *   where: {
     *     // ... the filter for the GoalFinanceManagers we want to count
     *   }
     * })
    **/
    count<T extends GoalFinanceManagerCountArgs>(
      args?: Subset<T, GoalFinanceManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalFinanceManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoalFinanceManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalFinanceManagerAggregateArgs>(args: Subset<T, GoalFinanceManagerAggregateArgs>): Prisma.PrismaPromise<GetGoalFinanceManagerAggregateType<T>>

    /**
     * Group by GoalFinanceManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFinanceManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalFinanceManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalFinanceManagerGroupByArgs['orderBy'] }
        : { orderBy?: GoalFinanceManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalFinanceManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalFinanceManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoalFinanceManager model
   */
  readonly fields: GoalFinanceManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoalFinanceManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalFinanceManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserFinanceManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFinanceManagerDefaultArgs<ExtArgs>>): Prisma__UserFinanceManagerClient<$Result.GetResult<Prisma.$UserFinanceManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoalFinanceManager model
   */ 
  interface GoalFinanceManagerFieldRefs {
    readonly id: FieldRef<"GoalFinanceManager", 'String'>
    readonly userId: FieldRef<"GoalFinanceManager", 'String'>
    readonly title: FieldRef<"GoalFinanceManager", 'String'>
    readonly targetAmount: FieldRef<"GoalFinanceManager", 'Decimal'>
    readonly deadline: FieldRef<"GoalFinanceManager", 'DateTime'>
    readonly description: FieldRef<"GoalFinanceManager", 'String'>
    readonly createdAt: FieldRef<"GoalFinanceManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoalFinanceManager findUnique
   */
  export type GoalFinanceManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which GoalFinanceManager to fetch.
     */
    where: GoalFinanceManagerWhereUniqueInput
  }

  /**
   * GoalFinanceManager findUniqueOrThrow
   */
  export type GoalFinanceManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which GoalFinanceManager to fetch.
     */
    where: GoalFinanceManagerWhereUniqueInput
  }

  /**
   * GoalFinanceManager findFirst
   */
  export type GoalFinanceManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which GoalFinanceManager to fetch.
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalFinanceManagers to fetch.
     */
    orderBy?: GoalFinanceManagerOrderByWithRelationInput | GoalFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalFinanceManagers.
     */
    cursor?: GoalFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalFinanceManagers.
     */
    distinct?: GoalFinanceManagerScalarFieldEnum | GoalFinanceManagerScalarFieldEnum[]
  }

  /**
   * GoalFinanceManager findFirstOrThrow
   */
  export type GoalFinanceManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which GoalFinanceManager to fetch.
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalFinanceManagers to fetch.
     */
    orderBy?: GoalFinanceManagerOrderByWithRelationInput | GoalFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalFinanceManagers.
     */
    cursor?: GoalFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalFinanceManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalFinanceManagers.
     */
    distinct?: GoalFinanceManagerScalarFieldEnum | GoalFinanceManagerScalarFieldEnum[]
  }

  /**
   * GoalFinanceManager findMany
   */
  export type GoalFinanceManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter, which GoalFinanceManagers to fetch.
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalFinanceManagers to fetch.
     */
    orderBy?: GoalFinanceManagerOrderByWithRelationInput | GoalFinanceManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoalFinanceManagers.
     */
    cursor?: GoalFinanceManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalFinanceManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalFinanceManagers.
     */
    skip?: number
    distinct?: GoalFinanceManagerScalarFieldEnum | GoalFinanceManagerScalarFieldEnum[]
  }

  /**
   * GoalFinanceManager create
   */
  export type GoalFinanceManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a GoalFinanceManager.
     */
    data: XOR<GoalFinanceManagerCreateInput, GoalFinanceManagerUncheckedCreateInput>
  }

  /**
   * GoalFinanceManager createMany
   */
  export type GoalFinanceManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoalFinanceManagers.
     */
    data: GoalFinanceManagerCreateManyInput | GoalFinanceManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoalFinanceManager createManyAndReturn
   */
  export type GoalFinanceManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * The data used to create many GoalFinanceManagers.
     */
    data: GoalFinanceManagerCreateManyInput | GoalFinanceManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalFinanceManager update
   */
  export type GoalFinanceManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a GoalFinanceManager.
     */
    data: XOR<GoalFinanceManagerUpdateInput, GoalFinanceManagerUncheckedUpdateInput>
    /**
     * Choose, which GoalFinanceManager to update.
     */
    where: GoalFinanceManagerWhereUniqueInput
  }

  /**
   * GoalFinanceManager updateMany
   */
  export type GoalFinanceManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoalFinanceManagers.
     */
    data: XOR<GoalFinanceManagerUpdateManyMutationInput, GoalFinanceManagerUncheckedUpdateManyInput>
    /**
     * Filter which GoalFinanceManagers to update
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * Limit how many GoalFinanceManagers to update.
     */
    limit?: number
  }

  /**
   * GoalFinanceManager updateManyAndReturn
   */
  export type GoalFinanceManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * The data used to update GoalFinanceManagers.
     */
    data: XOR<GoalFinanceManagerUpdateManyMutationInput, GoalFinanceManagerUncheckedUpdateManyInput>
    /**
     * Filter which GoalFinanceManagers to update
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * Limit how many GoalFinanceManagers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalFinanceManager upsert
   */
  export type GoalFinanceManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the GoalFinanceManager to update in case it exists.
     */
    where: GoalFinanceManagerWhereUniqueInput
    /**
     * In case the GoalFinanceManager found by the `where` argument doesn't exist, create a new GoalFinanceManager with this data.
     */
    create: XOR<GoalFinanceManagerCreateInput, GoalFinanceManagerUncheckedCreateInput>
    /**
     * In case the GoalFinanceManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalFinanceManagerUpdateInput, GoalFinanceManagerUncheckedUpdateInput>
  }

  /**
   * GoalFinanceManager delete
   */
  export type GoalFinanceManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
    /**
     * Filter which GoalFinanceManager to delete.
     */
    where: GoalFinanceManagerWhereUniqueInput
  }

  /**
   * GoalFinanceManager deleteMany
   */
  export type GoalFinanceManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalFinanceManagers to delete
     */
    where?: GoalFinanceManagerWhereInput
    /**
     * Limit how many GoalFinanceManagers to delete.
     */
    limit?: number
  }

  /**
   * GoalFinanceManager without action
   */
  export type GoalFinanceManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalFinanceManager
     */
    select?: GoalFinanceManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoalFinanceManager
     */
    omit?: GoalFinanceManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalFinanceManagerInclude<ExtArgs> | null
  }


  /**
   * Model UserMentalWellness
   */

  export type AggregateUserMentalWellness = {
    _count: UserMentalWellnessCountAggregateOutputType | null
    _min: UserMentalWellnessMinAggregateOutputType | null
    _max: UserMentalWellnessMaxAggregateOutputType | null
  }

  export type UserMentalWellnessMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMentalWellnessMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMentalWellnessCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserMentalWellnessMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserMentalWellnessMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
  }

  export type UserMentalWellnessCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserMentalWellnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMentalWellness to aggregate.
     */
    where?: UserMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMentalWellnesses to fetch.
     */
    orderBy?: UserMentalWellnessOrderByWithRelationInput | UserMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMentalWellnesses
    **/
    _count?: true | UserMentalWellnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMentalWellnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMentalWellnessMaxAggregateInputType
  }

  export type GetUserMentalWellnessAggregateType<T extends UserMentalWellnessAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMentalWellness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMentalWellness[P]>
      : GetScalarType<T[P], AggregateUserMentalWellness[P]>
  }




  export type UserMentalWellnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMentalWellnessWhereInput
    orderBy?: UserMentalWellnessOrderByWithAggregationInput | UserMentalWellnessOrderByWithAggregationInput[]
    by: UserMentalWellnessScalarFieldEnum[] | UserMentalWellnessScalarFieldEnum
    having?: UserMentalWellnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMentalWellnessCountAggregateInputType | true
    _min?: UserMentalWellnessMinAggregateInputType
    _max?: UserMentalWellnessMaxAggregateInputType
  }

  export type UserMentalWellnessGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    createdAt: Date
    _count: UserMentalWellnessCountAggregateOutputType | null
    _min: UserMentalWellnessMinAggregateOutputType | null
    _max: UserMentalWellnessMaxAggregateOutputType | null
  }

  type GetUserMentalWellnessGroupByPayload<T extends UserMentalWellnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMentalWellnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMentalWellnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMentalWellnessGroupByOutputType[P]>
            : GetScalarType<T[P], UserMentalWellnessGroupByOutputType[P]>
        }
      >
    >


  export type UserMentalWellnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
    journals?: boolean | UserMentalWellness$journalsArgs<ExtArgs>
    assessments?: boolean | UserMentalWellness$assessmentsArgs<ExtArgs>
    feedbacks?: boolean | UserMentalWellness$feedbacksArgs<ExtArgs>
    _count?: boolean | UserMentalWellnessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMentalWellness"]>

  export type UserMentalWellnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userMentalWellness"]>

  export type UserMentalWellnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userMentalWellness"]>

  export type UserMentalWellnessSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserMentalWellnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "createdAt", ExtArgs["result"]["userMentalWellness"]>
  export type UserMentalWellnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journals?: boolean | UserMentalWellness$journalsArgs<ExtArgs>
    assessments?: boolean | UserMentalWellness$assessmentsArgs<ExtArgs>
    feedbacks?: boolean | UserMentalWellness$feedbacksArgs<ExtArgs>
    _count?: boolean | UserMentalWellnessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserMentalWellnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserMentalWellnessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserMentalWellnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMentalWellness"
    objects: {
      journals: Prisma.$JournalMentalWellnessPayload<ExtArgs>[]
      assessments: Prisma.$AssessmentMentalWellnessPayload<ExtArgs>[]
      feedbacks: Prisma.$MeditationFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["userMentalWellness"]>
    composites: {}
  }

  type UserMentalWellnessGetPayload<S extends boolean | null | undefined | UserMentalWellnessDefaultArgs> = $Result.GetResult<Prisma.$UserMentalWellnessPayload, S>

  type UserMentalWellnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMentalWellnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMentalWellnessCountAggregateInputType | true
    }

  export interface UserMentalWellnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMentalWellness'], meta: { name: 'UserMentalWellness' } }
    /**
     * Find zero or one UserMentalWellness that matches the filter.
     * @param {UserMentalWellnessFindUniqueArgs} args - Arguments to find a UserMentalWellness
     * @example
     * // Get one UserMentalWellness
     * const userMentalWellness = await prisma.userMentalWellness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMentalWellnessFindUniqueArgs>(args: SelectSubset<T, UserMentalWellnessFindUniqueArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserMentalWellness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMentalWellnessFindUniqueOrThrowArgs} args - Arguments to find a UserMentalWellness
     * @example
     * // Get one UserMentalWellness
     * const userMentalWellness = await prisma.userMentalWellness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMentalWellnessFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMentalWellnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMentalWellness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessFindFirstArgs} args - Arguments to find a UserMentalWellness
     * @example
     * // Get one UserMentalWellness
     * const userMentalWellness = await prisma.userMentalWellness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMentalWellnessFindFirstArgs>(args?: SelectSubset<T, UserMentalWellnessFindFirstArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMentalWellness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessFindFirstOrThrowArgs} args - Arguments to find a UserMentalWellness
     * @example
     * // Get one UserMentalWellness
     * const userMentalWellness = await prisma.userMentalWellness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMentalWellnessFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMentalWellnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserMentalWellnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMentalWellnesses
     * const userMentalWellnesses = await prisma.userMentalWellness.findMany()
     * 
     * // Get first 10 UserMentalWellnesses
     * const userMentalWellnesses = await prisma.userMentalWellness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMentalWellnessWithIdOnly = await prisma.userMentalWellness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMentalWellnessFindManyArgs>(args?: SelectSubset<T, UserMentalWellnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserMentalWellness.
     * @param {UserMentalWellnessCreateArgs} args - Arguments to create a UserMentalWellness.
     * @example
     * // Create one UserMentalWellness
     * const UserMentalWellness = await prisma.userMentalWellness.create({
     *   data: {
     *     // ... data to create a UserMentalWellness
     *   }
     * })
     * 
     */
    create<T extends UserMentalWellnessCreateArgs>(args: SelectSubset<T, UserMentalWellnessCreateArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserMentalWellnesses.
     * @param {UserMentalWellnessCreateManyArgs} args - Arguments to create many UserMentalWellnesses.
     * @example
     * // Create many UserMentalWellnesses
     * const userMentalWellness = await prisma.userMentalWellness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMentalWellnessCreateManyArgs>(args?: SelectSubset<T, UserMentalWellnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMentalWellnesses and returns the data saved in the database.
     * @param {UserMentalWellnessCreateManyAndReturnArgs} args - Arguments to create many UserMentalWellnesses.
     * @example
     * // Create many UserMentalWellnesses
     * const userMentalWellness = await prisma.userMentalWellness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMentalWellnesses and only return the `id`
     * const userMentalWellnessWithIdOnly = await prisma.userMentalWellness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMentalWellnessCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMentalWellnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserMentalWellness.
     * @param {UserMentalWellnessDeleteArgs} args - Arguments to delete one UserMentalWellness.
     * @example
     * // Delete one UserMentalWellness
     * const UserMentalWellness = await prisma.userMentalWellness.delete({
     *   where: {
     *     // ... filter to delete one UserMentalWellness
     *   }
     * })
     * 
     */
    delete<T extends UserMentalWellnessDeleteArgs>(args: SelectSubset<T, UserMentalWellnessDeleteArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserMentalWellness.
     * @param {UserMentalWellnessUpdateArgs} args - Arguments to update one UserMentalWellness.
     * @example
     * // Update one UserMentalWellness
     * const userMentalWellness = await prisma.userMentalWellness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMentalWellnessUpdateArgs>(args: SelectSubset<T, UserMentalWellnessUpdateArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserMentalWellnesses.
     * @param {UserMentalWellnessDeleteManyArgs} args - Arguments to filter UserMentalWellnesses to delete.
     * @example
     * // Delete a few UserMentalWellnesses
     * const { count } = await prisma.userMentalWellness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMentalWellnessDeleteManyArgs>(args?: SelectSubset<T, UserMentalWellnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMentalWellnesses
     * const userMentalWellness = await prisma.userMentalWellness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMentalWellnessUpdateManyArgs>(args: SelectSubset<T, UserMentalWellnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMentalWellnesses and returns the data updated in the database.
     * @param {UserMentalWellnessUpdateManyAndReturnArgs} args - Arguments to update many UserMentalWellnesses.
     * @example
     * // Update many UserMentalWellnesses
     * const userMentalWellness = await prisma.userMentalWellness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserMentalWellnesses and only return the `id`
     * const userMentalWellnessWithIdOnly = await prisma.userMentalWellness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserMentalWellnessUpdateManyAndReturnArgs>(args: SelectSubset<T, UserMentalWellnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserMentalWellness.
     * @param {UserMentalWellnessUpsertArgs} args - Arguments to update or create a UserMentalWellness.
     * @example
     * // Update or create a UserMentalWellness
     * const userMentalWellness = await prisma.userMentalWellness.upsert({
     *   create: {
     *     // ... data to create a UserMentalWellness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMentalWellness we want to update
     *   }
     * })
     */
    upsert<T extends UserMentalWellnessUpsertArgs>(args: SelectSubset<T, UserMentalWellnessUpsertArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessCountArgs} args - Arguments to filter UserMentalWellnesses to count.
     * @example
     * // Count the number of UserMentalWellnesses
     * const count = await prisma.userMentalWellness.count({
     *   where: {
     *     // ... the filter for the UserMentalWellnesses we want to count
     *   }
     * })
    **/
    count<T extends UserMentalWellnessCountArgs>(
      args?: Subset<T, UserMentalWellnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMentalWellnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMentalWellnessAggregateArgs>(args: Subset<T, UserMentalWellnessAggregateArgs>): Prisma.PrismaPromise<GetUserMentalWellnessAggregateType<T>>

    /**
     * Group by UserMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMentalWellnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMentalWellnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMentalWellnessGroupByArgs['orderBy'] }
        : { orderBy?: UserMentalWellnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMentalWellnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMentalWellnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMentalWellness model
   */
  readonly fields: UserMentalWellnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMentalWellness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMentalWellnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journals<T extends UserMentalWellness$journalsArgs<ExtArgs> = {}>(args?: Subset<T, UserMentalWellness$journalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assessments<T extends UserMentalWellness$assessmentsArgs<ExtArgs> = {}>(args?: Subset<T, UserMentalWellness$assessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends UserMentalWellness$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, UserMentalWellness$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMentalWellness model
   */ 
  interface UserMentalWellnessFieldRefs {
    readonly id: FieldRef<"UserMentalWellness", 'String'>
    readonly email: FieldRef<"UserMentalWellness", 'String'>
    readonly name: FieldRef<"UserMentalWellness", 'String'>
    readonly password: FieldRef<"UserMentalWellness", 'String'>
    readonly createdAt: FieldRef<"UserMentalWellness", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMentalWellness findUnique
   */
  export type UserMentalWellnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which UserMentalWellness to fetch.
     */
    where: UserMentalWellnessWhereUniqueInput
  }

  /**
   * UserMentalWellness findUniqueOrThrow
   */
  export type UserMentalWellnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which UserMentalWellness to fetch.
     */
    where: UserMentalWellnessWhereUniqueInput
  }

  /**
   * UserMentalWellness findFirst
   */
  export type UserMentalWellnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which UserMentalWellness to fetch.
     */
    where?: UserMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMentalWellnesses to fetch.
     */
    orderBy?: UserMentalWellnessOrderByWithRelationInput | UserMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMentalWellnesses.
     */
    cursor?: UserMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMentalWellnesses.
     */
    distinct?: UserMentalWellnessScalarFieldEnum | UserMentalWellnessScalarFieldEnum[]
  }

  /**
   * UserMentalWellness findFirstOrThrow
   */
  export type UserMentalWellnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which UserMentalWellness to fetch.
     */
    where?: UserMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMentalWellnesses to fetch.
     */
    orderBy?: UserMentalWellnessOrderByWithRelationInput | UserMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMentalWellnesses.
     */
    cursor?: UserMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMentalWellnesses.
     */
    distinct?: UserMentalWellnessScalarFieldEnum | UserMentalWellnessScalarFieldEnum[]
  }

  /**
   * UserMentalWellness findMany
   */
  export type UserMentalWellnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which UserMentalWellnesses to fetch.
     */
    where?: UserMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMentalWellnesses to fetch.
     */
    orderBy?: UserMentalWellnessOrderByWithRelationInput | UserMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMentalWellnesses.
     */
    cursor?: UserMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMentalWellnesses.
     */
    skip?: number
    distinct?: UserMentalWellnessScalarFieldEnum | UserMentalWellnessScalarFieldEnum[]
  }

  /**
   * UserMentalWellness create
   */
  export type UserMentalWellnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMentalWellness.
     */
    data: XOR<UserMentalWellnessCreateInput, UserMentalWellnessUncheckedCreateInput>
  }

  /**
   * UserMentalWellness createMany
   */
  export type UserMentalWellnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMentalWellnesses.
     */
    data: UserMentalWellnessCreateManyInput | UserMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMentalWellness createManyAndReturn
   */
  export type UserMentalWellnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to create many UserMentalWellnesses.
     */
    data: UserMentalWellnessCreateManyInput | UserMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMentalWellness update
   */
  export type UserMentalWellnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMentalWellness.
     */
    data: XOR<UserMentalWellnessUpdateInput, UserMentalWellnessUncheckedUpdateInput>
    /**
     * Choose, which UserMentalWellness to update.
     */
    where: UserMentalWellnessWhereUniqueInput
  }

  /**
   * UserMentalWellness updateMany
   */
  export type UserMentalWellnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMentalWellnesses.
     */
    data: XOR<UserMentalWellnessUpdateManyMutationInput, UserMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which UserMentalWellnesses to update
     */
    where?: UserMentalWellnessWhereInput
    /**
     * Limit how many UserMentalWellnesses to update.
     */
    limit?: number
  }

  /**
   * UserMentalWellness updateManyAndReturn
   */
  export type UserMentalWellnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to update UserMentalWellnesses.
     */
    data: XOR<UserMentalWellnessUpdateManyMutationInput, UserMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which UserMentalWellnesses to update
     */
    where?: UserMentalWellnessWhereInput
    /**
     * Limit how many UserMentalWellnesses to update.
     */
    limit?: number
  }

  /**
   * UserMentalWellness upsert
   */
  export type UserMentalWellnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMentalWellness to update in case it exists.
     */
    where: UserMentalWellnessWhereUniqueInput
    /**
     * In case the UserMentalWellness found by the `where` argument doesn't exist, create a new UserMentalWellness with this data.
     */
    create: XOR<UserMentalWellnessCreateInput, UserMentalWellnessUncheckedCreateInput>
    /**
     * In case the UserMentalWellness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMentalWellnessUpdateInput, UserMentalWellnessUncheckedUpdateInput>
  }

  /**
   * UserMentalWellness delete
   */
  export type UserMentalWellnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter which UserMentalWellness to delete.
     */
    where: UserMentalWellnessWhereUniqueInput
  }

  /**
   * UserMentalWellness deleteMany
   */
  export type UserMentalWellnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMentalWellnesses to delete
     */
    where?: UserMentalWellnessWhereInput
    /**
     * Limit how many UserMentalWellnesses to delete.
     */
    limit?: number
  }

  /**
   * UserMentalWellness.journals
   */
  export type UserMentalWellness$journalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    where?: JournalMentalWellnessWhereInput
    orderBy?: JournalMentalWellnessOrderByWithRelationInput | JournalMentalWellnessOrderByWithRelationInput[]
    cursor?: JournalMentalWellnessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalMentalWellnessScalarFieldEnum | JournalMentalWellnessScalarFieldEnum[]
  }

  /**
   * UserMentalWellness.assessments
   */
  export type UserMentalWellness$assessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    where?: AssessmentMentalWellnessWhereInput
    orderBy?: AssessmentMentalWellnessOrderByWithRelationInput | AssessmentMentalWellnessOrderByWithRelationInput[]
    cursor?: AssessmentMentalWellnessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentMentalWellnessScalarFieldEnum | AssessmentMentalWellnessScalarFieldEnum[]
  }

  /**
   * UserMentalWellness.feedbacks
   */
  export type UserMentalWellness$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    where?: MeditationFeedbackWhereInput
    orderBy?: MeditationFeedbackOrderByWithRelationInput | MeditationFeedbackOrderByWithRelationInput[]
    cursor?: MeditationFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeditationFeedbackScalarFieldEnum | MeditationFeedbackScalarFieldEnum[]
  }

  /**
   * UserMentalWellness without action
   */
  export type UserMentalWellnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMentalWellness
     */
    select?: UserMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMentalWellness
     */
    omit?: UserMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMentalWellnessInclude<ExtArgs> | null
  }


  /**
   * Model JournalMentalWellness
   */

  export type AggregateJournalMentalWellness = {
    _count: JournalMentalWellnessCountAggregateOutputType | null
    _min: JournalMentalWellnessMinAggregateOutputType | null
    _max: JournalMentalWellnessMaxAggregateOutputType | null
  }

  export type JournalMentalWellnessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mood: string | null
    entryText: string | null
    createdAt: Date | null
  }

  export type JournalMentalWellnessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mood: string | null
    entryText: string | null
    createdAt: Date | null
  }

  export type JournalMentalWellnessCountAggregateOutputType = {
    id: number
    userId: number
    mood: number
    entryText: number
    tags: number
    createdAt: number
    _all: number
  }


  export type JournalMentalWellnessMinAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    entryText?: true
    createdAt?: true
  }

  export type JournalMentalWellnessMaxAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    entryText?: true
    createdAt?: true
  }

  export type JournalMentalWellnessCountAggregateInputType = {
    id?: true
    userId?: true
    mood?: true
    entryText?: true
    tags?: true
    createdAt?: true
    _all?: true
  }

  export type JournalMentalWellnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalMentalWellness to aggregate.
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalMentalWellnesses to fetch.
     */
    orderBy?: JournalMentalWellnessOrderByWithRelationInput | JournalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalMentalWellnesses
    **/
    _count?: true | JournalMentalWellnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMentalWellnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMentalWellnessMaxAggregateInputType
  }

  export type GetJournalMentalWellnessAggregateType<T extends JournalMentalWellnessAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalMentalWellness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalMentalWellness[P]>
      : GetScalarType<T[P], AggregateJournalMentalWellness[P]>
  }




  export type JournalMentalWellnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalMentalWellnessWhereInput
    orderBy?: JournalMentalWellnessOrderByWithAggregationInput | JournalMentalWellnessOrderByWithAggregationInput[]
    by: JournalMentalWellnessScalarFieldEnum[] | JournalMentalWellnessScalarFieldEnum
    having?: JournalMentalWellnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalMentalWellnessCountAggregateInputType | true
    _min?: JournalMentalWellnessMinAggregateInputType
    _max?: JournalMentalWellnessMaxAggregateInputType
  }

  export type JournalMentalWellnessGroupByOutputType = {
    id: string
    userId: string
    mood: string
    entryText: string
    tags: string[]
    createdAt: Date
    _count: JournalMentalWellnessCountAggregateOutputType | null
    _min: JournalMentalWellnessMinAggregateOutputType | null
    _max: JournalMentalWellnessMaxAggregateOutputType | null
  }

  type GetJournalMentalWellnessGroupByPayload<T extends JournalMentalWellnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalMentalWellnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalMentalWellnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalMentalWellnessGroupByOutputType[P]>
            : GetScalarType<T[P], JournalMentalWellnessGroupByOutputType[P]>
        }
      >
    >


  export type JournalMentalWellnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    entryText?: boolean
    tags?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalMentalWellness"]>

  export type JournalMentalWellnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    entryText?: boolean
    tags?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalMentalWellness"]>

  export type JournalMentalWellnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mood?: boolean
    entryText?: boolean
    tags?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalMentalWellness"]>

  export type JournalMentalWellnessSelectScalar = {
    id?: boolean
    userId?: boolean
    mood?: boolean
    entryText?: boolean
    tags?: boolean
    createdAt?: boolean
  }

  export type JournalMentalWellnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mood" | "entryText" | "tags" | "createdAt", ExtArgs["result"]["journalMentalWellness"]>
  export type JournalMentalWellnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }
  export type JournalMentalWellnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }
  export type JournalMentalWellnessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }

  export type $JournalMentalWellnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalMentalWellness"
    objects: {
      user: Prisma.$UserMentalWellnessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mood: string
      entryText: string
      tags: string[]
      createdAt: Date
    }, ExtArgs["result"]["journalMentalWellness"]>
    composites: {}
  }

  type JournalMentalWellnessGetPayload<S extends boolean | null | undefined | JournalMentalWellnessDefaultArgs> = $Result.GetResult<Prisma.$JournalMentalWellnessPayload, S>

  type JournalMentalWellnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalMentalWellnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalMentalWellnessCountAggregateInputType | true
    }

  export interface JournalMentalWellnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalMentalWellness'], meta: { name: 'JournalMentalWellness' } }
    /**
     * Find zero or one JournalMentalWellness that matches the filter.
     * @param {JournalMentalWellnessFindUniqueArgs} args - Arguments to find a JournalMentalWellness
     * @example
     * // Get one JournalMentalWellness
     * const journalMentalWellness = await prisma.journalMentalWellness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalMentalWellnessFindUniqueArgs>(args: SelectSubset<T, JournalMentalWellnessFindUniqueArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalMentalWellness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalMentalWellnessFindUniqueOrThrowArgs} args - Arguments to find a JournalMentalWellness
     * @example
     * // Get one JournalMentalWellness
     * const journalMentalWellness = await prisma.journalMentalWellness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalMentalWellnessFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalMentalWellnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalMentalWellness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessFindFirstArgs} args - Arguments to find a JournalMentalWellness
     * @example
     * // Get one JournalMentalWellness
     * const journalMentalWellness = await prisma.journalMentalWellness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalMentalWellnessFindFirstArgs>(args?: SelectSubset<T, JournalMentalWellnessFindFirstArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalMentalWellness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessFindFirstOrThrowArgs} args - Arguments to find a JournalMentalWellness
     * @example
     * // Get one JournalMentalWellness
     * const journalMentalWellness = await prisma.journalMentalWellness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalMentalWellnessFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalMentalWellnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalMentalWellnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalMentalWellnesses
     * const journalMentalWellnesses = await prisma.journalMentalWellness.findMany()
     * 
     * // Get first 10 JournalMentalWellnesses
     * const journalMentalWellnesses = await prisma.journalMentalWellness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalMentalWellnessWithIdOnly = await prisma.journalMentalWellness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalMentalWellnessFindManyArgs>(args?: SelectSubset<T, JournalMentalWellnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalMentalWellness.
     * @param {JournalMentalWellnessCreateArgs} args - Arguments to create a JournalMentalWellness.
     * @example
     * // Create one JournalMentalWellness
     * const JournalMentalWellness = await prisma.journalMentalWellness.create({
     *   data: {
     *     // ... data to create a JournalMentalWellness
     *   }
     * })
     * 
     */
    create<T extends JournalMentalWellnessCreateArgs>(args: SelectSubset<T, JournalMentalWellnessCreateArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalMentalWellnesses.
     * @param {JournalMentalWellnessCreateManyArgs} args - Arguments to create many JournalMentalWellnesses.
     * @example
     * // Create many JournalMentalWellnesses
     * const journalMentalWellness = await prisma.journalMentalWellness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalMentalWellnessCreateManyArgs>(args?: SelectSubset<T, JournalMentalWellnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalMentalWellnesses and returns the data saved in the database.
     * @param {JournalMentalWellnessCreateManyAndReturnArgs} args - Arguments to create many JournalMentalWellnesses.
     * @example
     * // Create many JournalMentalWellnesses
     * const journalMentalWellness = await prisma.journalMentalWellness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalMentalWellnesses and only return the `id`
     * const journalMentalWellnessWithIdOnly = await prisma.journalMentalWellness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalMentalWellnessCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalMentalWellnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalMentalWellness.
     * @param {JournalMentalWellnessDeleteArgs} args - Arguments to delete one JournalMentalWellness.
     * @example
     * // Delete one JournalMentalWellness
     * const JournalMentalWellness = await prisma.journalMentalWellness.delete({
     *   where: {
     *     // ... filter to delete one JournalMentalWellness
     *   }
     * })
     * 
     */
    delete<T extends JournalMentalWellnessDeleteArgs>(args: SelectSubset<T, JournalMentalWellnessDeleteArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalMentalWellness.
     * @param {JournalMentalWellnessUpdateArgs} args - Arguments to update one JournalMentalWellness.
     * @example
     * // Update one JournalMentalWellness
     * const journalMentalWellness = await prisma.journalMentalWellness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalMentalWellnessUpdateArgs>(args: SelectSubset<T, JournalMentalWellnessUpdateArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalMentalWellnesses.
     * @param {JournalMentalWellnessDeleteManyArgs} args - Arguments to filter JournalMentalWellnesses to delete.
     * @example
     * // Delete a few JournalMentalWellnesses
     * const { count } = await prisma.journalMentalWellness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalMentalWellnessDeleteManyArgs>(args?: SelectSubset<T, JournalMentalWellnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalMentalWellnesses
     * const journalMentalWellness = await prisma.journalMentalWellness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalMentalWellnessUpdateManyArgs>(args: SelectSubset<T, JournalMentalWellnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalMentalWellnesses and returns the data updated in the database.
     * @param {JournalMentalWellnessUpdateManyAndReturnArgs} args - Arguments to update many JournalMentalWellnesses.
     * @example
     * // Update many JournalMentalWellnesses
     * const journalMentalWellness = await prisma.journalMentalWellness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalMentalWellnesses and only return the `id`
     * const journalMentalWellnessWithIdOnly = await prisma.journalMentalWellness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalMentalWellnessUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalMentalWellnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalMentalWellness.
     * @param {JournalMentalWellnessUpsertArgs} args - Arguments to update or create a JournalMentalWellness.
     * @example
     * // Update or create a JournalMentalWellness
     * const journalMentalWellness = await prisma.journalMentalWellness.upsert({
     *   create: {
     *     // ... data to create a JournalMentalWellness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalMentalWellness we want to update
     *   }
     * })
     */
    upsert<T extends JournalMentalWellnessUpsertArgs>(args: SelectSubset<T, JournalMentalWellnessUpsertArgs<ExtArgs>>): Prisma__JournalMentalWellnessClient<$Result.GetResult<Prisma.$JournalMentalWellnessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessCountArgs} args - Arguments to filter JournalMentalWellnesses to count.
     * @example
     * // Count the number of JournalMentalWellnesses
     * const count = await prisma.journalMentalWellness.count({
     *   where: {
     *     // ... the filter for the JournalMentalWellnesses we want to count
     *   }
     * })
    **/
    count<T extends JournalMentalWellnessCountArgs>(
      args?: Subset<T, JournalMentalWellnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalMentalWellnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalMentalWellnessAggregateArgs>(args: Subset<T, JournalMentalWellnessAggregateArgs>): Prisma.PrismaPromise<GetJournalMentalWellnessAggregateType<T>>

    /**
     * Group by JournalMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalMentalWellnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalMentalWellnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalMentalWellnessGroupByArgs['orderBy'] }
        : { orderBy?: JournalMentalWellnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalMentalWellnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalMentalWellnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalMentalWellness model
   */
  readonly fields: JournalMentalWellnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalMentalWellness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalMentalWellnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserMentalWellnessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserMentalWellnessDefaultArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalMentalWellness model
   */ 
  interface JournalMentalWellnessFieldRefs {
    readonly id: FieldRef<"JournalMentalWellness", 'String'>
    readonly userId: FieldRef<"JournalMentalWellness", 'String'>
    readonly mood: FieldRef<"JournalMentalWellness", 'String'>
    readonly entryText: FieldRef<"JournalMentalWellness", 'String'>
    readonly tags: FieldRef<"JournalMentalWellness", 'String[]'>
    readonly createdAt: FieldRef<"JournalMentalWellness", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalMentalWellness findUnique
   */
  export type JournalMentalWellnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which JournalMentalWellness to fetch.
     */
    where: JournalMentalWellnessWhereUniqueInput
  }

  /**
   * JournalMentalWellness findUniqueOrThrow
   */
  export type JournalMentalWellnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which JournalMentalWellness to fetch.
     */
    where: JournalMentalWellnessWhereUniqueInput
  }

  /**
   * JournalMentalWellness findFirst
   */
  export type JournalMentalWellnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which JournalMentalWellness to fetch.
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalMentalWellnesses to fetch.
     */
    orderBy?: JournalMentalWellnessOrderByWithRelationInput | JournalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalMentalWellnesses.
     */
    cursor?: JournalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalMentalWellnesses.
     */
    distinct?: JournalMentalWellnessScalarFieldEnum | JournalMentalWellnessScalarFieldEnum[]
  }

  /**
   * JournalMentalWellness findFirstOrThrow
   */
  export type JournalMentalWellnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which JournalMentalWellness to fetch.
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalMentalWellnesses to fetch.
     */
    orderBy?: JournalMentalWellnessOrderByWithRelationInput | JournalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalMentalWellnesses.
     */
    cursor?: JournalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalMentalWellnesses.
     */
    distinct?: JournalMentalWellnessScalarFieldEnum | JournalMentalWellnessScalarFieldEnum[]
  }

  /**
   * JournalMentalWellness findMany
   */
  export type JournalMentalWellnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which JournalMentalWellnesses to fetch.
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalMentalWellnesses to fetch.
     */
    orderBy?: JournalMentalWellnessOrderByWithRelationInput | JournalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalMentalWellnesses.
     */
    cursor?: JournalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalMentalWellnesses.
     */
    skip?: number
    distinct?: JournalMentalWellnessScalarFieldEnum | JournalMentalWellnessScalarFieldEnum[]
  }

  /**
   * JournalMentalWellness create
   */
  export type JournalMentalWellnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalMentalWellness.
     */
    data: XOR<JournalMentalWellnessCreateInput, JournalMentalWellnessUncheckedCreateInput>
  }

  /**
   * JournalMentalWellness createMany
   */
  export type JournalMentalWellnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalMentalWellnesses.
     */
    data: JournalMentalWellnessCreateManyInput | JournalMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalMentalWellness createManyAndReturn
   */
  export type JournalMentalWellnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to create many JournalMentalWellnesses.
     */
    data: JournalMentalWellnessCreateManyInput | JournalMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalMentalWellness update
   */
  export type JournalMentalWellnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalMentalWellness.
     */
    data: XOR<JournalMentalWellnessUpdateInput, JournalMentalWellnessUncheckedUpdateInput>
    /**
     * Choose, which JournalMentalWellness to update.
     */
    where: JournalMentalWellnessWhereUniqueInput
  }

  /**
   * JournalMentalWellness updateMany
   */
  export type JournalMentalWellnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalMentalWellnesses.
     */
    data: XOR<JournalMentalWellnessUpdateManyMutationInput, JournalMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which JournalMentalWellnesses to update
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * Limit how many JournalMentalWellnesses to update.
     */
    limit?: number
  }

  /**
   * JournalMentalWellness updateManyAndReturn
   */
  export type JournalMentalWellnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to update JournalMentalWellnesses.
     */
    data: XOR<JournalMentalWellnessUpdateManyMutationInput, JournalMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which JournalMentalWellnesses to update
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * Limit how many JournalMentalWellnesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalMentalWellness upsert
   */
  export type JournalMentalWellnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalMentalWellness to update in case it exists.
     */
    where: JournalMentalWellnessWhereUniqueInput
    /**
     * In case the JournalMentalWellness found by the `where` argument doesn't exist, create a new JournalMentalWellness with this data.
     */
    create: XOR<JournalMentalWellnessCreateInput, JournalMentalWellnessUncheckedCreateInput>
    /**
     * In case the JournalMentalWellness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalMentalWellnessUpdateInput, JournalMentalWellnessUncheckedUpdateInput>
  }

  /**
   * JournalMentalWellness delete
   */
  export type JournalMentalWellnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter which JournalMentalWellness to delete.
     */
    where: JournalMentalWellnessWhereUniqueInput
  }

  /**
   * JournalMentalWellness deleteMany
   */
  export type JournalMentalWellnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalMentalWellnesses to delete
     */
    where?: JournalMentalWellnessWhereInput
    /**
     * Limit how many JournalMentalWellnesses to delete.
     */
    limit?: number
  }

  /**
   * JournalMentalWellness without action
   */
  export type JournalMentalWellnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalMentalWellness
     */
    select?: JournalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalMentalWellness
     */
    omit?: JournalMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalMentalWellnessInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentMentalWellness
   */

  export type AggregateAssessmentMentalWellness = {
    _count: AssessmentMentalWellnessCountAggregateOutputType | null
    _min: AssessmentMentalWellnessMinAggregateOutputType | null
    _max: AssessmentMentalWellnessMaxAggregateOutputType | null
  }

  export type AssessmentMentalWellnessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    result: string | null
    createdAt: Date | null
  }

  export type AssessmentMentalWellnessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    result: string | null
    createdAt: Date | null
  }

  export type AssessmentMentalWellnessCountAggregateOutputType = {
    id: number
    userId: number
    responses: number
    result: number
    createdAt: number
    _all: number
  }


  export type AssessmentMentalWellnessMinAggregateInputType = {
    id?: true
    userId?: true
    result?: true
    createdAt?: true
  }

  export type AssessmentMentalWellnessMaxAggregateInputType = {
    id?: true
    userId?: true
    result?: true
    createdAt?: true
  }

  export type AssessmentMentalWellnessCountAggregateInputType = {
    id?: true
    userId?: true
    responses?: true
    result?: true
    createdAt?: true
    _all?: true
  }

  export type AssessmentMentalWellnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentMentalWellness to aggregate.
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentMentalWellnesses to fetch.
     */
    orderBy?: AssessmentMentalWellnessOrderByWithRelationInput | AssessmentMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentMentalWellnesses
    **/
    _count?: true | AssessmentMentalWellnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMentalWellnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMentalWellnessMaxAggregateInputType
  }

  export type GetAssessmentMentalWellnessAggregateType<T extends AssessmentMentalWellnessAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentMentalWellness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentMentalWellness[P]>
      : GetScalarType<T[P], AggregateAssessmentMentalWellness[P]>
  }




  export type AssessmentMentalWellnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentMentalWellnessWhereInput
    orderBy?: AssessmentMentalWellnessOrderByWithAggregationInput | AssessmentMentalWellnessOrderByWithAggregationInput[]
    by: AssessmentMentalWellnessScalarFieldEnum[] | AssessmentMentalWellnessScalarFieldEnum
    having?: AssessmentMentalWellnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentMentalWellnessCountAggregateInputType | true
    _min?: AssessmentMentalWellnessMinAggregateInputType
    _max?: AssessmentMentalWellnessMaxAggregateInputType
  }

  export type AssessmentMentalWellnessGroupByOutputType = {
    id: string
    userId: string
    responses: JsonValue
    result: string
    createdAt: Date
    _count: AssessmentMentalWellnessCountAggregateOutputType | null
    _min: AssessmentMentalWellnessMinAggregateOutputType | null
    _max: AssessmentMentalWellnessMaxAggregateOutputType | null
  }

  type GetAssessmentMentalWellnessGroupByPayload<T extends AssessmentMentalWellnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentMentalWellnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentMentalWellnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentMentalWellnessGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentMentalWellnessGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentMentalWellnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    responses?: boolean
    result?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentMentalWellness"]>

  export type AssessmentMentalWellnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    responses?: boolean
    result?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentMentalWellness"]>

  export type AssessmentMentalWellnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    responses?: boolean
    result?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentMentalWellness"]>

  export type AssessmentMentalWellnessSelectScalar = {
    id?: boolean
    userId?: boolean
    responses?: boolean
    result?: boolean
    createdAt?: boolean
  }

  export type AssessmentMentalWellnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "responses" | "result" | "createdAt", ExtArgs["result"]["assessmentMentalWellness"]>
  export type AssessmentMentalWellnessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }
  export type AssessmentMentalWellnessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }
  export type AssessmentMentalWellnessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
  }

  export type $AssessmentMentalWellnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentMentalWellness"
    objects: {
      user: Prisma.$UserMentalWellnessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      responses: Prisma.JsonValue
      result: string
      createdAt: Date
    }, ExtArgs["result"]["assessmentMentalWellness"]>
    composites: {}
  }

  type AssessmentMentalWellnessGetPayload<S extends boolean | null | undefined | AssessmentMentalWellnessDefaultArgs> = $Result.GetResult<Prisma.$AssessmentMentalWellnessPayload, S>

  type AssessmentMentalWellnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentMentalWellnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentMentalWellnessCountAggregateInputType | true
    }

  export interface AssessmentMentalWellnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentMentalWellness'], meta: { name: 'AssessmentMentalWellness' } }
    /**
     * Find zero or one AssessmentMentalWellness that matches the filter.
     * @param {AssessmentMentalWellnessFindUniqueArgs} args - Arguments to find a AssessmentMentalWellness
     * @example
     * // Get one AssessmentMentalWellness
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentMentalWellnessFindUniqueArgs>(args: SelectSubset<T, AssessmentMentalWellnessFindUniqueArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssessmentMentalWellness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentMentalWellnessFindUniqueOrThrowArgs} args - Arguments to find a AssessmentMentalWellness
     * @example
     * // Get one AssessmentMentalWellness
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentMentalWellnessFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentMentalWellnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssessmentMentalWellness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessFindFirstArgs} args - Arguments to find a AssessmentMentalWellness
     * @example
     * // Get one AssessmentMentalWellness
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentMentalWellnessFindFirstArgs>(args?: SelectSubset<T, AssessmentMentalWellnessFindFirstArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssessmentMentalWellness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessFindFirstOrThrowArgs} args - Arguments to find a AssessmentMentalWellness
     * @example
     * // Get one AssessmentMentalWellness
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentMentalWellnessFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentMentalWellnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssessmentMentalWellnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentMentalWellnesses
     * const assessmentMentalWellnesses = await prisma.assessmentMentalWellness.findMany()
     * 
     * // Get first 10 AssessmentMentalWellnesses
     * const assessmentMentalWellnesses = await prisma.assessmentMentalWellness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentMentalWellnessWithIdOnly = await prisma.assessmentMentalWellness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentMentalWellnessFindManyArgs>(args?: SelectSubset<T, AssessmentMentalWellnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssessmentMentalWellness.
     * @param {AssessmentMentalWellnessCreateArgs} args - Arguments to create a AssessmentMentalWellness.
     * @example
     * // Create one AssessmentMentalWellness
     * const AssessmentMentalWellness = await prisma.assessmentMentalWellness.create({
     *   data: {
     *     // ... data to create a AssessmentMentalWellness
     *   }
     * })
     * 
     */
    create<T extends AssessmentMentalWellnessCreateArgs>(args: SelectSubset<T, AssessmentMentalWellnessCreateArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssessmentMentalWellnesses.
     * @param {AssessmentMentalWellnessCreateManyArgs} args - Arguments to create many AssessmentMentalWellnesses.
     * @example
     * // Create many AssessmentMentalWellnesses
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentMentalWellnessCreateManyArgs>(args?: SelectSubset<T, AssessmentMentalWellnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssessmentMentalWellnesses and returns the data saved in the database.
     * @param {AssessmentMentalWellnessCreateManyAndReturnArgs} args - Arguments to create many AssessmentMentalWellnesses.
     * @example
     * // Create many AssessmentMentalWellnesses
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssessmentMentalWellnesses and only return the `id`
     * const assessmentMentalWellnessWithIdOnly = await prisma.assessmentMentalWellness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentMentalWellnessCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentMentalWellnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssessmentMentalWellness.
     * @param {AssessmentMentalWellnessDeleteArgs} args - Arguments to delete one AssessmentMentalWellness.
     * @example
     * // Delete one AssessmentMentalWellness
     * const AssessmentMentalWellness = await prisma.assessmentMentalWellness.delete({
     *   where: {
     *     // ... filter to delete one AssessmentMentalWellness
     *   }
     * })
     * 
     */
    delete<T extends AssessmentMentalWellnessDeleteArgs>(args: SelectSubset<T, AssessmentMentalWellnessDeleteArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssessmentMentalWellness.
     * @param {AssessmentMentalWellnessUpdateArgs} args - Arguments to update one AssessmentMentalWellness.
     * @example
     * // Update one AssessmentMentalWellness
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentMentalWellnessUpdateArgs>(args: SelectSubset<T, AssessmentMentalWellnessUpdateArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssessmentMentalWellnesses.
     * @param {AssessmentMentalWellnessDeleteManyArgs} args - Arguments to filter AssessmentMentalWellnesses to delete.
     * @example
     * // Delete a few AssessmentMentalWellnesses
     * const { count } = await prisma.assessmentMentalWellness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentMentalWellnessDeleteManyArgs>(args?: SelectSubset<T, AssessmentMentalWellnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentMentalWellnesses
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentMentalWellnessUpdateManyArgs>(args: SelectSubset<T, AssessmentMentalWellnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentMentalWellnesses and returns the data updated in the database.
     * @param {AssessmentMentalWellnessUpdateManyAndReturnArgs} args - Arguments to update many AssessmentMentalWellnesses.
     * @example
     * // Update many AssessmentMentalWellnesses
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssessmentMentalWellnesses and only return the `id`
     * const assessmentMentalWellnessWithIdOnly = await prisma.assessmentMentalWellness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssessmentMentalWellnessUpdateManyAndReturnArgs>(args: SelectSubset<T, AssessmentMentalWellnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssessmentMentalWellness.
     * @param {AssessmentMentalWellnessUpsertArgs} args - Arguments to update or create a AssessmentMentalWellness.
     * @example
     * // Update or create a AssessmentMentalWellness
     * const assessmentMentalWellness = await prisma.assessmentMentalWellness.upsert({
     *   create: {
     *     // ... data to create a AssessmentMentalWellness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentMentalWellness we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentMentalWellnessUpsertArgs>(args: SelectSubset<T, AssessmentMentalWellnessUpsertArgs<ExtArgs>>): Prisma__AssessmentMentalWellnessClient<$Result.GetResult<Prisma.$AssessmentMentalWellnessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssessmentMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessCountArgs} args - Arguments to filter AssessmentMentalWellnesses to count.
     * @example
     * // Count the number of AssessmentMentalWellnesses
     * const count = await prisma.assessmentMentalWellness.count({
     *   where: {
     *     // ... the filter for the AssessmentMentalWellnesses we want to count
     *   }
     * })
    **/
    count<T extends AssessmentMentalWellnessCountArgs>(
      args?: Subset<T, AssessmentMentalWellnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentMentalWellnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentMentalWellnessAggregateArgs>(args: Subset<T, AssessmentMentalWellnessAggregateArgs>): Prisma.PrismaPromise<GetAssessmentMentalWellnessAggregateType<T>>

    /**
     * Group by AssessmentMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentMentalWellnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentMentalWellnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentMentalWellnessGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentMentalWellnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentMentalWellnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentMentalWellnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentMentalWellness model
   */
  readonly fields: AssessmentMentalWellnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentMentalWellness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentMentalWellnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserMentalWellnessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserMentalWellnessDefaultArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentMentalWellness model
   */ 
  interface AssessmentMentalWellnessFieldRefs {
    readonly id: FieldRef<"AssessmentMentalWellness", 'String'>
    readonly userId: FieldRef<"AssessmentMentalWellness", 'String'>
    readonly responses: FieldRef<"AssessmentMentalWellness", 'Json'>
    readonly result: FieldRef<"AssessmentMentalWellness", 'String'>
    readonly createdAt: FieldRef<"AssessmentMentalWellness", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentMentalWellness findUnique
   */
  export type AssessmentMentalWellnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentMentalWellness to fetch.
     */
    where: AssessmentMentalWellnessWhereUniqueInput
  }

  /**
   * AssessmentMentalWellness findUniqueOrThrow
   */
  export type AssessmentMentalWellnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentMentalWellness to fetch.
     */
    where: AssessmentMentalWellnessWhereUniqueInput
  }

  /**
   * AssessmentMentalWellness findFirst
   */
  export type AssessmentMentalWellnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentMentalWellness to fetch.
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentMentalWellnesses to fetch.
     */
    orderBy?: AssessmentMentalWellnessOrderByWithRelationInput | AssessmentMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentMentalWellnesses.
     */
    cursor?: AssessmentMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentMentalWellnesses.
     */
    distinct?: AssessmentMentalWellnessScalarFieldEnum | AssessmentMentalWellnessScalarFieldEnum[]
  }

  /**
   * AssessmentMentalWellness findFirstOrThrow
   */
  export type AssessmentMentalWellnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentMentalWellness to fetch.
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentMentalWellnesses to fetch.
     */
    orderBy?: AssessmentMentalWellnessOrderByWithRelationInput | AssessmentMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentMentalWellnesses.
     */
    cursor?: AssessmentMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentMentalWellnesses.
     */
    distinct?: AssessmentMentalWellnessScalarFieldEnum | AssessmentMentalWellnessScalarFieldEnum[]
  }

  /**
   * AssessmentMentalWellness findMany
   */
  export type AssessmentMentalWellnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentMentalWellnesses to fetch.
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentMentalWellnesses to fetch.
     */
    orderBy?: AssessmentMentalWellnessOrderByWithRelationInput | AssessmentMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentMentalWellnesses.
     */
    cursor?: AssessmentMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentMentalWellnesses.
     */
    skip?: number
    distinct?: AssessmentMentalWellnessScalarFieldEnum | AssessmentMentalWellnessScalarFieldEnum[]
  }

  /**
   * AssessmentMentalWellness create
   */
  export type AssessmentMentalWellnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentMentalWellness.
     */
    data: XOR<AssessmentMentalWellnessCreateInput, AssessmentMentalWellnessUncheckedCreateInput>
  }

  /**
   * AssessmentMentalWellness createMany
   */
  export type AssessmentMentalWellnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentMentalWellnesses.
     */
    data: AssessmentMentalWellnessCreateManyInput | AssessmentMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentMentalWellness createManyAndReturn
   */
  export type AssessmentMentalWellnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to create many AssessmentMentalWellnesses.
     */
    data: AssessmentMentalWellnessCreateManyInput | AssessmentMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentMentalWellness update
   */
  export type AssessmentMentalWellnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentMentalWellness.
     */
    data: XOR<AssessmentMentalWellnessUpdateInput, AssessmentMentalWellnessUncheckedUpdateInput>
    /**
     * Choose, which AssessmentMentalWellness to update.
     */
    where: AssessmentMentalWellnessWhereUniqueInput
  }

  /**
   * AssessmentMentalWellness updateMany
   */
  export type AssessmentMentalWellnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentMentalWellnesses.
     */
    data: XOR<AssessmentMentalWellnessUpdateManyMutationInput, AssessmentMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentMentalWellnesses to update
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * Limit how many AssessmentMentalWellnesses to update.
     */
    limit?: number
  }

  /**
   * AssessmentMentalWellness updateManyAndReturn
   */
  export type AssessmentMentalWellnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to update AssessmentMentalWellnesses.
     */
    data: XOR<AssessmentMentalWellnessUpdateManyMutationInput, AssessmentMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentMentalWellnesses to update
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * Limit how many AssessmentMentalWellnesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentMentalWellness upsert
   */
  export type AssessmentMentalWellnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentMentalWellness to update in case it exists.
     */
    where: AssessmentMentalWellnessWhereUniqueInput
    /**
     * In case the AssessmentMentalWellness found by the `where` argument doesn't exist, create a new AssessmentMentalWellness with this data.
     */
    create: XOR<AssessmentMentalWellnessCreateInput, AssessmentMentalWellnessUncheckedCreateInput>
    /**
     * In case the AssessmentMentalWellness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentMentalWellnessUpdateInput, AssessmentMentalWellnessUncheckedUpdateInput>
  }

  /**
   * AssessmentMentalWellness delete
   */
  export type AssessmentMentalWellnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
    /**
     * Filter which AssessmentMentalWellness to delete.
     */
    where: AssessmentMentalWellnessWhereUniqueInput
  }

  /**
   * AssessmentMentalWellness deleteMany
   */
  export type AssessmentMentalWellnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentMentalWellnesses to delete
     */
    where?: AssessmentMentalWellnessWhereInput
    /**
     * Limit how many AssessmentMentalWellnesses to delete.
     */
    limit?: number
  }

  /**
   * AssessmentMentalWellness without action
   */
  export type AssessmentMentalWellnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentMentalWellness
     */
    select?: AssessmentMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentMentalWellness
     */
    omit?: AssessmentMentalWellnessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentMentalWellnessInclude<ExtArgs> | null
  }


  /**
   * Model Meditation
   */

  export type AggregateMeditation = {
    _count: MeditationCountAggregateOutputType | null
    _min: MeditationMinAggregateOutputType | null
    _max: MeditationMaxAggregateOutputType | null
  }

  export type MeditationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    audioUrl: string | null
    createdAt: Date | null
  }

  export type MeditationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    audioUrl: string | null
    createdAt: Date | null
  }

  export type MeditationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    audioUrl: number
    createdAt: number
    _all: number
  }


  export type MeditationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    audioUrl?: true
    createdAt?: true
  }

  export type MeditationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    audioUrl?: true
    createdAt?: true
  }

  export type MeditationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    audioUrl?: true
    createdAt?: true
    _all?: true
  }

  export type MeditationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meditation to aggregate.
     */
    where?: MeditationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meditations to fetch.
     */
    orderBy?: MeditationOrderByWithRelationInput | MeditationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeditationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meditations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meditations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meditations
    **/
    _count?: true | MeditationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeditationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeditationMaxAggregateInputType
  }

  export type GetMeditationAggregateType<T extends MeditationAggregateArgs> = {
        [P in keyof T & keyof AggregateMeditation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeditation[P]>
      : GetScalarType<T[P], AggregateMeditation[P]>
  }




  export type MeditationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeditationWhereInput
    orderBy?: MeditationOrderByWithAggregationInput | MeditationOrderByWithAggregationInput[]
    by: MeditationScalarFieldEnum[] | MeditationScalarFieldEnum
    having?: MeditationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeditationCountAggregateInputType | true
    _min?: MeditationMinAggregateInputType
    _max?: MeditationMaxAggregateInputType
  }

  export type MeditationGroupByOutputType = {
    id: string
    title: string
    description: string
    audioUrl: string
    createdAt: Date
    _count: MeditationCountAggregateOutputType | null
    _min: MeditationMinAggregateOutputType | null
    _max: MeditationMaxAggregateOutputType | null
  }

  type GetMeditationGroupByPayload<T extends MeditationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeditationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeditationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeditationGroupByOutputType[P]>
            : GetScalarType<T[P], MeditationGroupByOutputType[P]>
        }
      >
    >


  export type MeditationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    audioUrl?: boolean
    createdAt?: boolean
    feedbacks?: boolean | Meditation$feedbacksArgs<ExtArgs>
    _count?: boolean | MeditationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meditation"]>

  export type MeditationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    audioUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["meditation"]>

  export type MeditationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    audioUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["meditation"]>

  export type MeditationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    audioUrl?: boolean
    createdAt?: boolean
  }

  export type MeditationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "audioUrl" | "createdAt", ExtArgs["result"]["meditation"]>
  export type MeditationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbacks?: boolean | Meditation$feedbacksArgs<ExtArgs>
    _count?: boolean | MeditationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeditationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MeditationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MeditationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meditation"
    objects: {
      feedbacks: Prisma.$MeditationFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      audioUrl: string
      createdAt: Date
    }, ExtArgs["result"]["meditation"]>
    composites: {}
  }

  type MeditationGetPayload<S extends boolean | null | undefined | MeditationDefaultArgs> = $Result.GetResult<Prisma.$MeditationPayload, S>

  type MeditationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeditationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeditationCountAggregateInputType | true
    }

  export interface MeditationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meditation'], meta: { name: 'Meditation' } }
    /**
     * Find zero or one Meditation that matches the filter.
     * @param {MeditationFindUniqueArgs} args - Arguments to find a Meditation
     * @example
     * // Get one Meditation
     * const meditation = await prisma.meditation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeditationFindUniqueArgs>(args: SelectSubset<T, MeditationFindUniqueArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meditation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeditationFindUniqueOrThrowArgs} args - Arguments to find a Meditation
     * @example
     * // Get one Meditation
     * const meditation = await prisma.meditation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeditationFindUniqueOrThrowArgs>(args: SelectSubset<T, MeditationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meditation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFindFirstArgs} args - Arguments to find a Meditation
     * @example
     * // Get one Meditation
     * const meditation = await prisma.meditation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeditationFindFirstArgs>(args?: SelectSubset<T, MeditationFindFirstArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meditation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFindFirstOrThrowArgs} args - Arguments to find a Meditation
     * @example
     * // Get one Meditation
     * const meditation = await prisma.meditation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeditationFindFirstOrThrowArgs>(args?: SelectSubset<T, MeditationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meditations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meditations
     * const meditations = await prisma.meditation.findMany()
     * 
     * // Get first 10 Meditations
     * const meditations = await prisma.meditation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meditationWithIdOnly = await prisma.meditation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeditationFindManyArgs>(args?: SelectSubset<T, MeditationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meditation.
     * @param {MeditationCreateArgs} args - Arguments to create a Meditation.
     * @example
     * // Create one Meditation
     * const Meditation = await prisma.meditation.create({
     *   data: {
     *     // ... data to create a Meditation
     *   }
     * })
     * 
     */
    create<T extends MeditationCreateArgs>(args: SelectSubset<T, MeditationCreateArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meditations.
     * @param {MeditationCreateManyArgs} args - Arguments to create many Meditations.
     * @example
     * // Create many Meditations
     * const meditation = await prisma.meditation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeditationCreateManyArgs>(args?: SelectSubset<T, MeditationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meditations and returns the data saved in the database.
     * @param {MeditationCreateManyAndReturnArgs} args - Arguments to create many Meditations.
     * @example
     * // Create many Meditations
     * const meditation = await prisma.meditation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meditations and only return the `id`
     * const meditationWithIdOnly = await prisma.meditation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeditationCreateManyAndReturnArgs>(args?: SelectSubset<T, MeditationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Meditation.
     * @param {MeditationDeleteArgs} args - Arguments to delete one Meditation.
     * @example
     * // Delete one Meditation
     * const Meditation = await prisma.meditation.delete({
     *   where: {
     *     // ... filter to delete one Meditation
     *   }
     * })
     * 
     */
    delete<T extends MeditationDeleteArgs>(args: SelectSubset<T, MeditationDeleteArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meditation.
     * @param {MeditationUpdateArgs} args - Arguments to update one Meditation.
     * @example
     * // Update one Meditation
     * const meditation = await prisma.meditation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeditationUpdateArgs>(args: SelectSubset<T, MeditationUpdateArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meditations.
     * @param {MeditationDeleteManyArgs} args - Arguments to filter Meditations to delete.
     * @example
     * // Delete a few Meditations
     * const { count } = await prisma.meditation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeditationDeleteManyArgs>(args?: SelectSubset<T, MeditationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meditations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meditations
     * const meditation = await prisma.meditation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeditationUpdateManyArgs>(args: SelectSubset<T, MeditationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meditations and returns the data updated in the database.
     * @param {MeditationUpdateManyAndReturnArgs} args - Arguments to update many Meditations.
     * @example
     * // Update many Meditations
     * const meditation = await prisma.meditation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Meditations and only return the `id`
     * const meditationWithIdOnly = await prisma.meditation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeditationUpdateManyAndReturnArgs>(args: SelectSubset<T, MeditationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Meditation.
     * @param {MeditationUpsertArgs} args - Arguments to update or create a Meditation.
     * @example
     * // Update or create a Meditation
     * const meditation = await prisma.meditation.upsert({
     *   create: {
     *     // ... data to create a Meditation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meditation we want to update
     *   }
     * })
     */
    upsert<T extends MeditationUpsertArgs>(args: SelectSubset<T, MeditationUpsertArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meditations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationCountArgs} args - Arguments to filter Meditations to count.
     * @example
     * // Count the number of Meditations
     * const count = await prisma.meditation.count({
     *   where: {
     *     // ... the filter for the Meditations we want to count
     *   }
     * })
    **/
    count<T extends MeditationCountArgs>(
      args?: Subset<T, MeditationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeditationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meditation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeditationAggregateArgs>(args: Subset<T, MeditationAggregateArgs>): Prisma.PrismaPromise<GetMeditationAggregateType<T>>

    /**
     * Group by Meditation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeditationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeditationGroupByArgs['orderBy'] }
        : { orderBy?: MeditationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeditationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeditationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meditation model
   */
  readonly fields: MeditationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meditation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeditationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedbacks<T extends Meditation$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Meditation$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meditation model
   */ 
  interface MeditationFieldRefs {
    readonly id: FieldRef<"Meditation", 'String'>
    readonly title: FieldRef<"Meditation", 'String'>
    readonly description: FieldRef<"Meditation", 'String'>
    readonly audioUrl: FieldRef<"Meditation", 'String'>
    readonly createdAt: FieldRef<"Meditation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meditation findUnique
   */
  export type MeditationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * Filter, which Meditation to fetch.
     */
    where: MeditationWhereUniqueInput
  }

  /**
   * Meditation findUniqueOrThrow
   */
  export type MeditationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * Filter, which Meditation to fetch.
     */
    where: MeditationWhereUniqueInput
  }

  /**
   * Meditation findFirst
   */
  export type MeditationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * Filter, which Meditation to fetch.
     */
    where?: MeditationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meditations to fetch.
     */
    orderBy?: MeditationOrderByWithRelationInput | MeditationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meditations.
     */
    cursor?: MeditationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meditations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meditations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meditations.
     */
    distinct?: MeditationScalarFieldEnum | MeditationScalarFieldEnum[]
  }

  /**
   * Meditation findFirstOrThrow
   */
  export type MeditationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * Filter, which Meditation to fetch.
     */
    where?: MeditationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meditations to fetch.
     */
    orderBy?: MeditationOrderByWithRelationInput | MeditationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meditations.
     */
    cursor?: MeditationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meditations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meditations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meditations.
     */
    distinct?: MeditationScalarFieldEnum | MeditationScalarFieldEnum[]
  }

  /**
   * Meditation findMany
   */
  export type MeditationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * Filter, which Meditations to fetch.
     */
    where?: MeditationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meditations to fetch.
     */
    orderBy?: MeditationOrderByWithRelationInput | MeditationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meditations.
     */
    cursor?: MeditationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meditations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meditations.
     */
    skip?: number
    distinct?: MeditationScalarFieldEnum | MeditationScalarFieldEnum[]
  }

  /**
   * Meditation create
   */
  export type MeditationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * The data needed to create a Meditation.
     */
    data: XOR<MeditationCreateInput, MeditationUncheckedCreateInput>
  }

  /**
   * Meditation createMany
   */
  export type MeditationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meditations.
     */
    data: MeditationCreateManyInput | MeditationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meditation createManyAndReturn
   */
  export type MeditationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * The data used to create many Meditations.
     */
    data: MeditationCreateManyInput | MeditationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meditation update
   */
  export type MeditationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * The data needed to update a Meditation.
     */
    data: XOR<MeditationUpdateInput, MeditationUncheckedUpdateInput>
    /**
     * Choose, which Meditation to update.
     */
    where: MeditationWhereUniqueInput
  }

  /**
   * Meditation updateMany
   */
  export type MeditationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meditations.
     */
    data: XOR<MeditationUpdateManyMutationInput, MeditationUncheckedUpdateManyInput>
    /**
     * Filter which Meditations to update
     */
    where?: MeditationWhereInput
    /**
     * Limit how many Meditations to update.
     */
    limit?: number
  }

  /**
   * Meditation updateManyAndReturn
   */
  export type MeditationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * The data used to update Meditations.
     */
    data: XOR<MeditationUpdateManyMutationInput, MeditationUncheckedUpdateManyInput>
    /**
     * Filter which Meditations to update
     */
    where?: MeditationWhereInput
    /**
     * Limit how many Meditations to update.
     */
    limit?: number
  }

  /**
   * Meditation upsert
   */
  export type MeditationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * The filter to search for the Meditation to update in case it exists.
     */
    where: MeditationWhereUniqueInput
    /**
     * In case the Meditation found by the `where` argument doesn't exist, create a new Meditation with this data.
     */
    create: XOR<MeditationCreateInput, MeditationUncheckedCreateInput>
    /**
     * In case the Meditation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeditationUpdateInput, MeditationUncheckedUpdateInput>
  }

  /**
   * Meditation delete
   */
  export type MeditationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
    /**
     * Filter which Meditation to delete.
     */
    where: MeditationWhereUniqueInput
  }

  /**
   * Meditation deleteMany
   */
  export type MeditationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meditations to delete
     */
    where?: MeditationWhereInput
    /**
     * Limit how many Meditations to delete.
     */
    limit?: number
  }

  /**
   * Meditation.feedbacks
   */
  export type Meditation$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    where?: MeditationFeedbackWhereInput
    orderBy?: MeditationFeedbackOrderByWithRelationInput | MeditationFeedbackOrderByWithRelationInput[]
    cursor?: MeditationFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeditationFeedbackScalarFieldEnum | MeditationFeedbackScalarFieldEnum[]
  }

  /**
   * Meditation without action
   */
  export type MeditationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meditation
     */
    select?: MeditationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meditation
     */
    omit?: MeditationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationInclude<ExtArgs> | null
  }


  /**
   * Model MeditationFeedback
   */

  export type AggregateMeditationFeedback = {
    _count: MeditationFeedbackCountAggregateOutputType | null
    _avg: MeditationFeedbackAvgAggregateOutputType | null
    _sum: MeditationFeedbackSumAggregateOutputType | null
    _min: MeditationFeedbackMinAggregateOutputType | null
    _max: MeditationFeedbackMaxAggregateOutputType | null
  }

  export type MeditationFeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type MeditationFeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type MeditationFeedbackMinAggregateOutputType = {
    id: string | null
    meditationId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type MeditationFeedbackMaxAggregateOutputType = {
    id: string | null
    meditationId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type MeditationFeedbackCountAggregateOutputType = {
    id: number
    meditationId: number
    userId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type MeditationFeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type MeditationFeedbackSumAggregateInputType = {
    rating?: true
  }

  export type MeditationFeedbackMinAggregateInputType = {
    id?: true
    meditationId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type MeditationFeedbackMaxAggregateInputType = {
    id?: true
    meditationId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type MeditationFeedbackCountAggregateInputType = {
    id?: true
    meditationId?: true
    userId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type MeditationFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeditationFeedback to aggregate.
     */
    where?: MeditationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationFeedbacks to fetch.
     */
    orderBy?: MeditationFeedbackOrderByWithRelationInput | MeditationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeditationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeditationFeedbacks
    **/
    _count?: true | MeditationFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeditationFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeditationFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeditationFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeditationFeedbackMaxAggregateInputType
  }

  export type GetMeditationFeedbackAggregateType<T extends MeditationFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateMeditationFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeditationFeedback[P]>
      : GetScalarType<T[P], AggregateMeditationFeedback[P]>
  }




  export type MeditationFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeditationFeedbackWhereInput
    orderBy?: MeditationFeedbackOrderByWithAggregationInput | MeditationFeedbackOrderByWithAggregationInput[]
    by: MeditationFeedbackScalarFieldEnum[] | MeditationFeedbackScalarFieldEnum
    having?: MeditationFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeditationFeedbackCountAggregateInputType | true
    _avg?: MeditationFeedbackAvgAggregateInputType
    _sum?: MeditationFeedbackSumAggregateInputType
    _min?: MeditationFeedbackMinAggregateInputType
    _max?: MeditationFeedbackMaxAggregateInputType
  }

  export type MeditationFeedbackGroupByOutputType = {
    id: string
    meditationId: string
    userId: string
    rating: number
    comment: string
    createdAt: Date
    _count: MeditationFeedbackCountAggregateOutputType | null
    _avg: MeditationFeedbackAvgAggregateOutputType | null
    _sum: MeditationFeedbackSumAggregateOutputType | null
    _min: MeditationFeedbackMinAggregateOutputType | null
    _max: MeditationFeedbackMaxAggregateOutputType | null
  }

  type GetMeditationFeedbackGroupByPayload<T extends MeditationFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeditationFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeditationFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeditationFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], MeditationFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type MeditationFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meditationId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
    meditation?: boolean | MeditationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meditationFeedback"]>

  export type MeditationFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meditationId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
    meditation?: boolean | MeditationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meditationFeedback"]>

  export type MeditationFeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meditationId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
    meditation?: boolean | MeditationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meditationFeedback"]>

  export type MeditationFeedbackSelectScalar = {
    id?: boolean
    meditationId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type MeditationFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meditationId" | "userId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["meditationFeedback"]>
  export type MeditationFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
    meditation?: boolean | MeditationDefaultArgs<ExtArgs>
  }
  export type MeditationFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
    meditation?: boolean | MeditationDefaultArgs<ExtArgs>
  }
  export type MeditationFeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserMentalWellnessDefaultArgs<ExtArgs>
    meditation?: boolean | MeditationDefaultArgs<ExtArgs>
  }

  export type $MeditationFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeditationFeedback"
    objects: {
      user: Prisma.$UserMentalWellnessPayload<ExtArgs>
      meditation: Prisma.$MeditationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meditationId: string
      userId: string
      rating: number
      comment: string
      createdAt: Date
    }, ExtArgs["result"]["meditationFeedback"]>
    composites: {}
  }

  type MeditationFeedbackGetPayload<S extends boolean | null | undefined | MeditationFeedbackDefaultArgs> = $Result.GetResult<Prisma.$MeditationFeedbackPayload, S>

  type MeditationFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeditationFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeditationFeedbackCountAggregateInputType | true
    }

  export interface MeditationFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeditationFeedback'], meta: { name: 'MeditationFeedback' } }
    /**
     * Find zero or one MeditationFeedback that matches the filter.
     * @param {MeditationFeedbackFindUniqueArgs} args - Arguments to find a MeditationFeedback
     * @example
     * // Get one MeditationFeedback
     * const meditationFeedback = await prisma.meditationFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeditationFeedbackFindUniqueArgs>(args: SelectSubset<T, MeditationFeedbackFindUniqueArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeditationFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeditationFeedbackFindUniqueOrThrowArgs} args - Arguments to find a MeditationFeedback
     * @example
     * // Get one MeditationFeedback
     * const meditationFeedback = await prisma.meditationFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeditationFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, MeditationFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeditationFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackFindFirstArgs} args - Arguments to find a MeditationFeedback
     * @example
     * // Get one MeditationFeedback
     * const meditationFeedback = await prisma.meditationFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeditationFeedbackFindFirstArgs>(args?: SelectSubset<T, MeditationFeedbackFindFirstArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeditationFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackFindFirstOrThrowArgs} args - Arguments to find a MeditationFeedback
     * @example
     * // Get one MeditationFeedback
     * const meditationFeedback = await prisma.meditationFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeditationFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, MeditationFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeditationFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeditationFeedbacks
     * const meditationFeedbacks = await prisma.meditationFeedback.findMany()
     * 
     * // Get first 10 MeditationFeedbacks
     * const meditationFeedbacks = await prisma.meditationFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meditationFeedbackWithIdOnly = await prisma.meditationFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeditationFeedbackFindManyArgs>(args?: SelectSubset<T, MeditationFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeditationFeedback.
     * @param {MeditationFeedbackCreateArgs} args - Arguments to create a MeditationFeedback.
     * @example
     * // Create one MeditationFeedback
     * const MeditationFeedback = await prisma.meditationFeedback.create({
     *   data: {
     *     // ... data to create a MeditationFeedback
     *   }
     * })
     * 
     */
    create<T extends MeditationFeedbackCreateArgs>(args: SelectSubset<T, MeditationFeedbackCreateArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeditationFeedbacks.
     * @param {MeditationFeedbackCreateManyArgs} args - Arguments to create many MeditationFeedbacks.
     * @example
     * // Create many MeditationFeedbacks
     * const meditationFeedback = await prisma.meditationFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeditationFeedbackCreateManyArgs>(args?: SelectSubset<T, MeditationFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeditationFeedbacks and returns the data saved in the database.
     * @param {MeditationFeedbackCreateManyAndReturnArgs} args - Arguments to create many MeditationFeedbacks.
     * @example
     * // Create many MeditationFeedbacks
     * const meditationFeedback = await prisma.meditationFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeditationFeedbacks and only return the `id`
     * const meditationFeedbackWithIdOnly = await prisma.meditationFeedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeditationFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, MeditationFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MeditationFeedback.
     * @param {MeditationFeedbackDeleteArgs} args - Arguments to delete one MeditationFeedback.
     * @example
     * // Delete one MeditationFeedback
     * const MeditationFeedback = await prisma.meditationFeedback.delete({
     *   where: {
     *     // ... filter to delete one MeditationFeedback
     *   }
     * })
     * 
     */
    delete<T extends MeditationFeedbackDeleteArgs>(args: SelectSubset<T, MeditationFeedbackDeleteArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeditationFeedback.
     * @param {MeditationFeedbackUpdateArgs} args - Arguments to update one MeditationFeedback.
     * @example
     * // Update one MeditationFeedback
     * const meditationFeedback = await prisma.meditationFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeditationFeedbackUpdateArgs>(args: SelectSubset<T, MeditationFeedbackUpdateArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeditationFeedbacks.
     * @param {MeditationFeedbackDeleteManyArgs} args - Arguments to filter MeditationFeedbacks to delete.
     * @example
     * // Delete a few MeditationFeedbacks
     * const { count } = await prisma.meditationFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeditationFeedbackDeleteManyArgs>(args?: SelectSubset<T, MeditationFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeditationFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeditationFeedbacks
     * const meditationFeedback = await prisma.meditationFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeditationFeedbackUpdateManyArgs>(args: SelectSubset<T, MeditationFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeditationFeedbacks and returns the data updated in the database.
     * @param {MeditationFeedbackUpdateManyAndReturnArgs} args - Arguments to update many MeditationFeedbacks.
     * @example
     * // Update many MeditationFeedbacks
     * const meditationFeedback = await prisma.meditationFeedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MeditationFeedbacks and only return the `id`
     * const meditationFeedbackWithIdOnly = await prisma.meditationFeedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeditationFeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, MeditationFeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MeditationFeedback.
     * @param {MeditationFeedbackUpsertArgs} args - Arguments to update or create a MeditationFeedback.
     * @example
     * // Update or create a MeditationFeedback
     * const meditationFeedback = await prisma.meditationFeedback.upsert({
     *   create: {
     *     // ... data to create a MeditationFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeditationFeedback we want to update
     *   }
     * })
     */
    upsert<T extends MeditationFeedbackUpsertArgs>(args: SelectSubset<T, MeditationFeedbackUpsertArgs<ExtArgs>>): Prisma__MeditationFeedbackClient<$Result.GetResult<Prisma.$MeditationFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeditationFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackCountArgs} args - Arguments to filter MeditationFeedbacks to count.
     * @example
     * // Count the number of MeditationFeedbacks
     * const count = await prisma.meditationFeedback.count({
     *   where: {
     *     // ... the filter for the MeditationFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends MeditationFeedbackCountArgs>(
      args?: Subset<T, MeditationFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeditationFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeditationFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeditationFeedbackAggregateArgs>(args: Subset<T, MeditationFeedbackAggregateArgs>): Prisma.PrismaPromise<GetMeditationFeedbackAggregateType<T>>

    /**
     * Group by MeditationFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeditationFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeditationFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeditationFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: MeditationFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeditationFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeditationFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeditationFeedback model
   */
  readonly fields: MeditationFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeditationFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeditationFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserMentalWellnessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserMentalWellnessDefaultArgs<ExtArgs>>): Prisma__UserMentalWellnessClient<$Result.GetResult<Prisma.$UserMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    meditation<T extends MeditationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeditationDefaultArgs<ExtArgs>>): Prisma__MeditationClient<$Result.GetResult<Prisma.$MeditationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeditationFeedback model
   */ 
  interface MeditationFeedbackFieldRefs {
    readonly id: FieldRef<"MeditationFeedback", 'String'>
    readonly meditationId: FieldRef<"MeditationFeedback", 'String'>
    readonly userId: FieldRef<"MeditationFeedback", 'String'>
    readonly rating: FieldRef<"MeditationFeedback", 'Int'>
    readonly comment: FieldRef<"MeditationFeedback", 'String'>
    readonly createdAt: FieldRef<"MeditationFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeditationFeedback findUnique
   */
  export type MeditationFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MeditationFeedback to fetch.
     */
    where: MeditationFeedbackWhereUniqueInput
  }

  /**
   * MeditationFeedback findUniqueOrThrow
   */
  export type MeditationFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MeditationFeedback to fetch.
     */
    where: MeditationFeedbackWhereUniqueInput
  }

  /**
   * MeditationFeedback findFirst
   */
  export type MeditationFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MeditationFeedback to fetch.
     */
    where?: MeditationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationFeedbacks to fetch.
     */
    orderBy?: MeditationFeedbackOrderByWithRelationInput | MeditationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeditationFeedbacks.
     */
    cursor?: MeditationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeditationFeedbacks.
     */
    distinct?: MeditationFeedbackScalarFieldEnum | MeditationFeedbackScalarFieldEnum[]
  }

  /**
   * MeditationFeedback findFirstOrThrow
   */
  export type MeditationFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MeditationFeedback to fetch.
     */
    where?: MeditationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationFeedbacks to fetch.
     */
    orderBy?: MeditationFeedbackOrderByWithRelationInput | MeditationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeditationFeedbacks.
     */
    cursor?: MeditationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeditationFeedbacks.
     */
    distinct?: MeditationFeedbackScalarFieldEnum | MeditationFeedbackScalarFieldEnum[]
  }

  /**
   * MeditationFeedback findMany
   */
  export type MeditationFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MeditationFeedbacks to fetch.
     */
    where?: MeditationFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeditationFeedbacks to fetch.
     */
    orderBy?: MeditationFeedbackOrderByWithRelationInput | MeditationFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeditationFeedbacks.
     */
    cursor?: MeditationFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeditationFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeditationFeedbacks.
     */
    skip?: number
    distinct?: MeditationFeedbackScalarFieldEnum | MeditationFeedbackScalarFieldEnum[]
  }

  /**
   * MeditationFeedback create
   */
  export type MeditationFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a MeditationFeedback.
     */
    data: XOR<MeditationFeedbackCreateInput, MeditationFeedbackUncheckedCreateInput>
  }

  /**
   * MeditationFeedback createMany
   */
  export type MeditationFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeditationFeedbacks.
     */
    data: MeditationFeedbackCreateManyInput | MeditationFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeditationFeedback createManyAndReturn
   */
  export type MeditationFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many MeditationFeedbacks.
     */
    data: MeditationFeedbackCreateManyInput | MeditationFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeditationFeedback update
   */
  export type MeditationFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a MeditationFeedback.
     */
    data: XOR<MeditationFeedbackUpdateInput, MeditationFeedbackUncheckedUpdateInput>
    /**
     * Choose, which MeditationFeedback to update.
     */
    where: MeditationFeedbackWhereUniqueInput
  }

  /**
   * MeditationFeedback updateMany
   */
  export type MeditationFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeditationFeedbacks.
     */
    data: XOR<MeditationFeedbackUpdateManyMutationInput, MeditationFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which MeditationFeedbacks to update
     */
    where?: MeditationFeedbackWhereInput
    /**
     * Limit how many MeditationFeedbacks to update.
     */
    limit?: number
  }

  /**
   * MeditationFeedback updateManyAndReturn
   */
  export type MeditationFeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * The data used to update MeditationFeedbacks.
     */
    data: XOR<MeditationFeedbackUpdateManyMutationInput, MeditationFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which MeditationFeedbacks to update
     */
    where?: MeditationFeedbackWhereInput
    /**
     * Limit how many MeditationFeedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeditationFeedback upsert
   */
  export type MeditationFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the MeditationFeedback to update in case it exists.
     */
    where: MeditationFeedbackWhereUniqueInput
    /**
     * In case the MeditationFeedback found by the `where` argument doesn't exist, create a new MeditationFeedback with this data.
     */
    create: XOR<MeditationFeedbackCreateInput, MeditationFeedbackUncheckedCreateInput>
    /**
     * In case the MeditationFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeditationFeedbackUpdateInput, MeditationFeedbackUncheckedUpdateInput>
  }

  /**
   * MeditationFeedback delete
   */
  export type MeditationFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
    /**
     * Filter which MeditationFeedback to delete.
     */
    where: MeditationFeedbackWhereUniqueInput
  }

  /**
   * MeditationFeedback deleteMany
   */
  export type MeditationFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeditationFeedbacks to delete
     */
    where?: MeditationFeedbackWhereInput
    /**
     * Limit how many MeditationFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * MeditationFeedback without action
   */
  export type MeditationFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeditationFeedback
     */
    select?: MeditationFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeditationFeedback
     */
    omit?: MeditationFeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeditationFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model HospitalMentalWellness
   */

  export type AggregateHospitalMentalWellness = {
    _count: HospitalMentalWellnessCountAggregateOutputType | null
    _min: HospitalMentalWellnessMinAggregateOutputType | null
    _max: HospitalMentalWellnessMaxAggregateOutputType | null
  }

  export type HospitalMentalWellnessMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    contactInfo: string | null
    type: string | null
    createdAt: Date | null
  }

  export type HospitalMentalWellnessMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    contactInfo: string | null
    type: string | null
    createdAt: Date | null
  }

  export type HospitalMentalWellnessCountAggregateOutputType = {
    id: number
    name: number
    location: number
    contactInfo: number
    type: number
    createdAt: number
    _all: number
  }


  export type HospitalMentalWellnessMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contactInfo?: true
    type?: true
    createdAt?: true
  }

  export type HospitalMentalWellnessMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contactInfo?: true
    type?: true
    createdAt?: true
  }

  export type HospitalMentalWellnessCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contactInfo?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type HospitalMentalWellnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HospitalMentalWellness to aggregate.
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalMentalWellnesses to fetch.
     */
    orderBy?: HospitalMentalWellnessOrderByWithRelationInput | HospitalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HospitalMentalWellnesses
    **/
    _count?: true | HospitalMentalWellnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMentalWellnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMentalWellnessMaxAggregateInputType
  }

  export type GetHospitalMentalWellnessAggregateType<T extends HospitalMentalWellnessAggregateArgs> = {
        [P in keyof T & keyof AggregateHospitalMentalWellness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospitalMentalWellness[P]>
      : GetScalarType<T[P], AggregateHospitalMentalWellness[P]>
  }




  export type HospitalMentalWellnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalMentalWellnessWhereInput
    orderBy?: HospitalMentalWellnessOrderByWithAggregationInput | HospitalMentalWellnessOrderByWithAggregationInput[]
    by: HospitalMentalWellnessScalarFieldEnum[] | HospitalMentalWellnessScalarFieldEnum
    having?: HospitalMentalWellnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalMentalWellnessCountAggregateInputType | true
    _min?: HospitalMentalWellnessMinAggregateInputType
    _max?: HospitalMentalWellnessMaxAggregateInputType
  }

  export type HospitalMentalWellnessGroupByOutputType = {
    id: string
    name: string
    location: string
    contactInfo: string
    type: string
    createdAt: Date
    _count: HospitalMentalWellnessCountAggregateOutputType | null
    _min: HospitalMentalWellnessMinAggregateOutputType | null
    _max: HospitalMentalWellnessMaxAggregateOutputType | null
  }

  type GetHospitalMentalWellnessGroupByPayload<T extends HospitalMentalWellnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalMentalWellnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalMentalWellnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalMentalWellnessGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalMentalWellnessGroupByOutputType[P]>
        }
      >
    >


  export type HospitalMentalWellnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contactInfo?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["hospitalMentalWellness"]>

  export type HospitalMentalWellnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contactInfo?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["hospitalMentalWellness"]>

  export type HospitalMentalWellnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contactInfo?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["hospitalMentalWellness"]>

  export type HospitalMentalWellnessSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    contactInfo?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type HospitalMentalWellnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "contactInfo" | "type" | "createdAt", ExtArgs["result"]["hospitalMentalWellness"]>

  export type $HospitalMentalWellnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HospitalMentalWellness"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      contactInfo: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["hospitalMentalWellness"]>
    composites: {}
  }

  type HospitalMentalWellnessGetPayload<S extends boolean | null | undefined | HospitalMentalWellnessDefaultArgs> = $Result.GetResult<Prisma.$HospitalMentalWellnessPayload, S>

  type HospitalMentalWellnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HospitalMentalWellnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HospitalMentalWellnessCountAggregateInputType | true
    }

  export interface HospitalMentalWellnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HospitalMentalWellness'], meta: { name: 'HospitalMentalWellness' } }
    /**
     * Find zero or one HospitalMentalWellness that matches the filter.
     * @param {HospitalMentalWellnessFindUniqueArgs} args - Arguments to find a HospitalMentalWellness
     * @example
     * // Get one HospitalMentalWellness
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalMentalWellnessFindUniqueArgs>(args: SelectSubset<T, HospitalMentalWellnessFindUniqueArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HospitalMentalWellness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalMentalWellnessFindUniqueOrThrowArgs} args - Arguments to find a HospitalMentalWellness
     * @example
     * // Get one HospitalMentalWellness
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalMentalWellnessFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalMentalWellnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HospitalMentalWellness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessFindFirstArgs} args - Arguments to find a HospitalMentalWellness
     * @example
     * // Get one HospitalMentalWellness
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalMentalWellnessFindFirstArgs>(args?: SelectSubset<T, HospitalMentalWellnessFindFirstArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HospitalMentalWellness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessFindFirstOrThrowArgs} args - Arguments to find a HospitalMentalWellness
     * @example
     * // Get one HospitalMentalWellness
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalMentalWellnessFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalMentalWellnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HospitalMentalWellnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HospitalMentalWellnesses
     * const hospitalMentalWellnesses = await prisma.hospitalMentalWellness.findMany()
     * 
     * // Get first 10 HospitalMentalWellnesses
     * const hospitalMentalWellnesses = await prisma.hospitalMentalWellness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalMentalWellnessWithIdOnly = await prisma.hospitalMentalWellness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalMentalWellnessFindManyArgs>(args?: SelectSubset<T, HospitalMentalWellnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HospitalMentalWellness.
     * @param {HospitalMentalWellnessCreateArgs} args - Arguments to create a HospitalMentalWellness.
     * @example
     * // Create one HospitalMentalWellness
     * const HospitalMentalWellness = await prisma.hospitalMentalWellness.create({
     *   data: {
     *     // ... data to create a HospitalMentalWellness
     *   }
     * })
     * 
     */
    create<T extends HospitalMentalWellnessCreateArgs>(args: SelectSubset<T, HospitalMentalWellnessCreateArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HospitalMentalWellnesses.
     * @param {HospitalMentalWellnessCreateManyArgs} args - Arguments to create many HospitalMentalWellnesses.
     * @example
     * // Create many HospitalMentalWellnesses
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalMentalWellnessCreateManyArgs>(args?: SelectSubset<T, HospitalMentalWellnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HospitalMentalWellnesses and returns the data saved in the database.
     * @param {HospitalMentalWellnessCreateManyAndReturnArgs} args - Arguments to create many HospitalMentalWellnesses.
     * @example
     * // Create many HospitalMentalWellnesses
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HospitalMentalWellnesses and only return the `id`
     * const hospitalMentalWellnessWithIdOnly = await prisma.hospitalMentalWellness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospitalMentalWellnessCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalMentalWellnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HospitalMentalWellness.
     * @param {HospitalMentalWellnessDeleteArgs} args - Arguments to delete one HospitalMentalWellness.
     * @example
     * // Delete one HospitalMentalWellness
     * const HospitalMentalWellness = await prisma.hospitalMentalWellness.delete({
     *   where: {
     *     // ... filter to delete one HospitalMentalWellness
     *   }
     * })
     * 
     */
    delete<T extends HospitalMentalWellnessDeleteArgs>(args: SelectSubset<T, HospitalMentalWellnessDeleteArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HospitalMentalWellness.
     * @param {HospitalMentalWellnessUpdateArgs} args - Arguments to update one HospitalMentalWellness.
     * @example
     * // Update one HospitalMentalWellness
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalMentalWellnessUpdateArgs>(args: SelectSubset<T, HospitalMentalWellnessUpdateArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HospitalMentalWellnesses.
     * @param {HospitalMentalWellnessDeleteManyArgs} args - Arguments to filter HospitalMentalWellnesses to delete.
     * @example
     * // Delete a few HospitalMentalWellnesses
     * const { count } = await prisma.hospitalMentalWellness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalMentalWellnessDeleteManyArgs>(args?: SelectSubset<T, HospitalMentalWellnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HospitalMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HospitalMentalWellnesses
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalMentalWellnessUpdateManyArgs>(args: SelectSubset<T, HospitalMentalWellnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HospitalMentalWellnesses and returns the data updated in the database.
     * @param {HospitalMentalWellnessUpdateManyAndReturnArgs} args - Arguments to update many HospitalMentalWellnesses.
     * @example
     * // Update many HospitalMentalWellnesses
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HospitalMentalWellnesses and only return the `id`
     * const hospitalMentalWellnessWithIdOnly = await prisma.hospitalMentalWellness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HospitalMentalWellnessUpdateManyAndReturnArgs>(args: SelectSubset<T, HospitalMentalWellnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HospitalMentalWellness.
     * @param {HospitalMentalWellnessUpsertArgs} args - Arguments to update or create a HospitalMentalWellness.
     * @example
     * // Update or create a HospitalMentalWellness
     * const hospitalMentalWellness = await prisma.hospitalMentalWellness.upsert({
     *   create: {
     *     // ... data to create a HospitalMentalWellness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HospitalMentalWellness we want to update
     *   }
     * })
     */
    upsert<T extends HospitalMentalWellnessUpsertArgs>(args: SelectSubset<T, HospitalMentalWellnessUpsertArgs<ExtArgs>>): Prisma__HospitalMentalWellnessClient<$Result.GetResult<Prisma.$HospitalMentalWellnessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HospitalMentalWellnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessCountArgs} args - Arguments to filter HospitalMentalWellnesses to count.
     * @example
     * // Count the number of HospitalMentalWellnesses
     * const count = await prisma.hospitalMentalWellness.count({
     *   where: {
     *     // ... the filter for the HospitalMentalWellnesses we want to count
     *   }
     * })
    **/
    count<T extends HospitalMentalWellnessCountArgs>(
      args?: Subset<T, HospitalMentalWellnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalMentalWellnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HospitalMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalMentalWellnessAggregateArgs>(args: Subset<T, HospitalMentalWellnessAggregateArgs>): Prisma.PrismaPromise<GetHospitalMentalWellnessAggregateType<T>>

    /**
     * Group by HospitalMentalWellness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalMentalWellnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalMentalWellnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalMentalWellnessGroupByArgs['orderBy'] }
        : { orderBy?: HospitalMentalWellnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalMentalWellnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalMentalWellnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HospitalMentalWellness model
   */
  readonly fields: HospitalMentalWellnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HospitalMentalWellness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalMentalWellnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HospitalMentalWellness model
   */ 
  interface HospitalMentalWellnessFieldRefs {
    readonly id: FieldRef<"HospitalMentalWellness", 'String'>
    readonly name: FieldRef<"HospitalMentalWellness", 'String'>
    readonly location: FieldRef<"HospitalMentalWellness", 'String'>
    readonly contactInfo: FieldRef<"HospitalMentalWellness", 'String'>
    readonly type: FieldRef<"HospitalMentalWellness", 'String'>
    readonly createdAt: FieldRef<"HospitalMentalWellness", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HospitalMentalWellness findUnique
   */
  export type HospitalMentalWellnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * Filter, which HospitalMentalWellness to fetch.
     */
    where: HospitalMentalWellnessWhereUniqueInput
  }

  /**
   * HospitalMentalWellness findUniqueOrThrow
   */
  export type HospitalMentalWellnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * Filter, which HospitalMentalWellness to fetch.
     */
    where: HospitalMentalWellnessWhereUniqueInput
  }

  /**
   * HospitalMentalWellness findFirst
   */
  export type HospitalMentalWellnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * Filter, which HospitalMentalWellness to fetch.
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalMentalWellnesses to fetch.
     */
    orderBy?: HospitalMentalWellnessOrderByWithRelationInput | HospitalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HospitalMentalWellnesses.
     */
    cursor?: HospitalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HospitalMentalWellnesses.
     */
    distinct?: HospitalMentalWellnessScalarFieldEnum | HospitalMentalWellnessScalarFieldEnum[]
  }

  /**
   * HospitalMentalWellness findFirstOrThrow
   */
  export type HospitalMentalWellnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * Filter, which HospitalMentalWellness to fetch.
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalMentalWellnesses to fetch.
     */
    orderBy?: HospitalMentalWellnessOrderByWithRelationInput | HospitalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HospitalMentalWellnesses.
     */
    cursor?: HospitalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalMentalWellnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HospitalMentalWellnesses.
     */
    distinct?: HospitalMentalWellnessScalarFieldEnum | HospitalMentalWellnessScalarFieldEnum[]
  }

  /**
   * HospitalMentalWellness findMany
   */
  export type HospitalMentalWellnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * Filter, which HospitalMentalWellnesses to fetch.
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HospitalMentalWellnesses to fetch.
     */
    orderBy?: HospitalMentalWellnessOrderByWithRelationInput | HospitalMentalWellnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HospitalMentalWellnesses.
     */
    cursor?: HospitalMentalWellnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HospitalMentalWellnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HospitalMentalWellnesses.
     */
    skip?: number
    distinct?: HospitalMentalWellnessScalarFieldEnum | HospitalMentalWellnessScalarFieldEnum[]
  }

  /**
   * HospitalMentalWellness create
   */
  export type HospitalMentalWellnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * The data needed to create a HospitalMentalWellness.
     */
    data: XOR<HospitalMentalWellnessCreateInput, HospitalMentalWellnessUncheckedCreateInput>
  }

  /**
   * HospitalMentalWellness createMany
   */
  export type HospitalMentalWellnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HospitalMentalWellnesses.
     */
    data: HospitalMentalWellnessCreateManyInput | HospitalMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HospitalMentalWellness createManyAndReturn
   */
  export type HospitalMentalWellnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to create many HospitalMentalWellnesses.
     */
    data: HospitalMentalWellnessCreateManyInput | HospitalMentalWellnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HospitalMentalWellness update
   */
  export type HospitalMentalWellnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * The data needed to update a HospitalMentalWellness.
     */
    data: XOR<HospitalMentalWellnessUpdateInput, HospitalMentalWellnessUncheckedUpdateInput>
    /**
     * Choose, which HospitalMentalWellness to update.
     */
    where: HospitalMentalWellnessWhereUniqueInput
  }

  /**
   * HospitalMentalWellness updateMany
   */
  export type HospitalMentalWellnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HospitalMentalWellnesses.
     */
    data: XOR<HospitalMentalWellnessUpdateManyMutationInput, HospitalMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which HospitalMentalWellnesses to update
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * Limit how many HospitalMentalWellnesses to update.
     */
    limit?: number
  }

  /**
   * HospitalMentalWellness updateManyAndReturn
   */
  export type HospitalMentalWellnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * The data used to update HospitalMentalWellnesses.
     */
    data: XOR<HospitalMentalWellnessUpdateManyMutationInput, HospitalMentalWellnessUncheckedUpdateManyInput>
    /**
     * Filter which HospitalMentalWellnesses to update
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * Limit how many HospitalMentalWellnesses to update.
     */
    limit?: number
  }

  /**
   * HospitalMentalWellness upsert
   */
  export type HospitalMentalWellnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * The filter to search for the HospitalMentalWellness to update in case it exists.
     */
    where: HospitalMentalWellnessWhereUniqueInput
    /**
     * In case the HospitalMentalWellness found by the `where` argument doesn't exist, create a new HospitalMentalWellness with this data.
     */
    create: XOR<HospitalMentalWellnessCreateInput, HospitalMentalWellnessUncheckedCreateInput>
    /**
     * In case the HospitalMentalWellness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalMentalWellnessUpdateInput, HospitalMentalWellnessUncheckedUpdateInput>
  }

  /**
   * HospitalMentalWellness delete
   */
  export type HospitalMentalWellnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
    /**
     * Filter which HospitalMentalWellness to delete.
     */
    where: HospitalMentalWellnessWhereUniqueInput
  }

  /**
   * HospitalMentalWellness deleteMany
   */
  export type HospitalMentalWellnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HospitalMentalWellnesses to delete
     */
    where?: HospitalMentalWellnessWhereInput
    /**
     * Limit how many HospitalMentalWellnesses to delete.
     */
    limit?: number
  }

  /**
   * HospitalMentalWellness without action
   */
  export type HospitalMentalWellnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalMentalWellness
     */
    select?: HospitalMentalWellnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HospitalMentalWellness
     */
    omit?: HospitalMentalWellnessOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserDIYHomesScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserDIYHomesScalarFieldEnum = (typeof UserDIYHomesScalarFieldEnum)[keyof typeof UserDIYHomesScalarFieldEnum]


  export const PostDIYHomesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    category: 'category',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PostDIYHomesScalarFieldEnum = (typeof PostDIYHomesScalarFieldEnum)[keyof typeof PostDIYHomesScalarFieldEnum]


  export const ReviewDIYHomesScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ReviewDIYHomesScalarFieldEnum = (typeof ReviewDIYHomesScalarFieldEnum)[keyof typeof ReviewDIYHomesScalarFieldEnum]


  export const LikeDIYHomesScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LikeDIYHomesScalarFieldEnum = (typeof LikeDIYHomesScalarFieldEnum)[keyof typeof LikeDIYHomesScalarFieldEnum]


  export const BookmarkDIYHomesScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type BookmarkDIYHomesScalarFieldEnum = (typeof BookmarkDIYHomesScalarFieldEnum)[keyof typeof BookmarkDIYHomesScalarFieldEnum]


  export const ReportDIYHomesScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    reviewId: 'reviewId',
    userId: 'userId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReportDIYHomesScalarFieldEnum = (typeof ReportDIYHomesScalarFieldEnum)[keyof typeof ReportDIYHomesScalarFieldEnum]


  export const UserUrbanExplorerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserUrbanExplorerScalarFieldEnum = (typeof UserUrbanExplorerScalarFieldEnum)[keyof typeof UserUrbanExplorerScalarFieldEnum]


  export const PlaceUrbanExplorerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    location: 'location',
    description: 'description',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    validated: 'validated'
  };

  export type PlaceUrbanExplorerScalarFieldEnum = (typeof PlaceUrbanExplorerScalarFieldEnum)[keyof typeof PlaceUrbanExplorerScalarFieldEnum]


  export const ReviewUrbanExplorerScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ReviewUrbanExplorerScalarFieldEnum = (typeof ReviewUrbanExplorerScalarFieldEnum)[keyof typeof ReviewUrbanExplorerScalarFieldEnum]


  export const LikeUrbanExplorerScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type LikeUrbanExplorerScalarFieldEnum = (typeof LikeUrbanExplorerScalarFieldEnum)[keyof typeof LikeUrbanExplorerScalarFieldEnum]


  export const BookmarkUrbanExplorerScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type BookmarkUrbanExplorerScalarFieldEnum = (typeof BookmarkUrbanExplorerScalarFieldEnum)[keyof typeof BookmarkUrbanExplorerScalarFieldEnum]


  export const ReportUrbanExplorerScalarFieldEnum: {
    id: 'id',
    placeId: 'placeId',
    reviewId: 'reviewId',
    userId: 'userId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReportUrbanExplorerScalarFieldEnum = (typeof ReportUrbanExplorerScalarFieldEnum)[keyof typeof ReportUrbanExplorerScalarFieldEnum]


  export const UserFoodieScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserFoodieScalarFieldEnum = (typeof UserFoodieScalarFieldEnum)[keyof typeof UserFoodieScalarFieldEnum]


  export const FoodieFoodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cuisine: 'cuisine',
    origin: 'origin',
    description: 'description',
    submittedBy: 'submittedBy',
    validated: 'validated',
    createdAt: 'createdAt'
  };

  export type FoodieFoodScalarFieldEnum = (typeof FoodieFoodScalarFieldEnum)[keyof typeof FoodieFoodScalarFieldEnum]


  export const FoodieLocationScalarFieldEnum: {
    id: 'id',
    foodId: 'foodId',
    locationName: 'locationName',
    address: 'address',
    submittedBy: 'submittedBy',
    createdAt: 'createdAt'
  };

  export type FoodieLocationScalarFieldEnum = (typeof FoodieLocationScalarFieldEnum)[keyof typeof FoodieLocationScalarFieldEnum]


  export const FoodieReviewScalarFieldEnum: {
    id: 'id',
    foodId: 'foodId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    validated: 'validated',
    createdAt: 'createdAt'
  };

  export type FoodieReviewScalarFieldEnum = (typeof FoodieReviewScalarFieldEnum)[keyof typeof FoodieReviewScalarFieldEnum]


  export const FoodieLikeScalarFieldEnum: {
    id: 'id',
    foodId: 'foodId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type FoodieLikeScalarFieldEnum = (typeof FoodieLikeScalarFieldEnum)[keyof typeof FoodieLikeScalarFieldEnum]


  export const UserPetLoverScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserPetLoverScalarFieldEnum = (typeof UserPetLoverScalarFieldEnum)[keyof typeof UserPetLoverScalarFieldEnum]


  export const PetPetLoverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    petName: 'petName',
    species: 'species',
    breed: 'breed',
    age: 'age',
    medicalHistory: 'medicalHistory',
    createdAt: 'createdAt'
  };

  export type PetPetLoverScalarFieldEnum = (typeof PetPetLoverScalarFieldEnum)[keyof typeof PetPetLoverScalarFieldEnum]


  export const AppointmentPetLoverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    petId: 'petId',
    appointmentType: 'appointmentType',
    dateTime: 'dateTime',
    location: 'location',
    createdAt: 'createdAt'
  };

  export type AppointmentPetLoverScalarFieldEnum = (typeof AppointmentPetLoverScalarFieldEnum)[keyof typeof AppointmentPetLoverScalarFieldEnum]


  export const VaccinationPetLoverScalarFieldEnum: {
    id: 'id',
    petId: 'petId',
    vaccineName: 'vaccineName',
    dateAdministered: 'dateAdministered',
    nextDueDate: 'nextDueDate',
    createdAt: 'createdAt'
  };

  export type VaccinationPetLoverScalarFieldEnum = (typeof VaccinationPetLoverScalarFieldEnum)[keyof typeof VaccinationPetLoverScalarFieldEnum]


  export const ClinicPetLoverScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt'
  };

  export type ClinicPetLoverScalarFieldEnum = (typeof ClinicPetLoverScalarFieldEnum)[keyof typeof ClinicPetLoverScalarFieldEnum]


  export const StorePetLoverScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt'
  };

  export type StorePetLoverScalarFieldEnum = (typeof StorePetLoverScalarFieldEnum)[keyof typeof StorePetLoverScalarFieldEnum]


  export const UserElderlyCareCompanionScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserElderlyCareCompanionScalarFieldEnum = (typeof UserElderlyCareCompanionScalarFieldEnum)[keyof typeof UserElderlyCareCompanionScalarFieldEnum]


  export const ElderlyCareCompanionAppointmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    dateTime: 'dateTime',
    location: 'location',
    medicationDetails: 'medicationDetails',
    createdAt: 'createdAt'
  };

  export type ElderlyCareCompanionAppointmentScalarFieldEnum = (typeof ElderlyCareCompanionAppointmentScalarFieldEnum)[keyof typeof ElderlyCareCompanionAppointmentScalarFieldEnum]


  export const ElderlyCareCompanionClinicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt'
  };

  export type ElderlyCareCompanionClinicScalarFieldEnum = (typeof ElderlyCareCompanionClinicScalarFieldEnum)[keyof typeof ElderlyCareCompanionClinicScalarFieldEnum]


  export const ElderlyCareCompanionStoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    createdAt: 'createdAt'
  };

  export type ElderlyCareCompanionStoreScalarFieldEnum = (typeof ElderlyCareCompanionStoreScalarFieldEnum)[keyof typeof ElderlyCareCompanionStoreScalarFieldEnum]


  export const ElderlyCareCompanionRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    recordType: 'recordType',
    details: 'details',
    date: 'date',
    createdAt: 'createdAt'
  };

  export type ElderlyCareCompanionRecordScalarFieldEnum = (typeof ElderlyCareCompanionRecordScalarFieldEnum)[keyof typeof ElderlyCareCompanionRecordScalarFieldEnum]


  export const ElderlyCareCompanionMedicationTrackingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    medicationId: 'medicationId',
    status: 'status',
    dateTime: 'dateTime'
  };

  export type ElderlyCareCompanionMedicationTrackingScalarFieldEnum = (typeof ElderlyCareCompanionMedicationTrackingScalarFieldEnum)[keyof typeof ElderlyCareCompanionMedicationTrackingScalarFieldEnum]


  export const UserEduSeekerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserEduSeekerScalarFieldEnum = (typeof UserEduSeekerScalarFieldEnum)[keyof typeof UserEduSeekerScalarFieldEnum]


  export const PlatformEduSeekerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    url: 'url',
    submittedBy: 'submittedBy',
    createdAt: 'createdAt',
    validated: 'validated'
  };

  export type PlatformEduSeekerScalarFieldEnum = (typeof PlatformEduSeekerScalarFieldEnum)[keyof typeof PlatformEduSeekerScalarFieldEnum]


  export const ReviewEduSeekerScalarFieldEnum: {
    id: 'id',
    platformId: 'platformId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    validated: 'validated',
    createdAt: 'createdAt'
  };

  export type ReviewEduSeekerScalarFieldEnum = (typeof ReviewEduSeekerScalarFieldEnum)[keyof typeof ReviewEduSeekerScalarFieldEnum]


  export const UserFinanceManagerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserFinanceManagerScalarFieldEnum = (typeof UserFinanceManagerScalarFieldEnum)[keyof typeof UserFinanceManagerScalarFieldEnum]


  export const TransactionFinanceManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    type: 'type',
    category: 'category',
    source: 'source',
    date: 'date',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TransactionFinanceManagerScalarFieldEnum = (typeof TransactionFinanceManagerScalarFieldEnum)[keyof typeof TransactionFinanceManagerScalarFieldEnum]


  export const GoalFinanceManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    targetAmount: 'targetAmount',
    deadline: 'deadline',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type GoalFinanceManagerScalarFieldEnum = (typeof GoalFinanceManagerScalarFieldEnum)[keyof typeof GoalFinanceManagerScalarFieldEnum]


  export const UserMentalWellnessScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserMentalWellnessScalarFieldEnum = (typeof UserMentalWellnessScalarFieldEnum)[keyof typeof UserMentalWellnessScalarFieldEnum]


  export const JournalMentalWellnessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mood: 'mood',
    entryText: 'entryText',
    tags: 'tags',
    createdAt: 'createdAt'
  };

  export type JournalMentalWellnessScalarFieldEnum = (typeof JournalMentalWellnessScalarFieldEnum)[keyof typeof JournalMentalWellnessScalarFieldEnum]


  export const AssessmentMentalWellnessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    responses: 'responses',
    result: 'result',
    createdAt: 'createdAt'
  };

  export type AssessmentMentalWellnessScalarFieldEnum = (typeof AssessmentMentalWellnessScalarFieldEnum)[keyof typeof AssessmentMentalWellnessScalarFieldEnum]


  export const MeditationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    audioUrl: 'audioUrl',
    createdAt: 'createdAt'
  };

  export type MeditationScalarFieldEnum = (typeof MeditationScalarFieldEnum)[keyof typeof MeditationScalarFieldEnum]


  export const MeditationFeedbackScalarFieldEnum: {
    id: 'id',
    meditationId: 'meditationId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type MeditationFeedbackScalarFieldEnum = (typeof MeditationFeedbackScalarFieldEnum)[keyof typeof MeditationFeedbackScalarFieldEnum]


  export const HospitalMentalWellnessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    contactInfo: 'contactInfo',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type HospitalMentalWellnessScalarFieldEnum = (typeof HospitalMentalWellnessScalarFieldEnum)[keyof typeof HospitalMentalWellnessScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserDIYHomesWhereInput = {
    AND?: UserDIYHomesWhereInput | UserDIYHomesWhereInput[]
    OR?: UserDIYHomesWhereInput[]
    NOT?: UserDIYHomesWhereInput | UserDIYHomesWhereInput[]
    id?: StringFilter<"UserDIYHomes"> | string
    email?: StringFilter<"UserDIYHomes"> | string
    name?: StringFilter<"UserDIYHomes"> | string
    password?: StringFilter<"UserDIYHomes"> | string
    createdAt?: DateTimeFilter<"UserDIYHomes"> | Date | string
    PostDIYHomes?: PostDIYHomesListRelationFilter
    ReviewDIYHomes?: ReviewDIYHomesListRelationFilter
    LikeDIYHomes?: LikeDIYHomesListRelationFilter
    BookmarkDIYHomes?: BookmarkDIYHomesListRelationFilter
    ReportDIYHomes?: ReportDIYHomesListRelationFilter
  }

  export type UserDIYHomesOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    PostDIYHomes?: PostDIYHomesOrderByRelationAggregateInput
    ReviewDIYHomes?: ReviewDIYHomesOrderByRelationAggregateInput
    LikeDIYHomes?: LikeDIYHomesOrderByRelationAggregateInput
    BookmarkDIYHomes?: BookmarkDIYHomesOrderByRelationAggregateInput
    ReportDIYHomes?: ReportDIYHomesOrderByRelationAggregateInput
  }

  export type UserDIYHomesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserDIYHomesWhereInput | UserDIYHomesWhereInput[]
    OR?: UserDIYHomesWhereInput[]
    NOT?: UserDIYHomesWhereInput | UserDIYHomesWhereInput[]
    name?: StringFilter<"UserDIYHomes"> | string
    password?: StringFilter<"UserDIYHomes"> | string
    createdAt?: DateTimeFilter<"UserDIYHomes"> | Date | string
    PostDIYHomes?: PostDIYHomesListRelationFilter
    ReviewDIYHomes?: ReviewDIYHomesListRelationFilter
    LikeDIYHomes?: LikeDIYHomesListRelationFilter
    BookmarkDIYHomes?: BookmarkDIYHomesListRelationFilter
    ReportDIYHomes?: ReportDIYHomesListRelationFilter
  }, "id" | "email">

  export type UserDIYHomesOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserDIYHomesCountOrderByAggregateInput
    _max?: UserDIYHomesMaxOrderByAggregateInput
    _min?: UserDIYHomesMinOrderByAggregateInput
  }

  export type UserDIYHomesScalarWhereWithAggregatesInput = {
    AND?: UserDIYHomesScalarWhereWithAggregatesInput | UserDIYHomesScalarWhereWithAggregatesInput[]
    OR?: UserDIYHomesScalarWhereWithAggregatesInput[]
    NOT?: UserDIYHomesScalarWhereWithAggregatesInput | UserDIYHomesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDIYHomes"> | string
    email?: StringWithAggregatesFilter<"UserDIYHomes"> | string
    name?: StringWithAggregatesFilter<"UserDIYHomes"> | string
    password?: StringWithAggregatesFilter<"UserDIYHomes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserDIYHomes"> | Date | string
  }

  export type PostDIYHomesWhereInput = {
    AND?: PostDIYHomesWhereInput | PostDIYHomesWhereInput[]
    OR?: PostDIYHomesWhereInput[]
    NOT?: PostDIYHomesWhereInput | PostDIYHomesWhereInput[]
    id?: StringFilter<"PostDIYHomes"> | string
    title?: StringFilter<"PostDIYHomes"> | string
    content?: StringFilter<"PostDIYHomes"> | string
    category?: StringFilter<"PostDIYHomes"> | string
    userId?: StringFilter<"PostDIYHomes"> | string
    createdAt?: DateTimeFilter<"PostDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    reviews?: ReviewDIYHomesListRelationFilter
    bookmarks?: BookmarkDIYHomesListRelationFilter
    Like?: LikeDIYHomesListRelationFilter
    Report?: ReportDIYHomesListRelationFilter
  }

  export type PostDIYHomesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserDIYHomesOrderByWithRelationInput
    reviews?: ReviewDIYHomesOrderByRelationAggregateInput
    bookmarks?: BookmarkDIYHomesOrderByRelationAggregateInput
    Like?: LikeDIYHomesOrderByRelationAggregateInput
    Report?: ReportDIYHomesOrderByRelationAggregateInput
  }

  export type PostDIYHomesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostDIYHomesWhereInput | PostDIYHomesWhereInput[]
    OR?: PostDIYHomesWhereInput[]
    NOT?: PostDIYHomesWhereInput | PostDIYHomesWhereInput[]
    title?: StringFilter<"PostDIYHomes"> | string
    content?: StringFilter<"PostDIYHomes"> | string
    category?: StringFilter<"PostDIYHomes"> | string
    userId?: StringFilter<"PostDIYHomes"> | string
    createdAt?: DateTimeFilter<"PostDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    reviews?: ReviewDIYHomesListRelationFilter
    bookmarks?: BookmarkDIYHomesListRelationFilter
    Like?: LikeDIYHomesListRelationFilter
    Report?: ReportDIYHomesListRelationFilter
  }, "id">

  export type PostDIYHomesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: PostDIYHomesCountOrderByAggregateInput
    _max?: PostDIYHomesMaxOrderByAggregateInput
    _min?: PostDIYHomesMinOrderByAggregateInput
  }

  export type PostDIYHomesScalarWhereWithAggregatesInput = {
    AND?: PostDIYHomesScalarWhereWithAggregatesInput | PostDIYHomesScalarWhereWithAggregatesInput[]
    OR?: PostDIYHomesScalarWhereWithAggregatesInput[]
    NOT?: PostDIYHomesScalarWhereWithAggregatesInput | PostDIYHomesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostDIYHomes"> | string
    title?: StringWithAggregatesFilter<"PostDIYHomes"> | string
    content?: StringWithAggregatesFilter<"PostDIYHomes"> | string
    category?: StringWithAggregatesFilter<"PostDIYHomes"> | string
    userId?: StringWithAggregatesFilter<"PostDIYHomes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostDIYHomes"> | Date | string
  }

  export type ReviewDIYHomesWhereInput = {
    AND?: ReviewDIYHomesWhereInput | ReviewDIYHomesWhereInput[]
    OR?: ReviewDIYHomesWhereInput[]
    NOT?: ReviewDIYHomesWhereInput | ReviewDIYHomesWhereInput[]
    id?: StringFilter<"ReviewDIYHomes"> | string
    postId?: StringFilter<"ReviewDIYHomes"> | string
    userId?: StringFilter<"ReviewDIYHomes"> | string
    rating?: IntFilter<"ReviewDIYHomes"> | number
    comment?: StringFilter<"ReviewDIYHomes"> | string
    createdAt?: DateTimeFilter<"ReviewDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesScalarRelationFilter, PostDIYHomesWhereInput>
    Report?: ReportDIYHomesListRelationFilter
  }

  export type ReviewDIYHomesOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    user?: UserDIYHomesOrderByWithRelationInput
    post?: PostDIYHomesOrderByWithRelationInput
    Report?: ReportDIYHomesOrderByRelationAggregateInput
  }

  export type ReviewDIYHomesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewDIYHomesWhereInput | ReviewDIYHomesWhereInput[]
    OR?: ReviewDIYHomesWhereInput[]
    NOT?: ReviewDIYHomesWhereInput | ReviewDIYHomesWhereInput[]
    postId?: StringFilter<"ReviewDIYHomes"> | string
    userId?: StringFilter<"ReviewDIYHomes"> | string
    rating?: IntFilter<"ReviewDIYHomes"> | number
    comment?: StringFilter<"ReviewDIYHomes"> | string
    createdAt?: DateTimeFilter<"ReviewDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesScalarRelationFilter, PostDIYHomesWhereInput>
    Report?: ReportDIYHomesListRelationFilter
  }, "id">

  export type ReviewDIYHomesOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewDIYHomesCountOrderByAggregateInput
    _avg?: ReviewDIYHomesAvgOrderByAggregateInput
    _max?: ReviewDIYHomesMaxOrderByAggregateInput
    _min?: ReviewDIYHomesMinOrderByAggregateInput
    _sum?: ReviewDIYHomesSumOrderByAggregateInput
  }

  export type ReviewDIYHomesScalarWhereWithAggregatesInput = {
    AND?: ReviewDIYHomesScalarWhereWithAggregatesInput | ReviewDIYHomesScalarWhereWithAggregatesInput[]
    OR?: ReviewDIYHomesScalarWhereWithAggregatesInput[]
    NOT?: ReviewDIYHomesScalarWhereWithAggregatesInput | ReviewDIYHomesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewDIYHomes"> | string
    postId?: StringWithAggregatesFilter<"ReviewDIYHomes"> | string
    userId?: StringWithAggregatesFilter<"ReviewDIYHomes"> | string
    rating?: IntWithAggregatesFilter<"ReviewDIYHomes"> | number
    comment?: StringWithAggregatesFilter<"ReviewDIYHomes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewDIYHomes"> | Date | string
  }

  export type LikeDIYHomesWhereInput = {
    AND?: LikeDIYHomesWhereInput | LikeDIYHomesWhereInput[]
    OR?: LikeDIYHomesWhereInput[]
    NOT?: LikeDIYHomesWhereInput | LikeDIYHomesWhereInput[]
    id?: StringFilter<"LikeDIYHomes"> | string
    postId?: StringFilter<"LikeDIYHomes"> | string
    userId?: StringFilter<"LikeDIYHomes"> | string
    createdAt?: DateTimeFilter<"LikeDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesScalarRelationFilter, PostDIYHomesWhereInput>
  }

  export type LikeDIYHomesOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserDIYHomesOrderByWithRelationInput
    post?: PostDIYHomesOrderByWithRelationInput
  }

  export type LikeDIYHomesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: LikeDIYHomesPostIdUserIdCompoundUniqueInput
    AND?: LikeDIYHomesWhereInput | LikeDIYHomesWhereInput[]
    OR?: LikeDIYHomesWhereInput[]
    NOT?: LikeDIYHomesWhereInput | LikeDIYHomesWhereInput[]
    postId?: StringFilter<"LikeDIYHomes"> | string
    userId?: StringFilter<"LikeDIYHomes"> | string
    createdAt?: DateTimeFilter<"LikeDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesScalarRelationFilter, PostDIYHomesWhereInput>
  }, "id" | "postId_userId">

  export type LikeDIYHomesOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeDIYHomesCountOrderByAggregateInput
    _max?: LikeDIYHomesMaxOrderByAggregateInput
    _min?: LikeDIYHomesMinOrderByAggregateInput
  }

  export type LikeDIYHomesScalarWhereWithAggregatesInput = {
    AND?: LikeDIYHomesScalarWhereWithAggregatesInput | LikeDIYHomesScalarWhereWithAggregatesInput[]
    OR?: LikeDIYHomesScalarWhereWithAggregatesInput[]
    NOT?: LikeDIYHomesScalarWhereWithAggregatesInput | LikeDIYHomesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikeDIYHomes"> | string
    postId?: StringWithAggregatesFilter<"LikeDIYHomes"> | string
    userId?: StringWithAggregatesFilter<"LikeDIYHomes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LikeDIYHomes"> | Date | string
  }

  export type BookmarkDIYHomesWhereInput = {
    AND?: BookmarkDIYHomesWhereInput | BookmarkDIYHomesWhereInput[]
    OR?: BookmarkDIYHomesWhereInput[]
    NOT?: BookmarkDIYHomesWhereInput | BookmarkDIYHomesWhereInput[]
    id?: StringFilter<"BookmarkDIYHomes"> | string
    postId?: StringFilter<"BookmarkDIYHomes"> | string
    userId?: StringFilter<"BookmarkDIYHomes"> | string
    createdAt?: DateTimeFilter<"BookmarkDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesScalarRelationFilter, PostDIYHomesWhereInput>
  }

  export type BookmarkDIYHomesOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserDIYHomesOrderByWithRelationInput
    post?: PostDIYHomesOrderByWithRelationInput
  }

  export type BookmarkDIYHomesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: BookmarkDIYHomesPostIdUserIdCompoundUniqueInput
    AND?: BookmarkDIYHomesWhereInput | BookmarkDIYHomesWhereInput[]
    OR?: BookmarkDIYHomesWhereInput[]
    NOT?: BookmarkDIYHomesWhereInput | BookmarkDIYHomesWhereInput[]
    postId?: StringFilter<"BookmarkDIYHomes"> | string
    userId?: StringFilter<"BookmarkDIYHomes"> | string
    createdAt?: DateTimeFilter<"BookmarkDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesScalarRelationFilter, PostDIYHomesWhereInput>
  }, "id" | "postId_userId">

  export type BookmarkDIYHomesOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkDIYHomesCountOrderByAggregateInput
    _max?: BookmarkDIYHomesMaxOrderByAggregateInput
    _min?: BookmarkDIYHomesMinOrderByAggregateInput
  }

  export type BookmarkDIYHomesScalarWhereWithAggregatesInput = {
    AND?: BookmarkDIYHomesScalarWhereWithAggregatesInput | BookmarkDIYHomesScalarWhereWithAggregatesInput[]
    OR?: BookmarkDIYHomesScalarWhereWithAggregatesInput[]
    NOT?: BookmarkDIYHomesScalarWhereWithAggregatesInput | BookmarkDIYHomesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookmarkDIYHomes"> | string
    postId?: StringWithAggregatesFilter<"BookmarkDIYHomes"> | string
    userId?: StringWithAggregatesFilter<"BookmarkDIYHomes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BookmarkDIYHomes"> | Date | string
  }

  export type ReportDIYHomesWhereInput = {
    AND?: ReportDIYHomesWhereInput | ReportDIYHomesWhereInput[]
    OR?: ReportDIYHomesWhereInput[]
    NOT?: ReportDIYHomesWhereInput | ReportDIYHomesWhereInput[]
    id?: StringFilter<"ReportDIYHomes"> | string
    postId?: StringNullableFilter<"ReportDIYHomes"> | string | null
    reviewId?: StringNullableFilter<"ReportDIYHomes"> | string | null
    userId?: StringFilter<"ReportDIYHomes"> | string
    reason?: StringFilter<"ReportDIYHomes"> | string
    createdAt?: DateTimeFilter<"ReportDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesNullableScalarRelationFilter, PostDIYHomesWhereInput> | null
    review?: XOR<ReviewDIYHomesNullableScalarRelationFilter, ReviewDIYHomesWhereInput> | null
  }

  export type ReportDIYHomesOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    user?: UserDIYHomesOrderByWithRelationInput
    post?: PostDIYHomesOrderByWithRelationInput
    review?: ReviewDIYHomesOrderByWithRelationInput
  }

  export type ReportDIYHomesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportDIYHomesWhereInput | ReportDIYHomesWhereInput[]
    OR?: ReportDIYHomesWhereInput[]
    NOT?: ReportDIYHomesWhereInput | ReportDIYHomesWhereInput[]
    postId?: StringNullableFilter<"ReportDIYHomes"> | string | null
    reviewId?: StringNullableFilter<"ReportDIYHomes"> | string | null
    userId?: StringFilter<"ReportDIYHomes"> | string
    reason?: StringFilter<"ReportDIYHomes"> | string
    createdAt?: DateTimeFilter<"ReportDIYHomes"> | Date | string
    user?: XOR<UserDIYHomesScalarRelationFilter, UserDIYHomesWhereInput>
    post?: XOR<PostDIYHomesNullableScalarRelationFilter, PostDIYHomesWhereInput> | null
    review?: XOR<ReviewDIYHomesNullableScalarRelationFilter, ReviewDIYHomesWhereInput> | null
  }, "id">

  export type ReportDIYHomesOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: ReportDIYHomesCountOrderByAggregateInput
    _max?: ReportDIYHomesMaxOrderByAggregateInput
    _min?: ReportDIYHomesMinOrderByAggregateInput
  }

  export type ReportDIYHomesScalarWhereWithAggregatesInput = {
    AND?: ReportDIYHomesScalarWhereWithAggregatesInput | ReportDIYHomesScalarWhereWithAggregatesInput[]
    OR?: ReportDIYHomesScalarWhereWithAggregatesInput[]
    NOT?: ReportDIYHomesScalarWhereWithAggregatesInput | ReportDIYHomesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportDIYHomes"> | string
    postId?: StringNullableWithAggregatesFilter<"ReportDIYHomes"> | string | null
    reviewId?: StringNullableWithAggregatesFilter<"ReportDIYHomes"> | string | null
    userId?: StringWithAggregatesFilter<"ReportDIYHomes"> | string
    reason?: StringWithAggregatesFilter<"ReportDIYHomes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportDIYHomes"> | Date | string
  }

  export type UserUrbanExplorerWhereInput = {
    AND?: UserUrbanExplorerWhereInput | UserUrbanExplorerWhereInput[]
    OR?: UserUrbanExplorerWhereInput[]
    NOT?: UserUrbanExplorerWhereInput | UserUrbanExplorerWhereInput[]
    id?: StringFilter<"UserUrbanExplorer"> | string
    email?: StringFilter<"UserUrbanExplorer"> | string
    name?: StringFilter<"UserUrbanExplorer"> | string
    password?: StringFilter<"UserUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"UserUrbanExplorer"> | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerListRelationFilter
    ReviewUrbanExplorer?: ReviewUrbanExplorerListRelationFilter
    LikeUrbanExplorer?: LikeUrbanExplorerListRelationFilter
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerListRelationFilter
    ReportUrbanExplorer?: ReportUrbanExplorerListRelationFilter
  }

  export type UserUrbanExplorerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    PlaceUrbanExplorer?: PlaceUrbanExplorerOrderByRelationAggregateInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerOrderByRelationAggregateInput
    LikeUrbanExplorer?: LikeUrbanExplorerOrderByRelationAggregateInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerOrderByRelationAggregateInput
    ReportUrbanExplorer?: ReportUrbanExplorerOrderByRelationAggregateInput
  }

  export type UserUrbanExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserUrbanExplorerWhereInput | UserUrbanExplorerWhereInput[]
    OR?: UserUrbanExplorerWhereInput[]
    NOT?: UserUrbanExplorerWhereInput | UserUrbanExplorerWhereInput[]
    name?: StringFilter<"UserUrbanExplorer"> | string
    password?: StringFilter<"UserUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"UserUrbanExplorer"> | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerListRelationFilter
    ReviewUrbanExplorer?: ReviewUrbanExplorerListRelationFilter
    LikeUrbanExplorer?: LikeUrbanExplorerListRelationFilter
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerListRelationFilter
    ReportUrbanExplorer?: ReportUrbanExplorerListRelationFilter
  }, "id" | "email">

  export type UserUrbanExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserUrbanExplorerCountOrderByAggregateInput
    _max?: UserUrbanExplorerMaxOrderByAggregateInput
    _min?: UserUrbanExplorerMinOrderByAggregateInput
  }

  export type UserUrbanExplorerScalarWhereWithAggregatesInput = {
    AND?: UserUrbanExplorerScalarWhereWithAggregatesInput | UserUrbanExplorerScalarWhereWithAggregatesInput[]
    OR?: UserUrbanExplorerScalarWhereWithAggregatesInput[]
    NOT?: UserUrbanExplorerScalarWhereWithAggregatesInput | UserUrbanExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserUrbanExplorer"> | string
    email?: StringWithAggregatesFilter<"UserUrbanExplorer"> | string
    name?: StringWithAggregatesFilter<"UserUrbanExplorer"> | string
    password?: StringWithAggregatesFilter<"UserUrbanExplorer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserUrbanExplorer"> | Date | string
  }

  export type PlaceUrbanExplorerWhereInput = {
    AND?: PlaceUrbanExplorerWhereInput | PlaceUrbanExplorerWhereInput[]
    OR?: PlaceUrbanExplorerWhereInput[]
    NOT?: PlaceUrbanExplorerWhereInput | PlaceUrbanExplorerWhereInput[]
    id?: StringFilter<"PlaceUrbanExplorer"> | string
    name?: StringFilter<"PlaceUrbanExplorer"> | string
    category?: StringFilter<"PlaceUrbanExplorer"> | string
    location?: StringFilter<"PlaceUrbanExplorer"> | string
    description?: StringFilter<"PlaceUrbanExplorer"> | string
    ownerId?: StringFilter<"PlaceUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"PlaceUrbanExplorer"> | Date | string
    validated?: BoolFilter<"PlaceUrbanExplorer"> | boolean
    owner?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    reviews?: ReviewUrbanExplorerListRelationFilter
    bookmarks?: BookmarkUrbanExplorerListRelationFilter
    likes?: LikeUrbanExplorerListRelationFilter
    reports?: ReportUrbanExplorerListRelationFilter
  }

  export type PlaceUrbanExplorerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
    owner?: UserUrbanExplorerOrderByWithRelationInput
    reviews?: ReviewUrbanExplorerOrderByRelationAggregateInput
    bookmarks?: BookmarkUrbanExplorerOrderByRelationAggregateInput
    likes?: LikeUrbanExplorerOrderByRelationAggregateInput
    reports?: ReportUrbanExplorerOrderByRelationAggregateInput
  }

  export type PlaceUrbanExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlaceUrbanExplorerWhereInput | PlaceUrbanExplorerWhereInput[]
    OR?: PlaceUrbanExplorerWhereInput[]
    NOT?: PlaceUrbanExplorerWhereInput | PlaceUrbanExplorerWhereInput[]
    name?: StringFilter<"PlaceUrbanExplorer"> | string
    category?: StringFilter<"PlaceUrbanExplorer"> | string
    location?: StringFilter<"PlaceUrbanExplorer"> | string
    description?: StringFilter<"PlaceUrbanExplorer"> | string
    ownerId?: StringFilter<"PlaceUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"PlaceUrbanExplorer"> | Date | string
    validated?: BoolFilter<"PlaceUrbanExplorer"> | boolean
    owner?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    reviews?: ReviewUrbanExplorerListRelationFilter
    bookmarks?: BookmarkUrbanExplorerListRelationFilter
    likes?: LikeUrbanExplorerListRelationFilter
    reports?: ReportUrbanExplorerListRelationFilter
  }, "id">

  export type PlaceUrbanExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
    _count?: PlaceUrbanExplorerCountOrderByAggregateInput
    _max?: PlaceUrbanExplorerMaxOrderByAggregateInput
    _min?: PlaceUrbanExplorerMinOrderByAggregateInput
  }

  export type PlaceUrbanExplorerScalarWhereWithAggregatesInput = {
    AND?: PlaceUrbanExplorerScalarWhereWithAggregatesInput | PlaceUrbanExplorerScalarWhereWithAggregatesInput[]
    OR?: PlaceUrbanExplorerScalarWhereWithAggregatesInput[]
    NOT?: PlaceUrbanExplorerScalarWhereWithAggregatesInput | PlaceUrbanExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlaceUrbanExplorer"> | string
    name?: StringWithAggregatesFilter<"PlaceUrbanExplorer"> | string
    category?: StringWithAggregatesFilter<"PlaceUrbanExplorer"> | string
    location?: StringWithAggregatesFilter<"PlaceUrbanExplorer"> | string
    description?: StringWithAggregatesFilter<"PlaceUrbanExplorer"> | string
    ownerId?: StringWithAggregatesFilter<"PlaceUrbanExplorer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlaceUrbanExplorer"> | Date | string
    validated?: BoolWithAggregatesFilter<"PlaceUrbanExplorer"> | boolean
  }

  export type ReviewUrbanExplorerWhereInput = {
    AND?: ReviewUrbanExplorerWhereInput | ReviewUrbanExplorerWhereInput[]
    OR?: ReviewUrbanExplorerWhereInput[]
    NOT?: ReviewUrbanExplorerWhereInput | ReviewUrbanExplorerWhereInput[]
    id?: StringFilter<"ReviewUrbanExplorer"> | string
    placeId?: StringFilter<"ReviewUrbanExplorer"> | string
    userId?: StringFilter<"ReviewUrbanExplorer"> | string
    rating?: IntFilter<"ReviewUrbanExplorer"> | number
    comment?: StringFilter<"ReviewUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"ReviewUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerScalarRelationFilter, PlaceUrbanExplorerWhereInput>
    reports?: ReportUrbanExplorerListRelationFilter
  }

  export type ReviewUrbanExplorerOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    user?: UserUrbanExplorerOrderByWithRelationInput
    place?: PlaceUrbanExplorerOrderByWithRelationInput
    reports?: ReportUrbanExplorerOrderByRelationAggregateInput
  }

  export type ReviewUrbanExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewUrbanExplorerWhereInput | ReviewUrbanExplorerWhereInput[]
    OR?: ReviewUrbanExplorerWhereInput[]
    NOT?: ReviewUrbanExplorerWhereInput | ReviewUrbanExplorerWhereInput[]
    placeId?: StringFilter<"ReviewUrbanExplorer"> | string
    userId?: StringFilter<"ReviewUrbanExplorer"> | string
    rating?: IntFilter<"ReviewUrbanExplorer"> | number
    comment?: StringFilter<"ReviewUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"ReviewUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerScalarRelationFilter, PlaceUrbanExplorerWhereInput>
    reports?: ReportUrbanExplorerListRelationFilter
  }, "id">

  export type ReviewUrbanExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewUrbanExplorerCountOrderByAggregateInput
    _avg?: ReviewUrbanExplorerAvgOrderByAggregateInput
    _max?: ReviewUrbanExplorerMaxOrderByAggregateInput
    _min?: ReviewUrbanExplorerMinOrderByAggregateInput
    _sum?: ReviewUrbanExplorerSumOrderByAggregateInput
  }

  export type ReviewUrbanExplorerScalarWhereWithAggregatesInput = {
    AND?: ReviewUrbanExplorerScalarWhereWithAggregatesInput | ReviewUrbanExplorerScalarWhereWithAggregatesInput[]
    OR?: ReviewUrbanExplorerScalarWhereWithAggregatesInput[]
    NOT?: ReviewUrbanExplorerScalarWhereWithAggregatesInput | ReviewUrbanExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewUrbanExplorer"> | string
    placeId?: StringWithAggregatesFilter<"ReviewUrbanExplorer"> | string
    userId?: StringWithAggregatesFilter<"ReviewUrbanExplorer"> | string
    rating?: IntWithAggregatesFilter<"ReviewUrbanExplorer"> | number
    comment?: StringWithAggregatesFilter<"ReviewUrbanExplorer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewUrbanExplorer"> | Date | string
  }

  export type LikeUrbanExplorerWhereInput = {
    AND?: LikeUrbanExplorerWhereInput | LikeUrbanExplorerWhereInput[]
    OR?: LikeUrbanExplorerWhereInput[]
    NOT?: LikeUrbanExplorerWhereInput | LikeUrbanExplorerWhereInput[]
    id?: StringFilter<"LikeUrbanExplorer"> | string
    placeId?: StringFilter<"LikeUrbanExplorer"> | string
    userId?: StringFilter<"LikeUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"LikeUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerScalarRelationFilter, PlaceUrbanExplorerWhereInput>
  }

  export type LikeUrbanExplorerOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserUrbanExplorerOrderByWithRelationInput
    place?: PlaceUrbanExplorerOrderByWithRelationInput
  }

  export type LikeUrbanExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    placeId_userId?: LikeUrbanExplorerPlaceIdUserIdCompoundUniqueInput
    AND?: LikeUrbanExplorerWhereInput | LikeUrbanExplorerWhereInput[]
    OR?: LikeUrbanExplorerWhereInput[]
    NOT?: LikeUrbanExplorerWhereInput | LikeUrbanExplorerWhereInput[]
    placeId?: StringFilter<"LikeUrbanExplorer"> | string
    userId?: StringFilter<"LikeUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"LikeUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerScalarRelationFilter, PlaceUrbanExplorerWhereInput>
  }, "id" | "placeId_userId">

  export type LikeUrbanExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeUrbanExplorerCountOrderByAggregateInput
    _max?: LikeUrbanExplorerMaxOrderByAggregateInput
    _min?: LikeUrbanExplorerMinOrderByAggregateInput
  }

  export type LikeUrbanExplorerScalarWhereWithAggregatesInput = {
    AND?: LikeUrbanExplorerScalarWhereWithAggregatesInput | LikeUrbanExplorerScalarWhereWithAggregatesInput[]
    OR?: LikeUrbanExplorerScalarWhereWithAggregatesInput[]
    NOT?: LikeUrbanExplorerScalarWhereWithAggregatesInput | LikeUrbanExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LikeUrbanExplorer"> | string
    placeId?: StringWithAggregatesFilter<"LikeUrbanExplorer"> | string
    userId?: StringWithAggregatesFilter<"LikeUrbanExplorer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LikeUrbanExplorer"> | Date | string
  }

  export type BookmarkUrbanExplorerWhereInput = {
    AND?: BookmarkUrbanExplorerWhereInput | BookmarkUrbanExplorerWhereInput[]
    OR?: BookmarkUrbanExplorerWhereInput[]
    NOT?: BookmarkUrbanExplorerWhereInput | BookmarkUrbanExplorerWhereInput[]
    id?: StringFilter<"BookmarkUrbanExplorer"> | string
    placeId?: StringFilter<"BookmarkUrbanExplorer"> | string
    userId?: StringFilter<"BookmarkUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"BookmarkUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerScalarRelationFilter, PlaceUrbanExplorerWhereInput>
  }

  export type BookmarkUrbanExplorerOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserUrbanExplorerOrderByWithRelationInput
    place?: PlaceUrbanExplorerOrderByWithRelationInput
  }

  export type BookmarkUrbanExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    placeId_userId?: BookmarkUrbanExplorerPlaceIdUserIdCompoundUniqueInput
    AND?: BookmarkUrbanExplorerWhereInput | BookmarkUrbanExplorerWhereInput[]
    OR?: BookmarkUrbanExplorerWhereInput[]
    NOT?: BookmarkUrbanExplorerWhereInput | BookmarkUrbanExplorerWhereInput[]
    placeId?: StringFilter<"BookmarkUrbanExplorer"> | string
    userId?: StringFilter<"BookmarkUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"BookmarkUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerScalarRelationFilter, PlaceUrbanExplorerWhereInput>
  }, "id" | "placeId_userId">

  export type BookmarkUrbanExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkUrbanExplorerCountOrderByAggregateInput
    _max?: BookmarkUrbanExplorerMaxOrderByAggregateInput
    _min?: BookmarkUrbanExplorerMinOrderByAggregateInput
  }

  export type BookmarkUrbanExplorerScalarWhereWithAggregatesInput = {
    AND?: BookmarkUrbanExplorerScalarWhereWithAggregatesInput | BookmarkUrbanExplorerScalarWhereWithAggregatesInput[]
    OR?: BookmarkUrbanExplorerScalarWhereWithAggregatesInput[]
    NOT?: BookmarkUrbanExplorerScalarWhereWithAggregatesInput | BookmarkUrbanExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookmarkUrbanExplorer"> | string
    placeId?: StringWithAggregatesFilter<"BookmarkUrbanExplorer"> | string
    userId?: StringWithAggregatesFilter<"BookmarkUrbanExplorer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BookmarkUrbanExplorer"> | Date | string
  }

  export type ReportUrbanExplorerWhereInput = {
    AND?: ReportUrbanExplorerWhereInput | ReportUrbanExplorerWhereInput[]
    OR?: ReportUrbanExplorerWhereInput[]
    NOT?: ReportUrbanExplorerWhereInput | ReportUrbanExplorerWhereInput[]
    id?: StringFilter<"ReportUrbanExplorer"> | string
    placeId?: StringNullableFilter<"ReportUrbanExplorer"> | string | null
    reviewId?: StringNullableFilter<"ReportUrbanExplorer"> | string | null
    userId?: StringFilter<"ReportUrbanExplorer"> | string
    reason?: StringFilter<"ReportUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"ReportUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerNullableScalarRelationFilter, PlaceUrbanExplorerWhereInput> | null
    review?: XOR<ReviewUrbanExplorerNullableScalarRelationFilter, ReviewUrbanExplorerWhereInput> | null
  }

  export type ReportUrbanExplorerOrderByWithRelationInput = {
    id?: SortOrder
    placeId?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    user?: UserUrbanExplorerOrderByWithRelationInput
    place?: PlaceUrbanExplorerOrderByWithRelationInput
    review?: ReviewUrbanExplorerOrderByWithRelationInput
  }

  export type ReportUrbanExplorerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportUrbanExplorerWhereInput | ReportUrbanExplorerWhereInput[]
    OR?: ReportUrbanExplorerWhereInput[]
    NOT?: ReportUrbanExplorerWhereInput | ReportUrbanExplorerWhereInput[]
    placeId?: StringNullableFilter<"ReportUrbanExplorer"> | string | null
    reviewId?: StringNullableFilter<"ReportUrbanExplorer"> | string | null
    userId?: StringFilter<"ReportUrbanExplorer"> | string
    reason?: StringFilter<"ReportUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"ReportUrbanExplorer"> | Date | string
    user?: XOR<UserUrbanExplorerScalarRelationFilter, UserUrbanExplorerWhereInput>
    place?: XOR<PlaceUrbanExplorerNullableScalarRelationFilter, PlaceUrbanExplorerWhereInput> | null
    review?: XOR<ReviewUrbanExplorerNullableScalarRelationFilter, ReviewUrbanExplorerWhereInput> | null
  }, "id">

  export type ReportUrbanExplorerOrderByWithAggregationInput = {
    id?: SortOrder
    placeId?: SortOrderInput | SortOrder
    reviewId?: SortOrderInput | SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: ReportUrbanExplorerCountOrderByAggregateInput
    _max?: ReportUrbanExplorerMaxOrderByAggregateInput
    _min?: ReportUrbanExplorerMinOrderByAggregateInput
  }

  export type ReportUrbanExplorerScalarWhereWithAggregatesInput = {
    AND?: ReportUrbanExplorerScalarWhereWithAggregatesInput | ReportUrbanExplorerScalarWhereWithAggregatesInput[]
    OR?: ReportUrbanExplorerScalarWhereWithAggregatesInput[]
    NOT?: ReportUrbanExplorerScalarWhereWithAggregatesInput | ReportUrbanExplorerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportUrbanExplorer"> | string
    placeId?: StringNullableWithAggregatesFilter<"ReportUrbanExplorer"> | string | null
    reviewId?: StringNullableWithAggregatesFilter<"ReportUrbanExplorer"> | string | null
    userId?: StringWithAggregatesFilter<"ReportUrbanExplorer"> | string
    reason?: StringWithAggregatesFilter<"ReportUrbanExplorer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportUrbanExplorer"> | Date | string
  }

  export type UserFoodieWhereInput = {
    AND?: UserFoodieWhereInput | UserFoodieWhereInput[]
    OR?: UserFoodieWhereInput[]
    NOT?: UserFoodieWhereInput | UserFoodieWhereInput[]
    id?: StringFilter<"UserFoodie"> | string
    email?: StringFilter<"UserFoodie"> | string
    name?: StringFilter<"UserFoodie"> | string
    password?: StringFilter<"UserFoodie"> | string
    createdAt?: DateTimeFilter<"UserFoodie"> | Date | string
    FoodieFood?: FoodieFoodListRelationFilter
    FoodieLocation?: FoodieLocationListRelationFilter
    FoodieReview?: FoodieReviewListRelationFilter
    FoodieLike?: FoodieLikeListRelationFilter
  }

  export type UserFoodieOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    FoodieFood?: FoodieFoodOrderByRelationAggregateInput
    FoodieLocation?: FoodieLocationOrderByRelationAggregateInput
    FoodieReview?: FoodieReviewOrderByRelationAggregateInput
    FoodieLike?: FoodieLikeOrderByRelationAggregateInput
  }

  export type UserFoodieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserFoodieWhereInput | UserFoodieWhereInput[]
    OR?: UserFoodieWhereInput[]
    NOT?: UserFoodieWhereInput | UserFoodieWhereInput[]
    name?: StringFilter<"UserFoodie"> | string
    password?: StringFilter<"UserFoodie"> | string
    createdAt?: DateTimeFilter<"UserFoodie"> | Date | string
    FoodieFood?: FoodieFoodListRelationFilter
    FoodieLocation?: FoodieLocationListRelationFilter
    FoodieReview?: FoodieReviewListRelationFilter
    FoodieLike?: FoodieLikeListRelationFilter
  }, "id" | "email">

  export type UserFoodieOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserFoodieCountOrderByAggregateInput
    _max?: UserFoodieMaxOrderByAggregateInput
    _min?: UserFoodieMinOrderByAggregateInput
  }

  export type UserFoodieScalarWhereWithAggregatesInput = {
    AND?: UserFoodieScalarWhereWithAggregatesInput | UserFoodieScalarWhereWithAggregatesInput[]
    OR?: UserFoodieScalarWhereWithAggregatesInput[]
    NOT?: UserFoodieScalarWhereWithAggregatesInput | UserFoodieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFoodie"> | string
    email?: StringWithAggregatesFilter<"UserFoodie"> | string
    name?: StringWithAggregatesFilter<"UserFoodie"> | string
    password?: StringWithAggregatesFilter<"UserFoodie"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFoodie"> | Date | string
  }

  export type FoodieFoodWhereInput = {
    AND?: FoodieFoodWhereInput | FoodieFoodWhereInput[]
    OR?: FoodieFoodWhereInput[]
    NOT?: FoodieFoodWhereInput | FoodieFoodWhereInput[]
    id?: StringFilter<"FoodieFood"> | string
    name?: StringFilter<"FoodieFood"> | string
    cuisine?: StringFilter<"FoodieFood"> | string
    origin?: StringFilter<"FoodieFood"> | string
    description?: StringFilter<"FoodieFood"> | string
    submittedBy?: StringFilter<"FoodieFood"> | string
    validated?: BoolFilter<"FoodieFood"> | boolean
    createdAt?: DateTimeFilter<"FoodieFood"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    locations?: FoodieLocationListRelationFilter
    reviews?: FoodieReviewListRelationFilter
    likes?: FoodieLikeListRelationFilter
  }

  export type FoodieFoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cuisine?: SortOrder
    origin?: SortOrder
    description?: SortOrder
    submittedBy?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    user?: UserFoodieOrderByWithRelationInput
    locations?: FoodieLocationOrderByRelationAggregateInput
    reviews?: FoodieReviewOrderByRelationAggregateInput
    likes?: FoodieLikeOrderByRelationAggregateInput
  }

  export type FoodieFoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FoodieFoodWhereInput | FoodieFoodWhereInput[]
    OR?: FoodieFoodWhereInput[]
    NOT?: FoodieFoodWhereInput | FoodieFoodWhereInput[]
    name?: StringFilter<"FoodieFood"> | string
    cuisine?: StringFilter<"FoodieFood"> | string
    origin?: StringFilter<"FoodieFood"> | string
    description?: StringFilter<"FoodieFood"> | string
    submittedBy?: StringFilter<"FoodieFood"> | string
    validated?: BoolFilter<"FoodieFood"> | boolean
    createdAt?: DateTimeFilter<"FoodieFood"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    locations?: FoodieLocationListRelationFilter
    reviews?: FoodieReviewListRelationFilter
    likes?: FoodieLikeListRelationFilter
  }, "id">

  export type FoodieFoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cuisine?: SortOrder
    origin?: SortOrder
    description?: SortOrder
    submittedBy?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    _count?: FoodieFoodCountOrderByAggregateInput
    _max?: FoodieFoodMaxOrderByAggregateInput
    _min?: FoodieFoodMinOrderByAggregateInput
  }

  export type FoodieFoodScalarWhereWithAggregatesInput = {
    AND?: FoodieFoodScalarWhereWithAggregatesInput | FoodieFoodScalarWhereWithAggregatesInput[]
    OR?: FoodieFoodScalarWhereWithAggregatesInput[]
    NOT?: FoodieFoodScalarWhereWithAggregatesInput | FoodieFoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodieFood"> | string
    name?: StringWithAggregatesFilter<"FoodieFood"> | string
    cuisine?: StringWithAggregatesFilter<"FoodieFood"> | string
    origin?: StringWithAggregatesFilter<"FoodieFood"> | string
    description?: StringWithAggregatesFilter<"FoodieFood"> | string
    submittedBy?: StringWithAggregatesFilter<"FoodieFood"> | string
    validated?: BoolWithAggregatesFilter<"FoodieFood"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FoodieFood"> | Date | string
  }

  export type FoodieLocationWhereInput = {
    AND?: FoodieLocationWhereInput | FoodieLocationWhereInput[]
    OR?: FoodieLocationWhereInput[]
    NOT?: FoodieLocationWhereInput | FoodieLocationWhereInput[]
    id?: StringFilter<"FoodieLocation"> | string
    foodId?: StringFilter<"FoodieLocation"> | string
    locationName?: StringFilter<"FoodieLocation"> | string
    address?: StringFilter<"FoodieLocation"> | string
    submittedBy?: StringFilter<"FoodieLocation"> | string
    createdAt?: DateTimeFilter<"FoodieLocation"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    food?: XOR<FoodieFoodScalarRelationFilter, FoodieFoodWhereInput>
  }

  export type FoodieLocationOrderByWithRelationInput = {
    id?: SortOrder
    foodId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    user?: UserFoodieOrderByWithRelationInput
    food?: FoodieFoodOrderByWithRelationInput
  }

  export type FoodieLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FoodieLocationWhereInput | FoodieLocationWhereInput[]
    OR?: FoodieLocationWhereInput[]
    NOT?: FoodieLocationWhereInput | FoodieLocationWhereInput[]
    foodId?: StringFilter<"FoodieLocation"> | string
    locationName?: StringFilter<"FoodieLocation"> | string
    address?: StringFilter<"FoodieLocation"> | string
    submittedBy?: StringFilter<"FoodieLocation"> | string
    createdAt?: DateTimeFilter<"FoodieLocation"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    food?: XOR<FoodieFoodScalarRelationFilter, FoodieFoodWhereInput>
  }, "id">

  export type FoodieLocationOrderByWithAggregationInput = {
    id?: SortOrder
    foodId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    _count?: FoodieLocationCountOrderByAggregateInput
    _max?: FoodieLocationMaxOrderByAggregateInput
    _min?: FoodieLocationMinOrderByAggregateInput
  }

  export type FoodieLocationScalarWhereWithAggregatesInput = {
    AND?: FoodieLocationScalarWhereWithAggregatesInput | FoodieLocationScalarWhereWithAggregatesInput[]
    OR?: FoodieLocationScalarWhereWithAggregatesInput[]
    NOT?: FoodieLocationScalarWhereWithAggregatesInput | FoodieLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodieLocation"> | string
    foodId?: StringWithAggregatesFilter<"FoodieLocation"> | string
    locationName?: StringWithAggregatesFilter<"FoodieLocation"> | string
    address?: StringWithAggregatesFilter<"FoodieLocation"> | string
    submittedBy?: StringWithAggregatesFilter<"FoodieLocation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FoodieLocation"> | Date | string
  }

  export type FoodieReviewWhereInput = {
    AND?: FoodieReviewWhereInput | FoodieReviewWhereInput[]
    OR?: FoodieReviewWhereInput[]
    NOT?: FoodieReviewWhereInput | FoodieReviewWhereInput[]
    id?: StringFilter<"FoodieReview"> | string
    foodId?: StringFilter<"FoodieReview"> | string
    userId?: StringFilter<"FoodieReview"> | string
    rating?: IntFilter<"FoodieReview"> | number
    comment?: StringFilter<"FoodieReview"> | string
    validated?: BoolFilter<"FoodieReview"> | boolean
    createdAt?: DateTimeFilter<"FoodieReview"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    food?: XOR<FoodieFoodScalarRelationFilter, FoodieFoodWhereInput>
  }

  export type FoodieReviewOrderByWithRelationInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    user?: UserFoodieOrderByWithRelationInput
    food?: FoodieFoodOrderByWithRelationInput
  }

  export type FoodieReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FoodieReviewWhereInput | FoodieReviewWhereInput[]
    OR?: FoodieReviewWhereInput[]
    NOT?: FoodieReviewWhereInput | FoodieReviewWhereInput[]
    foodId?: StringFilter<"FoodieReview"> | string
    userId?: StringFilter<"FoodieReview"> | string
    rating?: IntFilter<"FoodieReview"> | number
    comment?: StringFilter<"FoodieReview"> | string
    validated?: BoolFilter<"FoodieReview"> | boolean
    createdAt?: DateTimeFilter<"FoodieReview"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    food?: XOR<FoodieFoodScalarRelationFilter, FoodieFoodWhereInput>
  }, "id">

  export type FoodieReviewOrderByWithAggregationInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    _count?: FoodieReviewCountOrderByAggregateInput
    _avg?: FoodieReviewAvgOrderByAggregateInput
    _max?: FoodieReviewMaxOrderByAggregateInput
    _min?: FoodieReviewMinOrderByAggregateInput
    _sum?: FoodieReviewSumOrderByAggregateInput
  }

  export type FoodieReviewScalarWhereWithAggregatesInput = {
    AND?: FoodieReviewScalarWhereWithAggregatesInput | FoodieReviewScalarWhereWithAggregatesInput[]
    OR?: FoodieReviewScalarWhereWithAggregatesInput[]
    NOT?: FoodieReviewScalarWhereWithAggregatesInput | FoodieReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodieReview"> | string
    foodId?: StringWithAggregatesFilter<"FoodieReview"> | string
    userId?: StringWithAggregatesFilter<"FoodieReview"> | string
    rating?: IntWithAggregatesFilter<"FoodieReview"> | number
    comment?: StringWithAggregatesFilter<"FoodieReview"> | string
    validated?: BoolWithAggregatesFilter<"FoodieReview"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FoodieReview"> | Date | string
  }

  export type FoodieLikeWhereInput = {
    AND?: FoodieLikeWhereInput | FoodieLikeWhereInput[]
    OR?: FoodieLikeWhereInput[]
    NOT?: FoodieLikeWhereInput | FoodieLikeWhereInput[]
    id?: StringFilter<"FoodieLike"> | string
    foodId?: StringFilter<"FoodieLike"> | string
    userId?: StringFilter<"FoodieLike"> | string
    createdAt?: DateTimeFilter<"FoodieLike"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    food?: XOR<FoodieFoodScalarRelationFilter, FoodieFoodWhereInput>
  }

  export type FoodieLikeOrderByWithRelationInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserFoodieOrderByWithRelationInput
    food?: FoodieFoodOrderByWithRelationInput
  }

  export type FoodieLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    foodId_userId?: FoodieLikeFoodIdUserIdCompoundUniqueInput
    AND?: FoodieLikeWhereInput | FoodieLikeWhereInput[]
    OR?: FoodieLikeWhereInput[]
    NOT?: FoodieLikeWhereInput | FoodieLikeWhereInput[]
    foodId?: StringFilter<"FoodieLike"> | string
    userId?: StringFilter<"FoodieLike"> | string
    createdAt?: DateTimeFilter<"FoodieLike"> | Date | string
    user?: XOR<UserFoodieScalarRelationFilter, UserFoodieWhereInput>
    food?: XOR<FoodieFoodScalarRelationFilter, FoodieFoodWhereInput>
  }, "id" | "foodId_userId">

  export type FoodieLikeOrderByWithAggregationInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: FoodieLikeCountOrderByAggregateInput
    _max?: FoodieLikeMaxOrderByAggregateInput
    _min?: FoodieLikeMinOrderByAggregateInput
  }

  export type FoodieLikeScalarWhereWithAggregatesInput = {
    AND?: FoodieLikeScalarWhereWithAggregatesInput | FoodieLikeScalarWhereWithAggregatesInput[]
    OR?: FoodieLikeScalarWhereWithAggregatesInput[]
    NOT?: FoodieLikeScalarWhereWithAggregatesInput | FoodieLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FoodieLike"> | string
    foodId?: StringWithAggregatesFilter<"FoodieLike"> | string
    userId?: StringWithAggregatesFilter<"FoodieLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FoodieLike"> | Date | string
  }

  export type UserPetLoverWhereInput = {
    AND?: UserPetLoverWhereInput | UserPetLoverWhereInput[]
    OR?: UserPetLoverWhereInput[]
    NOT?: UserPetLoverWhereInput | UserPetLoverWhereInput[]
    id?: StringFilter<"UserPetLover"> | string
    email?: StringFilter<"UserPetLover"> | string
    name?: StringFilter<"UserPetLover"> | string
    password?: StringFilter<"UserPetLover"> | string
    createdAt?: DateTimeFilter<"UserPetLover"> | Date | string
    PetPetLover?: PetPetLoverListRelationFilter
    AppointmentPetLover?: AppointmentPetLoverListRelationFilter
  }

  export type UserPetLoverOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    PetPetLover?: PetPetLoverOrderByRelationAggregateInput
    AppointmentPetLover?: AppointmentPetLoverOrderByRelationAggregateInput
  }

  export type UserPetLoverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserPetLoverWhereInput | UserPetLoverWhereInput[]
    OR?: UserPetLoverWhereInput[]
    NOT?: UserPetLoverWhereInput | UserPetLoverWhereInput[]
    name?: StringFilter<"UserPetLover"> | string
    password?: StringFilter<"UserPetLover"> | string
    createdAt?: DateTimeFilter<"UserPetLover"> | Date | string
    PetPetLover?: PetPetLoverListRelationFilter
    AppointmentPetLover?: AppointmentPetLoverListRelationFilter
  }, "id" | "email">

  export type UserPetLoverOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserPetLoverCountOrderByAggregateInput
    _max?: UserPetLoverMaxOrderByAggregateInput
    _min?: UserPetLoverMinOrderByAggregateInput
  }

  export type UserPetLoverScalarWhereWithAggregatesInput = {
    AND?: UserPetLoverScalarWhereWithAggregatesInput | UserPetLoverScalarWhereWithAggregatesInput[]
    OR?: UserPetLoverScalarWhereWithAggregatesInput[]
    NOT?: UserPetLoverScalarWhereWithAggregatesInput | UserPetLoverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPetLover"> | string
    email?: StringWithAggregatesFilter<"UserPetLover"> | string
    name?: StringWithAggregatesFilter<"UserPetLover"> | string
    password?: StringWithAggregatesFilter<"UserPetLover"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserPetLover"> | Date | string
  }

  export type PetPetLoverWhereInput = {
    AND?: PetPetLoverWhereInput | PetPetLoverWhereInput[]
    OR?: PetPetLoverWhereInput[]
    NOT?: PetPetLoverWhereInput | PetPetLoverWhereInput[]
    id?: StringFilter<"PetPetLover"> | string
    userId?: StringFilter<"PetPetLover"> | string
    petName?: StringFilter<"PetPetLover"> | string
    species?: StringFilter<"PetPetLover"> | string
    breed?: StringFilter<"PetPetLover"> | string
    age?: IntFilter<"PetPetLover"> | number
    medicalHistory?: StringNullableFilter<"PetPetLover"> | string | null
    createdAt?: DateTimeFilter<"PetPetLover"> | Date | string
    user?: XOR<UserPetLoverScalarRelationFilter, UserPetLoverWhereInput>
    vaccinations?: VaccinationPetLoverListRelationFilter
    appointments?: AppointmentPetLoverListRelationFilter
  }

  export type PetPetLoverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    petName?: SortOrder
    species?: SortOrder
    breed?: SortOrder
    age?: SortOrder
    medicalHistory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserPetLoverOrderByWithRelationInput
    vaccinations?: VaccinationPetLoverOrderByRelationAggregateInput
    appointments?: AppointmentPetLoverOrderByRelationAggregateInput
  }

  export type PetPetLoverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PetPetLoverWhereInput | PetPetLoverWhereInput[]
    OR?: PetPetLoverWhereInput[]
    NOT?: PetPetLoverWhereInput | PetPetLoverWhereInput[]
    userId?: StringFilter<"PetPetLover"> | string
    petName?: StringFilter<"PetPetLover"> | string
    species?: StringFilter<"PetPetLover"> | string
    breed?: StringFilter<"PetPetLover"> | string
    age?: IntFilter<"PetPetLover"> | number
    medicalHistory?: StringNullableFilter<"PetPetLover"> | string | null
    createdAt?: DateTimeFilter<"PetPetLover"> | Date | string
    user?: XOR<UserPetLoverScalarRelationFilter, UserPetLoverWhereInput>
    vaccinations?: VaccinationPetLoverListRelationFilter
    appointments?: AppointmentPetLoverListRelationFilter
  }, "id">

  export type PetPetLoverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    petName?: SortOrder
    species?: SortOrder
    breed?: SortOrder
    age?: SortOrder
    medicalHistory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PetPetLoverCountOrderByAggregateInput
    _avg?: PetPetLoverAvgOrderByAggregateInput
    _max?: PetPetLoverMaxOrderByAggregateInput
    _min?: PetPetLoverMinOrderByAggregateInput
    _sum?: PetPetLoverSumOrderByAggregateInput
  }

  export type PetPetLoverScalarWhereWithAggregatesInput = {
    AND?: PetPetLoverScalarWhereWithAggregatesInput | PetPetLoverScalarWhereWithAggregatesInput[]
    OR?: PetPetLoverScalarWhereWithAggregatesInput[]
    NOT?: PetPetLoverScalarWhereWithAggregatesInput | PetPetLoverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PetPetLover"> | string
    userId?: StringWithAggregatesFilter<"PetPetLover"> | string
    petName?: StringWithAggregatesFilter<"PetPetLover"> | string
    species?: StringWithAggregatesFilter<"PetPetLover"> | string
    breed?: StringWithAggregatesFilter<"PetPetLover"> | string
    age?: IntWithAggregatesFilter<"PetPetLover"> | number
    medicalHistory?: StringNullableWithAggregatesFilter<"PetPetLover"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PetPetLover"> | Date | string
  }

  export type AppointmentPetLoverWhereInput = {
    AND?: AppointmentPetLoverWhereInput | AppointmentPetLoverWhereInput[]
    OR?: AppointmentPetLoverWhereInput[]
    NOT?: AppointmentPetLoverWhereInput | AppointmentPetLoverWhereInput[]
    id?: StringFilter<"AppointmentPetLover"> | string
    userId?: StringFilter<"AppointmentPetLover"> | string
    petId?: StringFilter<"AppointmentPetLover"> | string
    appointmentType?: StringFilter<"AppointmentPetLover"> | string
    dateTime?: DateTimeFilter<"AppointmentPetLover"> | Date | string
    location?: StringFilter<"AppointmentPetLover"> | string
    createdAt?: DateTimeFilter<"AppointmentPetLover"> | Date | string
    user?: XOR<UserPetLoverScalarRelationFilter, UserPetLoverWhereInput>
    pet?: XOR<PetPetLoverScalarRelationFilter, PetPetLoverWhereInput>
  }

  export type AppointmentPetLoverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    appointmentType?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    user?: UserPetLoverOrderByWithRelationInput
    pet?: PetPetLoverOrderByWithRelationInput
  }

  export type AppointmentPetLoverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentPetLoverWhereInput | AppointmentPetLoverWhereInput[]
    OR?: AppointmentPetLoverWhereInput[]
    NOT?: AppointmentPetLoverWhereInput | AppointmentPetLoverWhereInput[]
    userId?: StringFilter<"AppointmentPetLover"> | string
    petId?: StringFilter<"AppointmentPetLover"> | string
    appointmentType?: StringFilter<"AppointmentPetLover"> | string
    dateTime?: DateTimeFilter<"AppointmentPetLover"> | Date | string
    location?: StringFilter<"AppointmentPetLover"> | string
    createdAt?: DateTimeFilter<"AppointmentPetLover"> | Date | string
    user?: XOR<UserPetLoverScalarRelationFilter, UserPetLoverWhereInput>
    pet?: XOR<PetPetLoverScalarRelationFilter, PetPetLoverWhereInput>
  }, "id">

  export type AppointmentPetLoverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    appointmentType?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    _count?: AppointmentPetLoverCountOrderByAggregateInput
    _max?: AppointmentPetLoverMaxOrderByAggregateInput
    _min?: AppointmentPetLoverMinOrderByAggregateInput
  }

  export type AppointmentPetLoverScalarWhereWithAggregatesInput = {
    AND?: AppointmentPetLoverScalarWhereWithAggregatesInput | AppointmentPetLoverScalarWhereWithAggregatesInput[]
    OR?: AppointmentPetLoverScalarWhereWithAggregatesInput[]
    NOT?: AppointmentPetLoverScalarWhereWithAggregatesInput | AppointmentPetLoverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppointmentPetLover"> | string
    userId?: StringWithAggregatesFilter<"AppointmentPetLover"> | string
    petId?: StringWithAggregatesFilter<"AppointmentPetLover"> | string
    appointmentType?: StringWithAggregatesFilter<"AppointmentPetLover"> | string
    dateTime?: DateTimeWithAggregatesFilter<"AppointmentPetLover"> | Date | string
    location?: StringWithAggregatesFilter<"AppointmentPetLover"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AppointmentPetLover"> | Date | string
  }

  export type VaccinationPetLoverWhereInput = {
    AND?: VaccinationPetLoverWhereInput | VaccinationPetLoverWhereInput[]
    OR?: VaccinationPetLoverWhereInput[]
    NOT?: VaccinationPetLoverWhereInput | VaccinationPetLoverWhereInput[]
    id?: StringFilter<"VaccinationPetLover"> | string
    petId?: StringFilter<"VaccinationPetLover"> | string
    vaccineName?: StringFilter<"VaccinationPetLover"> | string
    dateAdministered?: DateTimeFilter<"VaccinationPetLover"> | Date | string
    nextDueDate?: DateTimeNullableFilter<"VaccinationPetLover"> | Date | string | null
    createdAt?: DateTimeFilter<"VaccinationPetLover"> | Date | string
    pet?: XOR<PetPetLoverScalarRelationFilter, PetPetLoverWhereInput>
  }

  export type VaccinationPetLoverOrderByWithRelationInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineName?: SortOrder
    dateAdministered?: SortOrder
    nextDueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    pet?: PetPetLoverOrderByWithRelationInput
  }

  export type VaccinationPetLoverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccinationPetLoverWhereInput | VaccinationPetLoverWhereInput[]
    OR?: VaccinationPetLoverWhereInput[]
    NOT?: VaccinationPetLoverWhereInput | VaccinationPetLoverWhereInput[]
    petId?: StringFilter<"VaccinationPetLover"> | string
    vaccineName?: StringFilter<"VaccinationPetLover"> | string
    dateAdministered?: DateTimeFilter<"VaccinationPetLover"> | Date | string
    nextDueDate?: DateTimeNullableFilter<"VaccinationPetLover"> | Date | string | null
    createdAt?: DateTimeFilter<"VaccinationPetLover"> | Date | string
    pet?: XOR<PetPetLoverScalarRelationFilter, PetPetLoverWhereInput>
  }, "id">

  export type VaccinationPetLoverOrderByWithAggregationInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineName?: SortOrder
    dateAdministered?: SortOrder
    nextDueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VaccinationPetLoverCountOrderByAggregateInput
    _max?: VaccinationPetLoverMaxOrderByAggregateInput
    _min?: VaccinationPetLoverMinOrderByAggregateInput
  }

  export type VaccinationPetLoverScalarWhereWithAggregatesInput = {
    AND?: VaccinationPetLoverScalarWhereWithAggregatesInput | VaccinationPetLoverScalarWhereWithAggregatesInput[]
    OR?: VaccinationPetLoverScalarWhereWithAggregatesInput[]
    NOT?: VaccinationPetLoverScalarWhereWithAggregatesInput | VaccinationPetLoverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VaccinationPetLover"> | string
    petId?: StringWithAggregatesFilter<"VaccinationPetLover"> | string
    vaccineName?: StringWithAggregatesFilter<"VaccinationPetLover"> | string
    dateAdministered?: DateTimeWithAggregatesFilter<"VaccinationPetLover"> | Date | string
    nextDueDate?: DateTimeNullableWithAggregatesFilter<"VaccinationPetLover"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VaccinationPetLover"> | Date | string
  }

  export type ClinicPetLoverWhereInput = {
    AND?: ClinicPetLoverWhereInput | ClinicPetLoverWhereInput[]
    OR?: ClinicPetLoverWhereInput[]
    NOT?: ClinicPetLoverWhereInput | ClinicPetLoverWhereInput[]
    id?: StringFilter<"ClinicPetLover"> | string
    name?: StringFilter<"ClinicPetLover"> | string
    address?: StringFilter<"ClinicPetLover"> | string
    phone?: StringFilter<"ClinicPetLover"> | string
    createdAt?: DateTimeFilter<"ClinicPetLover"> | Date | string
  }

  export type ClinicPetLoverOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ClinicPetLoverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicPetLoverWhereInput | ClinicPetLoverWhereInput[]
    OR?: ClinicPetLoverWhereInput[]
    NOT?: ClinicPetLoverWhereInput | ClinicPetLoverWhereInput[]
    name?: StringFilter<"ClinicPetLover"> | string
    address?: StringFilter<"ClinicPetLover"> | string
    phone?: StringFilter<"ClinicPetLover"> | string
    createdAt?: DateTimeFilter<"ClinicPetLover"> | Date | string
  }, "id">

  export type ClinicPetLoverOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    _count?: ClinicPetLoverCountOrderByAggregateInput
    _max?: ClinicPetLoverMaxOrderByAggregateInput
    _min?: ClinicPetLoverMinOrderByAggregateInput
  }

  export type ClinicPetLoverScalarWhereWithAggregatesInput = {
    AND?: ClinicPetLoverScalarWhereWithAggregatesInput | ClinicPetLoverScalarWhereWithAggregatesInput[]
    OR?: ClinicPetLoverScalarWhereWithAggregatesInput[]
    NOT?: ClinicPetLoverScalarWhereWithAggregatesInput | ClinicPetLoverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicPetLover"> | string
    name?: StringWithAggregatesFilter<"ClinicPetLover"> | string
    address?: StringWithAggregatesFilter<"ClinicPetLover"> | string
    phone?: StringWithAggregatesFilter<"ClinicPetLover"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClinicPetLover"> | Date | string
  }

  export type StorePetLoverWhereInput = {
    AND?: StorePetLoverWhereInput | StorePetLoverWhereInput[]
    OR?: StorePetLoverWhereInput[]
    NOT?: StorePetLoverWhereInput | StorePetLoverWhereInput[]
    id?: StringFilter<"StorePetLover"> | string
    name?: StringFilter<"StorePetLover"> | string
    address?: StringFilter<"StorePetLover"> | string
    phone?: StringFilter<"StorePetLover"> | string
    createdAt?: DateTimeFilter<"StorePetLover"> | Date | string
  }

  export type StorePetLoverOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type StorePetLoverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorePetLoverWhereInput | StorePetLoverWhereInput[]
    OR?: StorePetLoverWhereInput[]
    NOT?: StorePetLoverWhereInput | StorePetLoverWhereInput[]
    name?: StringFilter<"StorePetLover"> | string
    address?: StringFilter<"StorePetLover"> | string
    phone?: StringFilter<"StorePetLover"> | string
    createdAt?: DateTimeFilter<"StorePetLover"> | Date | string
  }, "id">

  export type StorePetLoverOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    _count?: StorePetLoverCountOrderByAggregateInput
    _max?: StorePetLoverMaxOrderByAggregateInput
    _min?: StorePetLoverMinOrderByAggregateInput
  }

  export type StorePetLoverScalarWhereWithAggregatesInput = {
    AND?: StorePetLoverScalarWhereWithAggregatesInput | StorePetLoverScalarWhereWithAggregatesInput[]
    OR?: StorePetLoverScalarWhereWithAggregatesInput[]
    NOT?: StorePetLoverScalarWhereWithAggregatesInput | StorePetLoverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorePetLover"> | string
    name?: StringWithAggregatesFilter<"StorePetLover"> | string
    address?: StringWithAggregatesFilter<"StorePetLover"> | string
    phone?: StringWithAggregatesFilter<"StorePetLover"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StorePetLover"> | Date | string
  }

  export type UserElderlyCareCompanionWhereInput = {
    AND?: UserElderlyCareCompanionWhereInput | UserElderlyCareCompanionWhereInput[]
    OR?: UserElderlyCareCompanionWhereInput[]
    NOT?: UserElderlyCareCompanionWhereInput | UserElderlyCareCompanionWhereInput[]
    id?: StringFilter<"UserElderlyCareCompanion"> | string
    email?: StringFilter<"UserElderlyCareCompanion"> | string
    name?: StringFilter<"UserElderlyCareCompanion"> | string
    password?: StringFilter<"UserElderlyCareCompanion"> | string
    createdAt?: DateTimeFilter<"UserElderlyCareCompanion"> | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentListRelationFilter
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordListRelationFilter
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingListRelationFilter
  }

  export type UserElderlyCareCompanionOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentOrderByRelationAggregateInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordOrderByRelationAggregateInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingOrderByRelationAggregateInput
  }

  export type UserElderlyCareCompanionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserElderlyCareCompanionWhereInput | UserElderlyCareCompanionWhereInput[]
    OR?: UserElderlyCareCompanionWhereInput[]
    NOT?: UserElderlyCareCompanionWhereInput | UserElderlyCareCompanionWhereInput[]
    name?: StringFilter<"UserElderlyCareCompanion"> | string
    password?: StringFilter<"UserElderlyCareCompanion"> | string
    createdAt?: DateTimeFilter<"UserElderlyCareCompanion"> | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentListRelationFilter
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordListRelationFilter
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingListRelationFilter
  }, "id" | "email">

  export type UserElderlyCareCompanionOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserElderlyCareCompanionCountOrderByAggregateInput
    _max?: UserElderlyCareCompanionMaxOrderByAggregateInput
    _min?: UserElderlyCareCompanionMinOrderByAggregateInput
  }

  export type UserElderlyCareCompanionScalarWhereWithAggregatesInput = {
    AND?: UserElderlyCareCompanionScalarWhereWithAggregatesInput | UserElderlyCareCompanionScalarWhereWithAggregatesInput[]
    OR?: UserElderlyCareCompanionScalarWhereWithAggregatesInput[]
    NOT?: UserElderlyCareCompanionScalarWhereWithAggregatesInput | UserElderlyCareCompanionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserElderlyCareCompanion"> | string
    email?: StringWithAggregatesFilter<"UserElderlyCareCompanion"> | string
    name?: StringWithAggregatesFilter<"UserElderlyCareCompanion"> | string
    password?: StringWithAggregatesFilter<"UserElderlyCareCompanion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserElderlyCareCompanion"> | Date | string
  }

  export type ElderlyCareCompanionAppointmentWhereInput = {
    AND?: ElderlyCareCompanionAppointmentWhereInput | ElderlyCareCompanionAppointmentWhereInput[]
    OR?: ElderlyCareCompanionAppointmentWhereInput[]
    NOT?: ElderlyCareCompanionAppointmentWhereInput | ElderlyCareCompanionAppointmentWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    userId?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    type?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    title?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    dateTime?: DateTimeFilter<"ElderlyCareCompanionAppointment"> | Date | string
    location?: StringNullableFilter<"ElderlyCareCompanionAppointment"> | string | null
    medicationDetails?: StringNullableFilter<"ElderlyCareCompanionAppointment"> | string | null
    createdAt?: DateTimeFilter<"ElderlyCareCompanionAppointment"> | Date | string
    user?: XOR<UserElderlyCareCompanionScalarRelationFilter, UserElderlyCareCompanionWhereInput>
    medicationLogs?: ElderlyCareCompanionMedicationTrackingListRelationFilter
  }

  export type ElderlyCareCompanionAppointmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    dateTime?: SortOrder
    location?: SortOrderInput | SortOrder
    medicationDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserElderlyCareCompanionOrderByWithRelationInput
    medicationLogs?: ElderlyCareCompanionMedicationTrackingOrderByRelationAggregateInput
  }

  export type ElderlyCareCompanionAppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElderlyCareCompanionAppointmentWhereInput | ElderlyCareCompanionAppointmentWhereInput[]
    OR?: ElderlyCareCompanionAppointmentWhereInput[]
    NOT?: ElderlyCareCompanionAppointmentWhereInput | ElderlyCareCompanionAppointmentWhereInput[]
    userId?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    type?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    title?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    dateTime?: DateTimeFilter<"ElderlyCareCompanionAppointment"> | Date | string
    location?: StringNullableFilter<"ElderlyCareCompanionAppointment"> | string | null
    medicationDetails?: StringNullableFilter<"ElderlyCareCompanionAppointment"> | string | null
    createdAt?: DateTimeFilter<"ElderlyCareCompanionAppointment"> | Date | string
    user?: XOR<UserElderlyCareCompanionScalarRelationFilter, UserElderlyCareCompanionWhereInput>
    medicationLogs?: ElderlyCareCompanionMedicationTrackingListRelationFilter
  }, "id">

  export type ElderlyCareCompanionAppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    dateTime?: SortOrder
    location?: SortOrderInput | SortOrder
    medicationDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ElderlyCareCompanionAppointmentCountOrderByAggregateInput
    _max?: ElderlyCareCompanionAppointmentMaxOrderByAggregateInput
    _min?: ElderlyCareCompanionAppointmentMinOrderByAggregateInput
  }

  export type ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput = {
    AND?: ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput | ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput[]
    OR?: ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput[]
    NOT?: ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput | ElderlyCareCompanionAppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | string
    userId?: StringWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | string
    type?: StringWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | string
    title?: StringWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | string
    dateTime?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | Date | string
    location?: StringNullableWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | string | null
    medicationDetails?: StringNullableWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionAppointment"> | Date | string
  }

  export type ElderlyCareCompanionClinicWhereInput = {
    AND?: ElderlyCareCompanionClinicWhereInput | ElderlyCareCompanionClinicWhereInput[]
    OR?: ElderlyCareCompanionClinicWhereInput[]
    NOT?: ElderlyCareCompanionClinicWhereInput | ElderlyCareCompanionClinicWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionClinic"> | string
    name?: StringFilter<"ElderlyCareCompanionClinic"> | string
    address?: StringFilter<"ElderlyCareCompanionClinic"> | string
    phone?: StringFilter<"ElderlyCareCompanionClinic"> | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionClinic"> | Date | string
  }

  export type ElderlyCareCompanionClinicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElderlyCareCompanionClinicWhereInput | ElderlyCareCompanionClinicWhereInput[]
    OR?: ElderlyCareCompanionClinicWhereInput[]
    NOT?: ElderlyCareCompanionClinicWhereInput | ElderlyCareCompanionClinicWhereInput[]
    name?: StringFilter<"ElderlyCareCompanionClinic"> | string
    address?: StringFilter<"ElderlyCareCompanionClinic"> | string
    phone?: StringFilter<"ElderlyCareCompanionClinic"> | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionClinic"> | Date | string
  }, "id">

  export type ElderlyCareCompanionClinicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    _count?: ElderlyCareCompanionClinicCountOrderByAggregateInput
    _max?: ElderlyCareCompanionClinicMaxOrderByAggregateInput
    _min?: ElderlyCareCompanionClinicMinOrderByAggregateInput
  }

  export type ElderlyCareCompanionClinicScalarWhereWithAggregatesInput = {
    AND?: ElderlyCareCompanionClinicScalarWhereWithAggregatesInput | ElderlyCareCompanionClinicScalarWhereWithAggregatesInput[]
    OR?: ElderlyCareCompanionClinicScalarWhereWithAggregatesInput[]
    NOT?: ElderlyCareCompanionClinicScalarWhereWithAggregatesInput | ElderlyCareCompanionClinicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ElderlyCareCompanionClinic"> | string
    name?: StringWithAggregatesFilter<"ElderlyCareCompanionClinic"> | string
    address?: StringWithAggregatesFilter<"ElderlyCareCompanionClinic"> | string
    phone?: StringWithAggregatesFilter<"ElderlyCareCompanionClinic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionClinic"> | Date | string
  }

  export type ElderlyCareCompanionStoreWhereInput = {
    AND?: ElderlyCareCompanionStoreWhereInput | ElderlyCareCompanionStoreWhereInput[]
    OR?: ElderlyCareCompanionStoreWhereInput[]
    NOT?: ElderlyCareCompanionStoreWhereInput | ElderlyCareCompanionStoreWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionStore"> | string
    name?: StringFilter<"ElderlyCareCompanionStore"> | string
    address?: StringFilter<"ElderlyCareCompanionStore"> | string
    phone?: StringFilter<"ElderlyCareCompanionStore"> | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionStore"> | Date | string
  }

  export type ElderlyCareCompanionStoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionStoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElderlyCareCompanionStoreWhereInput | ElderlyCareCompanionStoreWhereInput[]
    OR?: ElderlyCareCompanionStoreWhereInput[]
    NOT?: ElderlyCareCompanionStoreWhereInput | ElderlyCareCompanionStoreWhereInput[]
    name?: StringFilter<"ElderlyCareCompanionStore"> | string
    address?: StringFilter<"ElderlyCareCompanionStore"> | string
    phone?: StringFilter<"ElderlyCareCompanionStore"> | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionStore"> | Date | string
  }, "id">

  export type ElderlyCareCompanionStoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    _count?: ElderlyCareCompanionStoreCountOrderByAggregateInput
    _max?: ElderlyCareCompanionStoreMaxOrderByAggregateInput
    _min?: ElderlyCareCompanionStoreMinOrderByAggregateInput
  }

  export type ElderlyCareCompanionStoreScalarWhereWithAggregatesInput = {
    AND?: ElderlyCareCompanionStoreScalarWhereWithAggregatesInput | ElderlyCareCompanionStoreScalarWhereWithAggregatesInput[]
    OR?: ElderlyCareCompanionStoreScalarWhereWithAggregatesInput[]
    NOT?: ElderlyCareCompanionStoreScalarWhereWithAggregatesInput | ElderlyCareCompanionStoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ElderlyCareCompanionStore"> | string
    name?: StringWithAggregatesFilter<"ElderlyCareCompanionStore"> | string
    address?: StringWithAggregatesFilter<"ElderlyCareCompanionStore"> | string
    phone?: StringWithAggregatesFilter<"ElderlyCareCompanionStore"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionStore"> | Date | string
  }

  export type ElderlyCareCompanionRecordWhereInput = {
    AND?: ElderlyCareCompanionRecordWhereInput | ElderlyCareCompanionRecordWhereInput[]
    OR?: ElderlyCareCompanionRecordWhereInput[]
    NOT?: ElderlyCareCompanionRecordWhereInput | ElderlyCareCompanionRecordWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionRecord"> | string
    userId?: StringFilter<"ElderlyCareCompanionRecord"> | string
    recordType?: StringFilter<"ElderlyCareCompanionRecord"> | string
    details?: StringFilter<"ElderlyCareCompanionRecord"> | string
    date?: DateTimeFilter<"ElderlyCareCompanionRecord"> | Date | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionRecord"> | Date | string
    user?: XOR<UserElderlyCareCompanionScalarRelationFilter, UserElderlyCareCompanionWhereInput>
  }

  export type ElderlyCareCompanionRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    details?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    user?: UserElderlyCareCompanionOrderByWithRelationInput
  }

  export type ElderlyCareCompanionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElderlyCareCompanionRecordWhereInput | ElderlyCareCompanionRecordWhereInput[]
    OR?: ElderlyCareCompanionRecordWhereInput[]
    NOT?: ElderlyCareCompanionRecordWhereInput | ElderlyCareCompanionRecordWhereInput[]
    userId?: StringFilter<"ElderlyCareCompanionRecord"> | string
    recordType?: StringFilter<"ElderlyCareCompanionRecord"> | string
    details?: StringFilter<"ElderlyCareCompanionRecord"> | string
    date?: DateTimeFilter<"ElderlyCareCompanionRecord"> | Date | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionRecord"> | Date | string
    user?: XOR<UserElderlyCareCompanionScalarRelationFilter, UserElderlyCareCompanionWhereInput>
  }, "id">

  export type ElderlyCareCompanionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    details?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    _count?: ElderlyCareCompanionRecordCountOrderByAggregateInput
    _max?: ElderlyCareCompanionRecordMaxOrderByAggregateInput
    _min?: ElderlyCareCompanionRecordMinOrderByAggregateInput
  }

  export type ElderlyCareCompanionRecordScalarWhereWithAggregatesInput = {
    AND?: ElderlyCareCompanionRecordScalarWhereWithAggregatesInput | ElderlyCareCompanionRecordScalarWhereWithAggregatesInput[]
    OR?: ElderlyCareCompanionRecordScalarWhereWithAggregatesInput[]
    NOT?: ElderlyCareCompanionRecordScalarWhereWithAggregatesInput | ElderlyCareCompanionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ElderlyCareCompanionRecord"> | string
    userId?: StringWithAggregatesFilter<"ElderlyCareCompanionRecord"> | string
    recordType?: StringWithAggregatesFilter<"ElderlyCareCompanionRecord"> | string
    details?: StringWithAggregatesFilter<"ElderlyCareCompanionRecord"> | string
    date?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionRecord"> | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingWhereInput = {
    AND?: ElderlyCareCompanionMedicationTrackingWhereInput | ElderlyCareCompanionMedicationTrackingWhereInput[]
    OR?: ElderlyCareCompanionMedicationTrackingWhereInput[]
    NOT?: ElderlyCareCompanionMedicationTrackingWhereInput | ElderlyCareCompanionMedicationTrackingWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    userId?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    medicationId?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    status?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    dateTime?: DateTimeFilter<"ElderlyCareCompanionMedicationTracking"> | Date | string
    user?: XOR<UserElderlyCareCompanionScalarRelationFilter, UserElderlyCareCompanionWhereInput>
    medication?: XOR<ElderlyCareCompanionAppointmentScalarRelationFilter, ElderlyCareCompanionAppointmentWhereInput>
  }

  export type ElderlyCareCompanionMedicationTrackingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dateTime?: SortOrder
    user?: UserElderlyCareCompanionOrderByWithRelationInput
    medication?: ElderlyCareCompanionAppointmentOrderByWithRelationInput
  }

  export type ElderlyCareCompanionMedicationTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ElderlyCareCompanionMedicationTrackingWhereInput | ElderlyCareCompanionMedicationTrackingWhereInput[]
    OR?: ElderlyCareCompanionMedicationTrackingWhereInput[]
    NOT?: ElderlyCareCompanionMedicationTrackingWhereInput | ElderlyCareCompanionMedicationTrackingWhereInput[]
    userId?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    medicationId?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    status?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    dateTime?: DateTimeFilter<"ElderlyCareCompanionMedicationTracking"> | Date | string
    user?: XOR<UserElderlyCareCompanionScalarRelationFilter, UserElderlyCareCompanionWhereInput>
    medication?: XOR<ElderlyCareCompanionAppointmentScalarRelationFilter, ElderlyCareCompanionAppointmentWhereInput>
  }, "id">

  export type ElderlyCareCompanionMedicationTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dateTime?: SortOrder
    _count?: ElderlyCareCompanionMedicationTrackingCountOrderByAggregateInput
    _max?: ElderlyCareCompanionMedicationTrackingMaxOrderByAggregateInput
    _min?: ElderlyCareCompanionMedicationTrackingMinOrderByAggregateInput
  }

  export type ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput = {
    AND?: ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput | ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput[]
    OR?: ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput[]
    NOT?: ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput | ElderlyCareCompanionMedicationTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ElderlyCareCompanionMedicationTracking"> | string
    userId?: StringWithAggregatesFilter<"ElderlyCareCompanionMedicationTracking"> | string
    medicationId?: StringWithAggregatesFilter<"ElderlyCareCompanionMedicationTracking"> | string
    status?: StringWithAggregatesFilter<"ElderlyCareCompanionMedicationTracking"> | string
    dateTime?: DateTimeWithAggregatesFilter<"ElderlyCareCompanionMedicationTracking"> | Date | string
  }

  export type UserEduSeekerWhereInput = {
    AND?: UserEduSeekerWhereInput | UserEduSeekerWhereInput[]
    OR?: UserEduSeekerWhereInput[]
    NOT?: UserEduSeekerWhereInput | UserEduSeekerWhereInput[]
    id?: StringFilter<"UserEduSeeker"> | string
    email?: StringFilter<"UserEduSeeker"> | string
    name?: StringFilter<"UserEduSeeker"> | string
    password?: StringFilter<"UserEduSeeker"> | string
    createdAt?: DateTimeFilter<"UserEduSeeker"> | Date | string
    platforms?: PlatformEduSeekerListRelationFilter
    reviews?: ReviewEduSeekerListRelationFilter
  }

  export type UserEduSeekerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    platforms?: PlatformEduSeekerOrderByRelationAggregateInput
    reviews?: ReviewEduSeekerOrderByRelationAggregateInput
  }

  export type UserEduSeekerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserEduSeekerWhereInput | UserEduSeekerWhereInput[]
    OR?: UserEduSeekerWhereInput[]
    NOT?: UserEduSeekerWhereInput | UserEduSeekerWhereInput[]
    name?: StringFilter<"UserEduSeeker"> | string
    password?: StringFilter<"UserEduSeeker"> | string
    createdAt?: DateTimeFilter<"UserEduSeeker"> | Date | string
    platforms?: PlatformEduSeekerListRelationFilter
    reviews?: ReviewEduSeekerListRelationFilter
  }, "id" | "email">

  export type UserEduSeekerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserEduSeekerCountOrderByAggregateInput
    _max?: UserEduSeekerMaxOrderByAggregateInput
    _min?: UserEduSeekerMinOrderByAggregateInput
  }

  export type UserEduSeekerScalarWhereWithAggregatesInput = {
    AND?: UserEduSeekerScalarWhereWithAggregatesInput | UserEduSeekerScalarWhereWithAggregatesInput[]
    OR?: UserEduSeekerScalarWhereWithAggregatesInput[]
    NOT?: UserEduSeekerScalarWhereWithAggregatesInput | UserEduSeekerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserEduSeeker"> | string
    email?: StringWithAggregatesFilter<"UserEduSeeker"> | string
    name?: StringWithAggregatesFilter<"UserEduSeeker"> | string
    password?: StringWithAggregatesFilter<"UserEduSeeker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserEduSeeker"> | Date | string
  }

  export type PlatformEduSeekerWhereInput = {
    AND?: PlatformEduSeekerWhereInput | PlatformEduSeekerWhereInput[]
    OR?: PlatformEduSeekerWhereInput[]
    NOT?: PlatformEduSeekerWhereInput | PlatformEduSeekerWhereInput[]
    id?: StringFilter<"PlatformEduSeeker"> | string
    name?: StringFilter<"PlatformEduSeeker"> | string
    description?: StringFilter<"PlatformEduSeeker"> | string
    category?: StringFilter<"PlatformEduSeeker"> | string
    url?: StringFilter<"PlatformEduSeeker"> | string
    submittedBy?: StringFilter<"PlatformEduSeeker"> | string
    createdAt?: DateTimeFilter<"PlatformEduSeeker"> | Date | string
    validated?: BoolFilter<"PlatformEduSeeker"> | boolean
    submitter?: XOR<UserEduSeekerScalarRelationFilter, UserEduSeekerWhereInput>
    reviews?: ReviewEduSeekerListRelationFilter
  }

  export type PlatformEduSeekerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    url?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
    submitter?: UserEduSeekerOrderByWithRelationInput
    reviews?: ReviewEduSeekerOrderByRelationAggregateInput
  }

  export type PlatformEduSeekerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlatformEduSeekerWhereInput | PlatformEduSeekerWhereInput[]
    OR?: PlatformEduSeekerWhereInput[]
    NOT?: PlatformEduSeekerWhereInput | PlatformEduSeekerWhereInput[]
    name?: StringFilter<"PlatformEduSeeker"> | string
    description?: StringFilter<"PlatformEduSeeker"> | string
    category?: StringFilter<"PlatformEduSeeker"> | string
    url?: StringFilter<"PlatformEduSeeker"> | string
    submittedBy?: StringFilter<"PlatformEduSeeker"> | string
    createdAt?: DateTimeFilter<"PlatformEduSeeker"> | Date | string
    validated?: BoolFilter<"PlatformEduSeeker"> | boolean
    submitter?: XOR<UserEduSeekerScalarRelationFilter, UserEduSeekerWhereInput>
    reviews?: ReviewEduSeekerListRelationFilter
  }, "id">

  export type PlatformEduSeekerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    url?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
    _count?: PlatformEduSeekerCountOrderByAggregateInput
    _max?: PlatformEduSeekerMaxOrderByAggregateInput
    _min?: PlatformEduSeekerMinOrderByAggregateInput
  }

  export type PlatformEduSeekerScalarWhereWithAggregatesInput = {
    AND?: PlatformEduSeekerScalarWhereWithAggregatesInput | PlatformEduSeekerScalarWhereWithAggregatesInput[]
    OR?: PlatformEduSeekerScalarWhereWithAggregatesInput[]
    NOT?: PlatformEduSeekerScalarWhereWithAggregatesInput | PlatformEduSeekerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformEduSeeker"> | string
    name?: StringWithAggregatesFilter<"PlatformEduSeeker"> | string
    description?: StringWithAggregatesFilter<"PlatformEduSeeker"> | string
    category?: StringWithAggregatesFilter<"PlatformEduSeeker"> | string
    url?: StringWithAggregatesFilter<"PlatformEduSeeker"> | string
    submittedBy?: StringWithAggregatesFilter<"PlatformEduSeeker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlatformEduSeeker"> | Date | string
    validated?: BoolWithAggregatesFilter<"PlatformEduSeeker"> | boolean
  }

  export type ReviewEduSeekerWhereInput = {
    AND?: ReviewEduSeekerWhereInput | ReviewEduSeekerWhereInput[]
    OR?: ReviewEduSeekerWhereInput[]
    NOT?: ReviewEduSeekerWhereInput | ReviewEduSeekerWhereInput[]
    id?: StringFilter<"ReviewEduSeeker"> | string
    platformId?: StringFilter<"ReviewEduSeeker"> | string
    userId?: StringFilter<"ReviewEduSeeker"> | string
    rating?: IntFilter<"ReviewEduSeeker"> | number
    comment?: StringFilter<"ReviewEduSeeker"> | string
    validated?: BoolFilter<"ReviewEduSeeker"> | boolean
    createdAt?: DateTimeFilter<"ReviewEduSeeker"> | Date | string
    platform?: XOR<PlatformEduSeekerScalarRelationFilter, PlatformEduSeekerWhereInput>
    user?: XOR<UserEduSeekerScalarRelationFilter, UserEduSeekerWhereInput>
  }

  export type ReviewEduSeekerOrderByWithRelationInput = {
    id?: SortOrder
    platformId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    platform?: PlatformEduSeekerOrderByWithRelationInput
    user?: UserEduSeekerOrderByWithRelationInput
  }

  export type ReviewEduSeekerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewEduSeekerWhereInput | ReviewEduSeekerWhereInput[]
    OR?: ReviewEduSeekerWhereInput[]
    NOT?: ReviewEduSeekerWhereInput | ReviewEduSeekerWhereInput[]
    platformId?: StringFilter<"ReviewEduSeeker"> | string
    userId?: StringFilter<"ReviewEduSeeker"> | string
    rating?: IntFilter<"ReviewEduSeeker"> | number
    comment?: StringFilter<"ReviewEduSeeker"> | string
    validated?: BoolFilter<"ReviewEduSeeker"> | boolean
    createdAt?: DateTimeFilter<"ReviewEduSeeker"> | Date | string
    platform?: XOR<PlatformEduSeekerScalarRelationFilter, PlatformEduSeekerWhereInput>
    user?: XOR<UserEduSeekerScalarRelationFilter, UserEduSeekerWhereInput>
  }, "id">

  export type ReviewEduSeekerOrderByWithAggregationInput = {
    id?: SortOrder
    platformId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewEduSeekerCountOrderByAggregateInput
    _avg?: ReviewEduSeekerAvgOrderByAggregateInput
    _max?: ReviewEduSeekerMaxOrderByAggregateInput
    _min?: ReviewEduSeekerMinOrderByAggregateInput
    _sum?: ReviewEduSeekerSumOrderByAggregateInput
  }

  export type ReviewEduSeekerScalarWhereWithAggregatesInput = {
    AND?: ReviewEduSeekerScalarWhereWithAggregatesInput | ReviewEduSeekerScalarWhereWithAggregatesInput[]
    OR?: ReviewEduSeekerScalarWhereWithAggregatesInput[]
    NOT?: ReviewEduSeekerScalarWhereWithAggregatesInput | ReviewEduSeekerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewEduSeeker"> | string
    platformId?: StringWithAggregatesFilter<"ReviewEduSeeker"> | string
    userId?: StringWithAggregatesFilter<"ReviewEduSeeker"> | string
    rating?: IntWithAggregatesFilter<"ReviewEduSeeker"> | number
    comment?: StringWithAggregatesFilter<"ReviewEduSeeker"> | string
    validated?: BoolWithAggregatesFilter<"ReviewEduSeeker"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ReviewEduSeeker"> | Date | string
  }

  export type UserFinanceManagerWhereInput = {
    AND?: UserFinanceManagerWhereInput | UserFinanceManagerWhereInput[]
    OR?: UserFinanceManagerWhereInput[]
    NOT?: UserFinanceManagerWhereInput | UserFinanceManagerWhereInput[]
    id?: StringFilter<"UserFinanceManager"> | string
    email?: StringFilter<"UserFinanceManager"> | string
    name?: StringFilter<"UserFinanceManager"> | string
    password?: StringFilter<"UserFinanceManager"> | string
    createdAt?: DateTimeFilter<"UserFinanceManager"> | Date | string
    transactions?: TransactionFinanceManagerListRelationFilter
    goals?: GoalFinanceManagerListRelationFilter
  }

  export type UserFinanceManagerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    transactions?: TransactionFinanceManagerOrderByRelationAggregateInput
    goals?: GoalFinanceManagerOrderByRelationAggregateInput
  }

  export type UserFinanceManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserFinanceManagerWhereInput | UserFinanceManagerWhereInput[]
    OR?: UserFinanceManagerWhereInput[]
    NOT?: UserFinanceManagerWhereInput | UserFinanceManagerWhereInput[]
    name?: StringFilter<"UserFinanceManager"> | string
    password?: StringFilter<"UserFinanceManager"> | string
    createdAt?: DateTimeFilter<"UserFinanceManager"> | Date | string
    transactions?: TransactionFinanceManagerListRelationFilter
    goals?: GoalFinanceManagerListRelationFilter
  }, "id" | "email">

  export type UserFinanceManagerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserFinanceManagerCountOrderByAggregateInput
    _max?: UserFinanceManagerMaxOrderByAggregateInput
    _min?: UserFinanceManagerMinOrderByAggregateInput
  }

  export type UserFinanceManagerScalarWhereWithAggregatesInput = {
    AND?: UserFinanceManagerScalarWhereWithAggregatesInput | UserFinanceManagerScalarWhereWithAggregatesInput[]
    OR?: UserFinanceManagerScalarWhereWithAggregatesInput[]
    NOT?: UserFinanceManagerScalarWhereWithAggregatesInput | UserFinanceManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFinanceManager"> | string
    email?: StringWithAggregatesFilter<"UserFinanceManager"> | string
    name?: StringWithAggregatesFilter<"UserFinanceManager"> | string
    password?: StringWithAggregatesFilter<"UserFinanceManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFinanceManager"> | Date | string
  }

  export type TransactionFinanceManagerWhereInput = {
    AND?: TransactionFinanceManagerWhereInput | TransactionFinanceManagerWhereInput[]
    OR?: TransactionFinanceManagerWhereInput[]
    NOT?: TransactionFinanceManagerWhereInput | TransactionFinanceManagerWhereInput[]
    id?: StringFilter<"TransactionFinanceManager"> | string
    userId?: StringFilter<"TransactionFinanceManager"> | string
    amount?: DecimalFilter<"TransactionFinanceManager"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"TransactionFinanceManager"> | string
    category?: StringNullableFilter<"TransactionFinanceManager"> | string | null
    source?: StringNullableFilter<"TransactionFinanceManager"> | string | null
    date?: DateTimeFilter<"TransactionFinanceManager"> | Date | string
    description?: StringFilter<"TransactionFinanceManager"> | string
    createdAt?: DateTimeFilter<"TransactionFinanceManager"> | Date | string
    user?: XOR<UserFinanceManagerScalarRelationFilter, UserFinanceManagerWhereInput>
  }

  export type TransactionFinanceManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    user?: UserFinanceManagerOrderByWithRelationInput
  }

  export type TransactionFinanceManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionFinanceManagerWhereInput | TransactionFinanceManagerWhereInput[]
    OR?: TransactionFinanceManagerWhereInput[]
    NOT?: TransactionFinanceManagerWhereInput | TransactionFinanceManagerWhereInput[]
    userId?: StringFilter<"TransactionFinanceManager"> | string
    amount?: DecimalFilter<"TransactionFinanceManager"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"TransactionFinanceManager"> | string
    category?: StringNullableFilter<"TransactionFinanceManager"> | string | null
    source?: StringNullableFilter<"TransactionFinanceManager"> | string | null
    date?: DateTimeFilter<"TransactionFinanceManager"> | Date | string
    description?: StringFilter<"TransactionFinanceManager"> | string
    createdAt?: DateTimeFilter<"TransactionFinanceManager"> | Date | string
    user?: XOR<UserFinanceManagerScalarRelationFilter, UserFinanceManagerWhereInput>
  }, "id">

  export type TransactionFinanceManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionFinanceManagerCountOrderByAggregateInput
    _avg?: TransactionFinanceManagerAvgOrderByAggregateInput
    _max?: TransactionFinanceManagerMaxOrderByAggregateInput
    _min?: TransactionFinanceManagerMinOrderByAggregateInput
    _sum?: TransactionFinanceManagerSumOrderByAggregateInput
  }

  export type TransactionFinanceManagerScalarWhereWithAggregatesInput = {
    AND?: TransactionFinanceManagerScalarWhereWithAggregatesInput | TransactionFinanceManagerScalarWhereWithAggregatesInput[]
    OR?: TransactionFinanceManagerScalarWhereWithAggregatesInput[]
    NOT?: TransactionFinanceManagerScalarWhereWithAggregatesInput | TransactionFinanceManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionFinanceManager"> | string
    userId?: StringWithAggregatesFilter<"TransactionFinanceManager"> | string
    amount?: DecimalWithAggregatesFilter<"TransactionFinanceManager"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"TransactionFinanceManager"> | string
    category?: StringNullableWithAggregatesFilter<"TransactionFinanceManager"> | string | null
    source?: StringNullableWithAggregatesFilter<"TransactionFinanceManager"> | string | null
    date?: DateTimeWithAggregatesFilter<"TransactionFinanceManager"> | Date | string
    description?: StringWithAggregatesFilter<"TransactionFinanceManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TransactionFinanceManager"> | Date | string
  }

  export type GoalFinanceManagerWhereInput = {
    AND?: GoalFinanceManagerWhereInput | GoalFinanceManagerWhereInput[]
    OR?: GoalFinanceManagerWhereInput[]
    NOT?: GoalFinanceManagerWhereInput | GoalFinanceManagerWhereInput[]
    id?: StringFilter<"GoalFinanceManager"> | string
    userId?: StringFilter<"GoalFinanceManager"> | string
    title?: StringFilter<"GoalFinanceManager"> | string
    targetAmount?: DecimalFilter<"GoalFinanceManager"> | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFilter<"GoalFinanceManager"> | Date | string
    description?: StringFilter<"GoalFinanceManager"> | string
    createdAt?: DateTimeFilter<"GoalFinanceManager"> | Date | string
    user?: XOR<UserFinanceManagerScalarRelationFilter, UserFinanceManagerWhereInput>
  }

  export type GoalFinanceManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    user?: UserFinanceManagerOrderByWithRelationInput
  }

  export type GoalFinanceManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoalFinanceManagerWhereInput | GoalFinanceManagerWhereInput[]
    OR?: GoalFinanceManagerWhereInput[]
    NOT?: GoalFinanceManagerWhereInput | GoalFinanceManagerWhereInput[]
    userId?: StringFilter<"GoalFinanceManager"> | string
    title?: StringFilter<"GoalFinanceManager"> | string
    targetAmount?: DecimalFilter<"GoalFinanceManager"> | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFilter<"GoalFinanceManager"> | Date | string
    description?: StringFilter<"GoalFinanceManager"> | string
    createdAt?: DateTimeFilter<"GoalFinanceManager"> | Date | string
    user?: XOR<UserFinanceManagerScalarRelationFilter, UserFinanceManagerWhereInput>
  }, "id">

  export type GoalFinanceManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: GoalFinanceManagerCountOrderByAggregateInput
    _avg?: GoalFinanceManagerAvgOrderByAggregateInput
    _max?: GoalFinanceManagerMaxOrderByAggregateInput
    _min?: GoalFinanceManagerMinOrderByAggregateInput
    _sum?: GoalFinanceManagerSumOrderByAggregateInput
  }

  export type GoalFinanceManagerScalarWhereWithAggregatesInput = {
    AND?: GoalFinanceManagerScalarWhereWithAggregatesInput | GoalFinanceManagerScalarWhereWithAggregatesInput[]
    OR?: GoalFinanceManagerScalarWhereWithAggregatesInput[]
    NOT?: GoalFinanceManagerScalarWhereWithAggregatesInput | GoalFinanceManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoalFinanceManager"> | string
    userId?: StringWithAggregatesFilter<"GoalFinanceManager"> | string
    title?: StringWithAggregatesFilter<"GoalFinanceManager"> | string
    targetAmount?: DecimalWithAggregatesFilter<"GoalFinanceManager"> | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeWithAggregatesFilter<"GoalFinanceManager"> | Date | string
    description?: StringWithAggregatesFilter<"GoalFinanceManager"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GoalFinanceManager"> | Date | string
  }

  export type UserMentalWellnessWhereInput = {
    AND?: UserMentalWellnessWhereInput | UserMentalWellnessWhereInput[]
    OR?: UserMentalWellnessWhereInput[]
    NOT?: UserMentalWellnessWhereInput | UserMentalWellnessWhereInput[]
    id?: StringFilter<"UserMentalWellness"> | string
    email?: StringFilter<"UserMentalWellness"> | string
    name?: StringFilter<"UserMentalWellness"> | string
    password?: StringFilter<"UserMentalWellness"> | string
    createdAt?: DateTimeFilter<"UserMentalWellness"> | Date | string
    journals?: JournalMentalWellnessListRelationFilter
    assessments?: AssessmentMentalWellnessListRelationFilter
    feedbacks?: MeditationFeedbackListRelationFilter
  }

  export type UserMentalWellnessOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    journals?: JournalMentalWellnessOrderByRelationAggregateInput
    assessments?: AssessmentMentalWellnessOrderByRelationAggregateInput
    feedbacks?: MeditationFeedbackOrderByRelationAggregateInput
  }

  export type UserMentalWellnessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserMentalWellnessWhereInput | UserMentalWellnessWhereInput[]
    OR?: UserMentalWellnessWhereInput[]
    NOT?: UserMentalWellnessWhereInput | UserMentalWellnessWhereInput[]
    name?: StringFilter<"UserMentalWellness"> | string
    password?: StringFilter<"UserMentalWellness"> | string
    createdAt?: DateTimeFilter<"UserMentalWellness"> | Date | string
    journals?: JournalMentalWellnessListRelationFilter
    assessments?: AssessmentMentalWellnessListRelationFilter
    feedbacks?: MeditationFeedbackListRelationFilter
  }, "id" | "email">

  export type UserMentalWellnessOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserMentalWellnessCountOrderByAggregateInput
    _max?: UserMentalWellnessMaxOrderByAggregateInput
    _min?: UserMentalWellnessMinOrderByAggregateInput
  }

  export type UserMentalWellnessScalarWhereWithAggregatesInput = {
    AND?: UserMentalWellnessScalarWhereWithAggregatesInput | UserMentalWellnessScalarWhereWithAggregatesInput[]
    OR?: UserMentalWellnessScalarWhereWithAggregatesInput[]
    NOT?: UserMentalWellnessScalarWhereWithAggregatesInput | UserMentalWellnessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMentalWellness"> | string
    email?: StringWithAggregatesFilter<"UserMentalWellness"> | string
    name?: StringWithAggregatesFilter<"UserMentalWellness"> | string
    password?: StringWithAggregatesFilter<"UserMentalWellness"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserMentalWellness"> | Date | string
  }

  export type JournalMentalWellnessWhereInput = {
    AND?: JournalMentalWellnessWhereInput | JournalMentalWellnessWhereInput[]
    OR?: JournalMentalWellnessWhereInput[]
    NOT?: JournalMentalWellnessWhereInput | JournalMentalWellnessWhereInput[]
    id?: StringFilter<"JournalMentalWellness"> | string
    userId?: StringFilter<"JournalMentalWellness"> | string
    mood?: StringFilter<"JournalMentalWellness"> | string
    entryText?: StringFilter<"JournalMentalWellness"> | string
    tags?: StringNullableListFilter<"JournalMentalWellness">
    createdAt?: DateTimeFilter<"JournalMentalWellness"> | Date | string
    user?: XOR<UserMentalWellnessScalarRelationFilter, UserMentalWellnessWhereInput>
  }

  export type JournalMentalWellnessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    entryText?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    user?: UserMentalWellnessOrderByWithRelationInput
  }

  export type JournalMentalWellnessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalMentalWellnessWhereInput | JournalMentalWellnessWhereInput[]
    OR?: JournalMentalWellnessWhereInput[]
    NOT?: JournalMentalWellnessWhereInput | JournalMentalWellnessWhereInput[]
    userId?: StringFilter<"JournalMentalWellness"> | string
    mood?: StringFilter<"JournalMentalWellness"> | string
    entryText?: StringFilter<"JournalMentalWellness"> | string
    tags?: StringNullableListFilter<"JournalMentalWellness">
    createdAt?: DateTimeFilter<"JournalMentalWellness"> | Date | string
    user?: XOR<UserMentalWellnessScalarRelationFilter, UserMentalWellnessWhereInput>
  }, "id">

  export type JournalMentalWellnessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    entryText?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    _count?: JournalMentalWellnessCountOrderByAggregateInput
    _max?: JournalMentalWellnessMaxOrderByAggregateInput
    _min?: JournalMentalWellnessMinOrderByAggregateInput
  }

  export type JournalMentalWellnessScalarWhereWithAggregatesInput = {
    AND?: JournalMentalWellnessScalarWhereWithAggregatesInput | JournalMentalWellnessScalarWhereWithAggregatesInput[]
    OR?: JournalMentalWellnessScalarWhereWithAggregatesInput[]
    NOT?: JournalMentalWellnessScalarWhereWithAggregatesInput | JournalMentalWellnessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalMentalWellness"> | string
    userId?: StringWithAggregatesFilter<"JournalMentalWellness"> | string
    mood?: StringWithAggregatesFilter<"JournalMentalWellness"> | string
    entryText?: StringWithAggregatesFilter<"JournalMentalWellness"> | string
    tags?: StringNullableListFilter<"JournalMentalWellness">
    createdAt?: DateTimeWithAggregatesFilter<"JournalMentalWellness"> | Date | string
  }

  export type AssessmentMentalWellnessWhereInput = {
    AND?: AssessmentMentalWellnessWhereInput | AssessmentMentalWellnessWhereInput[]
    OR?: AssessmentMentalWellnessWhereInput[]
    NOT?: AssessmentMentalWellnessWhereInput | AssessmentMentalWellnessWhereInput[]
    id?: StringFilter<"AssessmentMentalWellness"> | string
    userId?: StringFilter<"AssessmentMentalWellness"> | string
    responses?: JsonFilter<"AssessmentMentalWellness">
    result?: StringFilter<"AssessmentMentalWellness"> | string
    createdAt?: DateTimeFilter<"AssessmentMentalWellness"> | Date | string
    user?: XOR<UserMentalWellnessScalarRelationFilter, UserMentalWellnessWhereInput>
  }

  export type AssessmentMentalWellnessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    responses?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    user?: UserMentalWellnessOrderByWithRelationInput
  }

  export type AssessmentMentalWellnessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssessmentMentalWellnessWhereInput | AssessmentMentalWellnessWhereInput[]
    OR?: AssessmentMentalWellnessWhereInput[]
    NOT?: AssessmentMentalWellnessWhereInput | AssessmentMentalWellnessWhereInput[]
    userId?: StringFilter<"AssessmentMentalWellness"> | string
    responses?: JsonFilter<"AssessmentMentalWellness">
    result?: StringFilter<"AssessmentMentalWellness"> | string
    createdAt?: DateTimeFilter<"AssessmentMentalWellness"> | Date | string
    user?: XOR<UserMentalWellnessScalarRelationFilter, UserMentalWellnessWhereInput>
  }, "id">

  export type AssessmentMentalWellnessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    responses?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    _count?: AssessmentMentalWellnessCountOrderByAggregateInput
    _max?: AssessmentMentalWellnessMaxOrderByAggregateInput
    _min?: AssessmentMentalWellnessMinOrderByAggregateInput
  }

  export type AssessmentMentalWellnessScalarWhereWithAggregatesInput = {
    AND?: AssessmentMentalWellnessScalarWhereWithAggregatesInput | AssessmentMentalWellnessScalarWhereWithAggregatesInput[]
    OR?: AssessmentMentalWellnessScalarWhereWithAggregatesInput[]
    NOT?: AssessmentMentalWellnessScalarWhereWithAggregatesInput | AssessmentMentalWellnessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssessmentMentalWellness"> | string
    userId?: StringWithAggregatesFilter<"AssessmentMentalWellness"> | string
    responses?: JsonWithAggregatesFilter<"AssessmentMentalWellness">
    result?: StringWithAggregatesFilter<"AssessmentMentalWellness"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AssessmentMentalWellness"> | Date | string
  }

  export type MeditationWhereInput = {
    AND?: MeditationWhereInput | MeditationWhereInput[]
    OR?: MeditationWhereInput[]
    NOT?: MeditationWhereInput | MeditationWhereInput[]
    id?: StringFilter<"Meditation"> | string
    title?: StringFilter<"Meditation"> | string
    description?: StringFilter<"Meditation"> | string
    audioUrl?: StringFilter<"Meditation"> | string
    createdAt?: DateTimeFilter<"Meditation"> | Date | string
    feedbacks?: MeditationFeedbackListRelationFilter
  }

  export type MeditationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
    feedbacks?: MeditationFeedbackOrderByRelationAggregateInput
  }

  export type MeditationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeditationWhereInput | MeditationWhereInput[]
    OR?: MeditationWhereInput[]
    NOT?: MeditationWhereInput | MeditationWhereInput[]
    title?: StringFilter<"Meditation"> | string
    description?: StringFilter<"Meditation"> | string
    audioUrl?: StringFilter<"Meditation"> | string
    createdAt?: DateTimeFilter<"Meditation"> | Date | string
    feedbacks?: MeditationFeedbackListRelationFilter
  }, "id">

  export type MeditationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
    _count?: MeditationCountOrderByAggregateInput
    _max?: MeditationMaxOrderByAggregateInput
    _min?: MeditationMinOrderByAggregateInput
  }

  export type MeditationScalarWhereWithAggregatesInput = {
    AND?: MeditationScalarWhereWithAggregatesInput | MeditationScalarWhereWithAggregatesInput[]
    OR?: MeditationScalarWhereWithAggregatesInput[]
    NOT?: MeditationScalarWhereWithAggregatesInput | MeditationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meditation"> | string
    title?: StringWithAggregatesFilter<"Meditation"> | string
    description?: StringWithAggregatesFilter<"Meditation"> | string
    audioUrl?: StringWithAggregatesFilter<"Meditation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Meditation"> | Date | string
  }

  export type MeditationFeedbackWhereInput = {
    AND?: MeditationFeedbackWhereInput | MeditationFeedbackWhereInput[]
    OR?: MeditationFeedbackWhereInput[]
    NOT?: MeditationFeedbackWhereInput | MeditationFeedbackWhereInput[]
    id?: StringFilter<"MeditationFeedback"> | string
    meditationId?: StringFilter<"MeditationFeedback"> | string
    userId?: StringFilter<"MeditationFeedback"> | string
    rating?: IntFilter<"MeditationFeedback"> | number
    comment?: StringFilter<"MeditationFeedback"> | string
    createdAt?: DateTimeFilter<"MeditationFeedback"> | Date | string
    user?: XOR<UserMentalWellnessScalarRelationFilter, UserMentalWellnessWhereInput>
    meditation?: XOR<MeditationScalarRelationFilter, MeditationWhereInput>
  }

  export type MeditationFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    meditationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    user?: UserMentalWellnessOrderByWithRelationInput
    meditation?: MeditationOrderByWithRelationInput
  }

  export type MeditationFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeditationFeedbackWhereInput | MeditationFeedbackWhereInput[]
    OR?: MeditationFeedbackWhereInput[]
    NOT?: MeditationFeedbackWhereInput | MeditationFeedbackWhereInput[]
    meditationId?: StringFilter<"MeditationFeedback"> | string
    userId?: StringFilter<"MeditationFeedback"> | string
    rating?: IntFilter<"MeditationFeedback"> | number
    comment?: StringFilter<"MeditationFeedback"> | string
    createdAt?: DateTimeFilter<"MeditationFeedback"> | Date | string
    user?: XOR<UserMentalWellnessScalarRelationFilter, UserMentalWellnessWhereInput>
    meditation?: XOR<MeditationScalarRelationFilter, MeditationWhereInput>
  }, "id">

  export type MeditationFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    meditationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    _count?: MeditationFeedbackCountOrderByAggregateInput
    _avg?: MeditationFeedbackAvgOrderByAggregateInput
    _max?: MeditationFeedbackMaxOrderByAggregateInput
    _min?: MeditationFeedbackMinOrderByAggregateInput
    _sum?: MeditationFeedbackSumOrderByAggregateInput
  }

  export type MeditationFeedbackScalarWhereWithAggregatesInput = {
    AND?: MeditationFeedbackScalarWhereWithAggregatesInput | MeditationFeedbackScalarWhereWithAggregatesInput[]
    OR?: MeditationFeedbackScalarWhereWithAggregatesInput[]
    NOT?: MeditationFeedbackScalarWhereWithAggregatesInput | MeditationFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeditationFeedback"> | string
    meditationId?: StringWithAggregatesFilter<"MeditationFeedback"> | string
    userId?: StringWithAggregatesFilter<"MeditationFeedback"> | string
    rating?: IntWithAggregatesFilter<"MeditationFeedback"> | number
    comment?: StringWithAggregatesFilter<"MeditationFeedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MeditationFeedback"> | Date | string
  }

  export type HospitalMentalWellnessWhereInput = {
    AND?: HospitalMentalWellnessWhereInput | HospitalMentalWellnessWhereInput[]
    OR?: HospitalMentalWellnessWhereInput[]
    NOT?: HospitalMentalWellnessWhereInput | HospitalMentalWellnessWhereInput[]
    id?: StringFilter<"HospitalMentalWellness"> | string
    name?: StringFilter<"HospitalMentalWellness"> | string
    location?: StringFilter<"HospitalMentalWellness"> | string
    contactInfo?: StringFilter<"HospitalMentalWellness"> | string
    type?: StringFilter<"HospitalMentalWellness"> | string
    createdAt?: DateTimeFilter<"HospitalMentalWellness"> | Date | string
  }

  export type HospitalMentalWellnessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type HospitalMentalWellnessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HospitalMentalWellnessWhereInput | HospitalMentalWellnessWhereInput[]
    OR?: HospitalMentalWellnessWhereInput[]
    NOT?: HospitalMentalWellnessWhereInput | HospitalMentalWellnessWhereInput[]
    name?: StringFilter<"HospitalMentalWellness"> | string
    location?: StringFilter<"HospitalMentalWellness"> | string
    contactInfo?: StringFilter<"HospitalMentalWellness"> | string
    type?: StringFilter<"HospitalMentalWellness"> | string
    createdAt?: DateTimeFilter<"HospitalMentalWellness"> | Date | string
  }, "id">

  export type HospitalMentalWellnessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: HospitalMentalWellnessCountOrderByAggregateInput
    _max?: HospitalMentalWellnessMaxOrderByAggregateInput
    _min?: HospitalMentalWellnessMinOrderByAggregateInput
  }

  export type HospitalMentalWellnessScalarWhereWithAggregatesInput = {
    AND?: HospitalMentalWellnessScalarWhereWithAggregatesInput | HospitalMentalWellnessScalarWhereWithAggregatesInput[]
    OR?: HospitalMentalWellnessScalarWhereWithAggregatesInput[]
    NOT?: HospitalMentalWellnessScalarWhereWithAggregatesInput | HospitalMentalWellnessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HospitalMentalWellness"> | string
    name?: StringWithAggregatesFilter<"HospitalMentalWellness"> | string
    location?: StringWithAggregatesFilter<"HospitalMentalWellness"> | string
    contactInfo?: StringWithAggregatesFilter<"HospitalMentalWellness"> | string
    type?: StringWithAggregatesFilter<"HospitalMentalWellness"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HospitalMentalWellness"> | Date | string
  }

  export type UserDIYHomesCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesUncheckedCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserDIYHomesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDIYHomesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDIYHomesCreateInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutPostDIYHomesInput
    reviews?: ReviewDIYHomesCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    category: string
    userId: string
    createdAt?: Date | string
    reviews?: ReviewDIYHomesUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutPostDIYHomesNestedInput
    reviews?: ReviewDIYHomesUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesCreateManyInput = {
    id?: string
    title: string
    content: string
    category: string
    userId: string
    createdAt?: Date | string
  }

  export type PostDIYHomesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDIYHomesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewDIYHomesCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutReviewDIYHomesInput
    post: PostDIYHomesCreateNestedOneWithoutReviewsInput
    Report?: ReportDIYHomesCreateNestedManyWithoutReviewInput
  }

  export type ReviewDIYHomesUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewDIYHomesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutReviewDIYHomesNestedInput
    post?: PostDIYHomesUpdateOneRequiredWithoutReviewsNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutReviewNestedInput
  }

  export type ReviewDIYHomesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewDIYHomesCreateManyInput = {
    id?: string
    postId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewDIYHomesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewDIYHomesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutLikeDIYHomesInput
    post: PostDIYHomesCreateNestedOneWithoutLikeInput
  }

  export type LikeDIYHomesUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeDIYHomesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutLikeDIYHomesNestedInput
    post?: PostDIYHomesUpdateOneRequiredWithoutLikeNestedInput
  }

  export type LikeDIYHomesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesCreateManyInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeDIYHomesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutBookmarkDIYHomesInput
    post: PostDIYHomesCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkDIYHomesUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkDIYHomesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutBookmarkDIYHomesNestedInput
    post?: PostDIYHomesUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkDIYHomesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesCreateManyInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkDIYHomesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesCreateInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutReportDIYHomesInput
    post?: PostDIYHomesCreateNestedOneWithoutReportInput
    review?: ReviewDIYHomesCreateNestedOneWithoutReportInput
  }

  export type ReportDIYHomesUncheckedCreateInput = {
    id?: string
    postId?: string | null
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutReportDIYHomesNestedInput
    post?: PostDIYHomesUpdateOneWithoutReportNestedInput
    review?: ReviewDIYHomesUpdateOneWithoutReportNestedInput
  }

  export type ReportDIYHomesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesCreateManyInput = {
    id?: string
    postId?: string | null
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUrbanExplorerCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserUrbanExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUrbanExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUrbanExplorerCreateInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    owner: UserUrbanExplorerCreateNestedOneWithoutPlaceUrbanExplorerInput
    reviews?: ReviewUrbanExplorerCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUrbanExplorerUpdateOneRequiredWithoutPlaceUrbanExplorerNestedInput
    reviews?: ReviewUrbanExplorerUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerCreateManyInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt?: Date | string
    validated?: boolean
  }

  export type PlaceUrbanExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlaceUrbanExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUrbanExplorerCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutReviewUrbanExplorerInput
    place: PlaceUrbanExplorerCreateNestedOneWithoutReviewsInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutReviewInput
  }

  export type ReviewUrbanExplorerUncheckedCreateInput = {
    id?: string
    placeId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUrbanExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutReviewUrbanExplorerNestedInput
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutReviewsNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUrbanExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUrbanExplorerCreateManyInput = {
    id?: string
    placeId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewUrbanExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUrbanExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutLikeUrbanExplorerInput
    place: PlaceUrbanExplorerCreateNestedOneWithoutLikesInput
  }

  export type LikeUrbanExplorerUncheckedCreateInput = {
    id?: string
    placeId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUrbanExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutLikeUrbanExplorerNestedInput
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUrbanExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerCreateManyInput = {
    id?: string
    placeId: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUrbanExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutBookmarkUrbanExplorerInput
    place: PlaceUrbanExplorerCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUrbanExplorerUncheckedCreateInput = {
    id?: string
    placeId: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkUrbanExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutBookmarkUrbanExplorerNestedInput
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUrbanExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerCreateManyInput = {
    id?: string
    placeId: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkUrbanExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerCreateInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutReportUrbanExplorerInput
    place?: PlaceUrbanExplorerCreateNestedOneWithoutReportsInput
    review?: ReviewUrbanExplorerCreateNestedOneWithoutReportsInput
  }

  export type ReportUrbanExplorerUncheckedCreateInput = {
    id?: string
    placeId?: string | null
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutReportUrbanExplorerNestedInput
    place?: PlaceUrbanExplorerUpdateOneWithoutReportsNestedInput
    review?: ReviewUrbanExplorerUpdateOneWithoutReportsNestedInput
  }

  export type ReportUrbanExplorerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerCreateManyInput = {
    id?: string
    placeId?: string | null
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFoodieCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodCreateNestedManyWithoutUserInput
    FoodieLocation?: FoodieLocationCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeCreateNestedManyWithoutUserInput
  }

  export type UserFoodieUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodUncheckedCreateNestedManyWithoutUserInput
    FoodieLocation?: FoodieLocationUncheckedCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewUncheckedCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFoodieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUpdateManyWithoutUserNestedInput
    FoodieLocation?: FoodieLocationUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUpdateManyWithoutUserNestedInput
  }

  export type UserFoodieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUncheckedUpdateManyWithoutUserNestedInput
    FoodieLocation?: FoodieLocationUncheckedUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUncheckedUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFoodieCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserFoodieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFoodieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieFoodCreateInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieFoodInput
    locations?: FoodieLocationCreateNestedManyWithoutFoodInput
    reviews?: FoodieReviewCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodUncheckedCreateInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    submittedBy: string
    validated?: boolean
    createdAt?: Date | string
    locations?: FoodieLocationUncheckedCreateNestedManyWithoutFoodInput
    reviews?: FoodieReviewUncheckedCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieFoodNestedInput
    locations?: FoodieLocationUpdateManyWithoutFoodNestedInput
    reviews?: FoodieReviewUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: FoodieLocationUncheckedUpdateManyWithoutFoodNestedInput
    reviews?: FoodieReviewUncheckedUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodCreateManyInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    submittedBy: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieFoodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieFoodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationCreateInput = {
    id?: string
    locationName: string
    address: string
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieLocationInput
    food: FoodieFoodCreateNestedOneWithoutLocationsInput
  }

  export type FoodieLocationUncheckedCreateInput = {
    id?: string
    foodId: string
    locationName: string
    address: string
    submittedBy: string
    createdAt?: Date | string
  }

  export type FoodieLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieLocationNestedInput
    food?: FoodieFoodUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type FoodieLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationCreateManyInput = {
    id?: string
    foodId: string
    locationName: string
    address: string
    submittedBy: string
    createdAt?: Date | string
  }

  export type FoodieLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieReviewInput
    food: FoodieFoodCreateNestedOneWithoutReviewsInput
  }

  export type FoodieReviewUncheckedCreateInput = {
    id?: string
    foodId: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieReviewNestedInput
    food?: FoodieFoodUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type FoodieReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewCreateManyInput = {
    id?: string
    foodId: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieLikeInput
    food: FoodieFoodCreateNestedOneWithoutLikesInput
  }

  export type FoodieLikeUncheckedCreateInput = {
    id?: string
    foodId: string
    userId: string
    createdAt?: Date | string
  }

  export type FoodieLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieLikeNestedInput
    food?: FoodieFoodUpdateOneRequiredWithoutLikesNestedInput
  }

  export type FoodieLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeCreateManyInput = {
    id?: string
    foodId: string
    userId: string
    createdAt?: Date | string
  }

  export type FoodieLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPetLoverCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PetPetLover?: PetPetLoverCreateNestedManyWithoutUserInput
    AppointmentPetLover?: AppointmentPetLoverCreateNestedManyWithoutUserInput
  }

  export type UserPetLoverUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PetPetLover?: PetPetLoverUncheckedCreateNestedManyWithoutUserInput
    AppointmentPetLover?: AppointmentPetLoverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserPetLoverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PetPetLover?: PetPetLoverUpdateManyWithoutUserNestedInput
    AppointmentPetLover?: AppointmentPetLoverUpdateManyWithoutUserNestedInput
  }

  export type UserPetLoverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PetPetLover?: PetPetLoverUncheckedUpdateManyWithoutUserNestedInput
    AppointmentPetLover?: AppointmentPetLoverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserPetLoverCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserPetLoverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPetLoverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetPetLoverCreateInput = {
    id?: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    user: UserPetLoverCreateNestedOneWithoutPetPetLoverInput
    vaccinations?: VaccinationPetLoverCreateNestedManyWithoutPetInput
    appointments?: AppointmentPetLoverCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverUncheckedCreateInput = {
    id?: string
    userId: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    vaccinations?: VaccinationPetLoverUncheckedCreateNestedManyWithoutPetInput
    appointments?: AppointmentPetLoverUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserPetLoverUpdateOneRequiredWithoutPetPetLoverNestedInput
    vaccinations?: VaccinationPetLoverUpdateManyWithoutPetNestedInput
    appointments?: AppointmentPetLoverUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationPetLoverUncheckedUpdateManyWithoutPetNestedInput
    appointments?: AppointmentPetLoverUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverCreateManyInput = {
    id?: string
    userId: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
  }

  export type PetPetLoverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetPetLoverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverCreateInput = {
    id?: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
    user: UserPetLoverCreateNestedOneWithoutAppointmentPetLoverInput
    pet: PetPetLoverCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentPetLoverUncheckedCreateInput = {
    id?: string
    userId: string
    petId: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
  }

  export type AppointmentPetLoverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserPetLoverUpdateOneRequiredWithoutAppointmentPetLoverNestedInput
    pet?: PetPetLoverUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentPetLoverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverCreateManyInput = {
    id?: string
    userId: string
    petId: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
  }

  export type AppointmentPetLoverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationPetLoverCreateInput = {
    id?: string
    vaccineName: string
    dateAdministered: Date | string
    nextDueDate?: Date | string | null
    createdAt?: Date | string
    pet: PetPetLoverCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationPetLoverUncheckedCreateInput = {
    id?: string
    petId: string
    vaccineName: string
    dateAdministered: Date | string
    nextDueDate?: Date | string | null
    createdAt?: Date | string
  }

  export type VaccinationPetLoverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetPetLoverUpdateOneRequiredWithoutVaccinationsNestedInput
  }

  export type VaccinationPetLoverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationPetLoverCreateManyInput = {
    id?: string
    petId: string
    vaccineName: string
    dateAdministered: Date | string
    nextDueDate?: Date | string | null
    createdAt?: Date | string
  }

  export type VaccinationPetLoverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationPetLoverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPetLoverCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ClinicPetLoverUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ClinicPetLoverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPetLoverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPetLoverCreateManyInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ClinicPetLoverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicPetLoverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePetLoverCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type StorePetLoverUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type StorePetLoverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePetLoverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePetLoverCreateManyInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type StorePetLoverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePetLoverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserElderlyCareCompanionCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentCreateNestedManyWithoutUserInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordCreateNestedManyWithoutUserInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUncheckedCreateNestedManyWithoutUserInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUncheckedCreateNestedManyWithoutUserInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUpdateManyWithoutUserNestedInput
  }

  export type UserElderlyCareCompanionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUncheckedUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUncheckedUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserElderlyCareCompanionCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserElderlyCareCompanionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserElderlyCareCompanionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionAppointmentCreateInput = {
    id?: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
    user: UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionAppointmentInput
    medicationLogs?: ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutMedicationInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
    medicationLogs?: ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type ElderlyCareCompanionAppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionAppointmentNestedInput
    medicationLogs?: ElderlyCareCompanionMedicationTrackingUpdateManyWithoutMedicationNestedInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationLogs?: ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type ElderlyCareCompanionAppointmentCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionAppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionAppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionClinicCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionClinicUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionClinicCreateManyInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionStoreCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionStoreUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionStoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionStoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionStoreCreateManyInput = {
    id?: string
    name: string
    address: string
    phone: string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionStoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionStoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionRecordCreateInput = {
    id?: string
    recordType: string
    details: string
    date: Date | string
    createdAt?: Date | string
    user: UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionRecordInput
  }

  export type ElderlyCareCompanionRecordUncheckedCreateInput = {
    id?: string
    userId: string
    recordType: string
    details: string
    date: Date | string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionRecordNestedInput
  }

  export type ElderlyCareCompanionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionRecordCreateManyInput = {
    id?: string
    userId: string
    recordType: string
    details: string
    date: Date | string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingCreateInput = {
    id?: string
    status: string
    dateTime?: Date | string
    user: UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionMedicationTrackingInput
    medication: ElderlyCareCompanionAppointmentCreateNestedOneWithoutMedicationLogsInput
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedCreateInput = {
    id?: string
    userId: string
    medicationId: string
    status: string
    dateTime?: Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionMedicationTrackingNestedInput
    medication?: ElderlyCareCompanionAppointmentUpdateOneRequiredWithoutMedicationLogsNestedInput
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingCreateManyInput = {
    id?: string
    userId: string
    medicationId: string
    status: string
    dateTime?: Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEduSeekerCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    platforms?: PlatformEduSeekerCreateNestedManyWithoutSubmitterInput
    reviews?: ReviewEduSeekerCreateNestedManyWithoutUserInput
  }

  export type UserEduSeekerUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    platforms?: PlatformEduSeekerUncheckedCreateNestedManyWithoutSubmitterInput
    reviews?: ReviewEduSeekerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserEduSeekerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platforms?: PlatformEduSeekerUpdateManyWithoutSubmitterNestedInput
    reviews?: ReviewEduSeekerUpdateManyWithoutUserNestedInput
  }

  export type UserEduSeekerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platforms?: PlatformEduSeekerUncheckedUpdateManyWithoutSubmitterNestedInput
    reviews?: ReviewEduSeekerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserEduSeekerCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserEduSeekerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEduSeekerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformEduSeekerCreateInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    createdAt?: Date | string
    validated?: boolean
    submitter: UserEduSeekerCreateNestedOneWithoutPlatformsInput
    reviews?: ReviewEduSeekerCreateNestedManyWithoutPlatformInput
  }

  export type PlatformEduSeekerUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    submittedBy: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewEduSeekerUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformEduSeekerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    submitter?: UserEduSeekerUpdateOneRequiredWithoutPlatformsNestedInput
    reviews?: ReviewEduSeekerUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformEduSeekerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewEduSeekerUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformEduSeekerCreateManyInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    submittedBy: string
    createdAt?: Date | string
    validated?: boolean
  }

  export type PlatformEduSeekerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformEduSeekerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewEduSeekerCreateInput = {
    id?: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
    platform: PlatformEduSeekerCreateNestedOneWithoutReviewsInput
    user: UserEduSeekerCreateNestedOneWithoutReviewsInput
  }

  export type ReviewEduSeekerUncheckedCreateInput = {
    id?: string
    platformId: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type ReviewEduSeekerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformEduSeekerUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserEduSeekerUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewEduSeekerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewEduSeekerCreateManyInput = {
    id?: string
    platformId: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type ReviewEduSeekerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewEduSeekerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinanceManagerCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    transactions?: TransactionFinanceManagerCreateNestedManyWithoutUserInput
    goals?: GoalFinanceManagerCreateNestedManyWithoutUserInput
  }

  export type UserFinanceManagerUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    transactions?: TransactionFinanceManagerUncheckedCreateNestedManyWithoutUserInput
    goals?: GoalFinanceManagerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFinanceManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionFinanceManagerUpdateManyWithoutUserNestedInput
    goals?: GoalFinanceManagerUpdateManyWithoutUserNestedInput
  }

  export type UserFinanceManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionFinanceManagerUncheckedUpdateManyWithoutUserNestedInput
    goals?: GoalFinanceManagerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFinanceManagerCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserFinanceManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFinanceManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFinanceManagerCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    category?: string | null
    source?: string | null
    date: Date | string
    description: string
    createdAt?: Date | string
    user: UserFinanceManagerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionFinanceManagerUncheckedCreateInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    category?: string | null
    source?: string | null
    date: Date | string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFinanceManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFinanceManagerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionFinanceManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFinanceManagerCreateManyInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    category?: string | null
    source?: string | null
    date: Date | string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFinanceManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFinanceManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalFinanceManagerCreateInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    deadline: Date | string
    description: string
    createdAt?: Date | string
    user: UserFinanceManagerCreateNestedOneWithoutGoalsInput
  }

  export type GoalFinanceManagerUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    deadline: Date | string
    description: string
    createdAt?: Date | string
  }

  export type GoalFinanceManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFinanceManagerUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type GoalFinanceManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalFinanceManagerCreateManyInput = {
    id?: string
    userId: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    deadline: Date | string
    description: string
    createdAt?: Date | string
  }

  export type GoalFinanceManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalFinanceManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMentalWellnessCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    journals?: JournalMentalWellnessCreateNestedManyWithoutUserInput
    assessments?: AssessmentMentalWellnessCreateNestedManyWithoutUserInput
    feedbacks?: MeditationFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    journals?: JournalMentalWellnessUncheckedCreateNestedManyWithoutUserInput
    assessments?: AssessmentMentalWellnessUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: MeditationFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: JournalMentalWellnessUpdateManyWithoutUserNestedInput
    assessments?: AssessmentMentalWellnessUpdateManyWithoutUserNestedInput
    feedbacks?: MeditationFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserMentalWellnessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: JournalMentalWellnessUncheckedUpdateManyWithoutUserNestedInput
    assessments?: AssessmentMentalWellnessUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: MeditationFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserMentalWellnessCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
  }

  export type UserMentalWellnessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMentalWellnessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalMentalWellnessCreateInput = {
    id?: string
    mood: string
    entryText: string
    tags?: JournalMentalWellnessCreatetagsInput | string[]
    createdAt?: Date | string
    user: UserMentalWellnessCreateNestedOneWithoutJournalsInput
  }

  export type JournalMentalWellnessUncheckedCreateInput = {
    id?: string
    userId: string
    mood: string
    entryText: string
    tags?: JournalMentalWellnessCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type JournalMentalWellnessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserMentalWellnessUpdateOneRequiredWithoutJournalsNestedInput
  }

  export type JournalMentalWellnessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalMentalWellnessCreateManyInput = {
    id?: string
    userId: string
    mood: string
    entryText: string
    tags?: JournalMentalWellnessCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type JournalMentalWellnessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalMentalWellnessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentMentalWellnessCreateInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    result: string
    createdAt?: Date | string
    user: UserMentalWellnessCreateNestedOneWithoutAssessmentsInput
  }

  export type AssessmentMentalWellnessUncheckedCreateInput = {
    id?: string
    userId: string
    responses: JsonNullValueInput | InputJsonValue
    result: string
    createdAt?: Date | string
  }

  export type AssessmentMentalWellnessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserMentalWellnessUpdateOneRequiredWithoutAssessmentsNestedInput
  }

  export type AssessmentMentalWellnessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentMentalWellnessCreateManyInput = {
    id?: string
    userId: string
    responses: JsonNullValueInput | InputJsonValue
    result: string
    createdAt?: Date | string
  }

  export type AssessmentMentalWellnessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentMentalWellnessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationCreateInput = {
    id?: string
    title: string
    description: string
    audioUrl: string
    createdAt?: Date | string
    feedbacks?: MeditationFeedbackCreateNestedManyWithoutMeditationInput
  }

  export type MeditationUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    audioUrl: string
    createdAt?: Date | string
    feedbacks?: MeditationFeedbackUncheckedCreateNestedManyWithoutMeditationInput
  }

  export type MeditationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbacks?: MeditationFeedbackUpdateManyWithoutMeditationNestedInput
  }

  export type MeditationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedbacks?: MeditationFeedbackUncheckedUpdateManyWithoutMeditationNestedInput
  }

  export type MeditationCreateManyInput = {
    id?: string
    title: string
    description: string
    audioUrl: string
    createdAt?: Date | string
  }

  export type MeditationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserMentalWellnessCreateNestedOneWithoutFeedbacksInput
    meditation: MeditationCreateNestedOneWithoutFeedbacksInput
  }

  export type MeditationFeedbackUncheckedCreateInput = {
    id?: string
    meditationId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type MeditationFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserMentalWellnessUpdateOneRequiredWithoutFeedbacksNestedInput
    meditation?: MeditationUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type MeditationFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meditationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackCreateManyInput = {
    id?: string
    meditationId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type MeditationFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meditationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalMentalWellnessCreateInput = {
    id?: string
    name: string
    location: string
    contactInfo: string
    type: string
    createdAt?: Date | string
  }

  export type HospitalMentalWellnessUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    contactInfo: string
    type: string
    createdAt?: Date | string
  }

  export type HospitalMentalWellnessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalMentalWellnessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalMentalWellnessCreateManyInput = {
    id?: string
    name: string
    location: string
    contactInfo: string
    type: string
    createdAt?: Date | string
  }

  export type HospitalMentalWellnessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalMentalWellnessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PostDIYHomesListRelationFilter = {
    every?: PostDIYHomesWhereInput
    some?: PostDIYHomesWhereInput
    none?: PostDIYHomesWhereInput
  }

  export type ReviewDIYHomesListRelationFilter = {
    every?: ReviewDIYHomesWhereInput
    some?: ReviewDIYHomesWhereInput
    none?: ReviewDIYHomesWhereInput
  }

  export type LikeDIYHomesListRelationFilter = {
    every?: LikeDIYHomesWhereInput
    some?: LikeDIYHomesWhereInput
    none?: LikeDIYHomesWhereInput
  }

  export type BookmarkDIYHomesListRelationFilter = {
    every?: BookmarkDIYHomesWhereInput
    some?: BookmarkDIYHomesWhereInput
    none?: BookmarkDIYHomesWhereInput
  }

  export type ReportDIYHomesListRelationFilter = {
    every?: ReportDIYHomesWhereInput
    some?: ReportDIYHomesWhereInput
    none?: ReportDIYHomesWhereInput
  }

  export type PostDIYHomesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewDIYHomesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeDIYHomesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarkDIYHomesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportDIYHomesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDIYHomesCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserDIYHomesMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserDIYHomesMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserDIYHomesScalarRelationFilter = {
    is?: UserDIYHomesWhereInput
    isNot?: UserDIYHomesWhereInput
  }

  export type PostDIYHomesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostDIYHomesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostDIYHomesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PostDIYHomesScalarRelationFilter = {
    is?: PostDIYHomesWhereInput
    isNot?: PostDIYHomesWhereInput
  }

  export type ReviewDIYHomesCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewDIYHomesAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewDIYHomesMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewDIYHomesMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewDIYHomesSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type LikeDIYHomesPostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type LikeDIYHomesCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeDIYHomesMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeDIYHomesMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkDIYHomesPostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type BookmarkDIYHomesCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkDIYHomesMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkDIYHomesMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PostDIYHomesNullableScalarRelationFilter = {
    is?: PostDIYHomesWhereInput | null
    isNot?: PostDIYHomesWhereInput | null
  }

  export type ReviewDIYHomesNullableScalarRelationFilter = {
    is?: ReviewDIYHomesWhereInput | null
    isNot?: ReviewDIYHomesWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReportDIYHomesCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportDIYHomesMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportDIYHomesMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PlaceUrbanExplorerListRelationFilter = {
    every?: PlaceUrbanExplorerWhereInput
    some?: PlaceUrbanExplorerWhereInput
    none?: PlaceUrbanExplorerWhereInput
  }

  export type ReviewUrbanExplorerListRelationFilter = {
    every?: ReviewUrbanExplorerWhereInput
    some?: ReviewUrbanExplorerWhereInput
    none?: ReviewUrbanExplorerWhereInput
  }

  export type LikeUrbanExplorerListRelationFilter = {
    every?: LikeUrbanExplorerWhereInput
    some?: LikeUrbanExplorerWhereInput
    none?: LikeUrbanExplorerWhereInput
  }

  export type BookmarkUrbanExplorerListRelationFilter = {
    every?: BookmarkUrbanExplorerWhereInput
    some?: BookmarkUrbanExplorerWhereInput
    none?: BookmarkUrbanExplorerWhereInput
  }

  export type ReportUrbanExplorerListRelationFilter = {
    every?: ReportUrbanExplorerWhereInput
    some?: ReportUrbanExplorerWhereInput
    none?: ReportUrbanExplorerWhereInput
  }

  export type PlaceUrbanExplorerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewUrbanExplorerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeUrbanExplorerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarkUrbanExplorerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportUrbanExplorerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserUrbanExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserUrbanExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserUrbanExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserUrbanExplorerScalarRelationFilter = {
    is?: UserUrbanExplorerWhereInput
    isNot?: UserUrbanExplorerWhereInput
  }

  export type PlaceUrbanExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
  }

  export type PlaceUrbanExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
  }

  export type PlaceUrbanExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PlaceUrbanExplorerScalarRelationFilter = {
    is?: PlaceUrbanExplorerWhereInput
    isNot?: PlaceUrbanExplorerWhereInput
  }

  export type ReviewUrbanExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewUrbanExplorerAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewUrbanExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewUrbanExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewUrbanExplorerSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type LikeUrbanExplorerPlaceIdUserIdCompoundUniqueInput = {
    placeId: string
    userId: string
  }

  export type LikeUrbanExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeUrbanExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeUrbanExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkUrbanExplorerPlaceIdUserIdCompoundUniqueInput = {
    placeId: string
    userId: string
  }

  export type BookmarkUrbanExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkUrbanExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkUrbanExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PlaceUrbanExplorerNullableScalarRelationFilter = {
    is?: PlaceUrbanExplorerWhereInput | null
    isNot?: PlaceUrbanExplorerWhereInput | null
  }

  export type ReviewUrbanExplorerNullableScalarRelationFilter = {
    is?: ReviewUrbanExplorerWhereInput | null
    isNot?: ReviewUrbanExplorerWhereInput | null
  }

  export type ReportUrbanExplorerCountOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportUrbanExplorerMaxOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportUrbanExplorerMinOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieFoodListRelationFilter = {
    every?: FoodieFoodWhereInput
    some?: FoodieFoodWhereInput
    none?: FoodieFoodWhereInput
  }

  export type FoodieLocationListRelationFilter = {
    every?: FoodieLocationWhereInput
    some?: FoodieLocationWhereInput
    none?: FoodieLocationWhereInput
  }

  export type FoodieReviewListRelationFilter = {
    every?: FoodieReviewWhereInput
    some?: FoodieReviewWhereInput
    none?: FoodieReviewWhereInput
  }

  export type FoodieLikeListRelationFilter = {
    every?: FoodieLikeWhereInput
    some?: FoodieLikeWhereInput
    none?: FoodieLikeWhereInput
  }

  export type FoodieFoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodieLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodieReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodieLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFoodieCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFoodieMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFoodieMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFoodieScalarRelationFilter = {
    is?: UserFoodieWhereInput
    isNot?: UserFoodieWhereInput
  }

  export type FoodieFoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cuisine?: SortOrder
    origin?: SortOrder
    description?: SortOrder
    submittedBy?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieFoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cuisine?: SortOrder
    origin?: SortOrder
    description?: SortOrder
    submittedBy?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieFoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cuisine?: SortOrder
    origin?: SortOrder
    description?: SortOrder
    submittedBy?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieFoodScalarRelationFilter = {
    is?: FoodieFoodWhereInput
    isNot?: FoodieFoodWhereInput
  }

  export type FoodieLocationCountOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieLocationMinOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    locationName?: SortOrder
    address?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieReviewCountOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FoodieReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieReviewMinOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FoodieLikeFoodIdUserIdCompoundUniqueInput = {
    foodId: string
    userId: string
  }

  export type FoodieLikeCountOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodieLikeMinOrderByAggregateInput = {
    id?: SortOrder
    foodId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PetPetLoverListRelationFilter = {
    every?: PetPetLoverWhereInput
    some?: PetPetLoverWhereInput
    none?: PetPetLoverWhereInput
  }

  export type AppointmentPetLoverListRelationFilter = {
    every?: AppointmentPetLoverWhereInput
    some?: AppointmentPetLoverWhereInput
    none?: AppointmentPetLoverWhereInput
  }

  export type PetPetLoverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentPetLoverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPetLoverCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPetLoverMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPetLoverMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPetLoverScalarRelationFilter = {
    is?: UserPetLoverWhereInput
    isNot?: UserPetLoverWhereInput
  }

  export type VaccinationPetLoverListRelationFilter = {
    every?: VaccinationPetLoverWhereInput
    some?: VaccinationPetLoverWhereInput
    none?: VaccinationPetLoverWhereInput
  }

  export type VaccinationPetLoverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PetPetLoverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petName?: SortOrder
    species?: SortOrder
    breed?: SortOrder
    age?: SortOrder
    medicalHistory?: SortOrder
    createdAt?: SortOrder
  }

  export type PetPetLoverAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type PetPetLoverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petName?: SortOrder
    species?: SortOrder
    breed?: SortOrder
    age?: SortOrder
    medicalHistory?: SortOrder
    createdAt?: SortOrder
  }

  export type PetPetLoverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petName?: SortOrder
    species?: SortOrder
    breed?: SortOrder
    age?: SortOrder
    medicalHistory?: SortOrder
    createdAt?: SortOrder
  }

  export type PetPetLoverSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type PetPetLoverScalarRelationFilter = {
    is?: PetPetLoverWhereInput
    isNot?: PetPetLoverWhereInput
  }

  export type AppointmentPetLoverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    appointmentType?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentPetLoverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    appointmentType?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentPetLoverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    petId?: SortOrder
    appointmentType?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type VaccinationPetLoverCountOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineName?: SortOrder
    dateAdministered?: SortOrder
    nextDueDate?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationPetLoverMaxOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineName?: SortOrder
    dateAdministered?: SortOrder
    nextDueDate?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationPetLoverMinOrderByAggregateInput = {
    id?: SortOrder
    petId?: SortOrder
    vaccineName?: SortOrder
    dateAdministered?: SortOrder
    nextDueDate?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClinicPetLoverCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ClinicPetLoverMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ClinicPetLoverMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type StorePetLoverCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type StorePetLoverMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type StorePetLoverMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionAppointmentListRelationFilter = {
    every?: ElderlyCareCompanionAppointmentWhereInput
    some?: ElderlyCareCompanionAppointmentWhereInput
    none?: ElderlyCareCompanionAppointmentWhereInput
  }

  export type ElderlyCareCompanionRecordListRelationFilter = {
    every?: ElderlyCareCompanionRecordWhereInput
    some?: ElderlyCareCompanionRecordWhereInput
    none?: ElderlyCareCompanionRecordWhereInput
  }

  export type ElderlyCareCompanionMedicationTrackingListRelationFilter = {
    every?: ElderlyCareCompanionMedicationTrackingWhereInput
    some?: ElderlyCareCompanionMedicationTrackingWhereInput
    none?: ElderlyCareCompanionMedicationTrackingWhereInput
  }

  export type ElderlyCareCompanionAppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElderlyCareCompanionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElderlyCareCompanionMedicationTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserElderlyCareCompanionCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserElderlyCareCompanionMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserElderlyCareCompanionMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserElderlyCareCompanionScalarRelationFilter = {
    is?: UserElderlyCareCompanionWhereInput
    isNot?: UserElderlyCareCompanionWhereInput
  }

  export type ElderlyCareCompanionAppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    medicationDetails?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionAppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    medicationDetails?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionAppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    dateTime?: SortOrder
    location?: SortOrder
    medicationDetails?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionClinicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionClinicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionStoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionStoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    details?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    details?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    details?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type ElderlyCareCompanionAppointmentScalarRelationFilter = {
    is?: ElderlyCareCompanionAppointmentWhereInput
    isNot?: ElderlyCareCompanionAppointmentWhereInput
  }

  export type ElderlyCareCompanionMedicationTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dateTime?: SortOrder
  }

  export type ElderlyCareCompanionMedicationTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dateTime?: SortOrder
  }

  export type ElderlyCareCompanionMedicationTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    medicationId?: SortOrder
    status?: SortOrder
    dateTime?: SortOrder
  }

  export type PlatformEduSeekerListRelationFilter = {
    every?: PlatformEduSeekerWhereInput
    some?: PlatformEduSeekerWhereInput
    none?: PlatformEduSeekerWhereInput
  }

  export type ReviewEduSeekerListRelationFilter = {
    every?: ReviewEduSeekerWhereInput
    some?: ReviewEduSeekerWhereInput
    none?: ReviewEduSeekerWhereInput
  }

  export type PlatformEduSeekerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewEduSeekerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEduSeekerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserEduSeekerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserEduSeekerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserEduSeekerScalarRelationFilter = {
    is?: UserEduSeekerWhereInput
    isNot?: UserEduSeekerWhereInput
  }

  export type PlatformEduSeekerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    url?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
  }

  export type PlatformEduSeekerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    url?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
  }

  export type PlatformEduSeekerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    url?: SortOrder
    submittedBy?: SortOrder
    createdAt?: SortOrder
    validated?: SortOrder
  }

  export type PlatformEduSeekerScalarRelationFilter = {
    is?: PlatformEduSeekerWhereInput
    isNot?: PlatformEduSeekerWhereInput
  }

  export type ReviewEduSeekerCountOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewEduSeekerAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewEduSeekerMaxOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewEduSeekerMinOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    validated?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewEduSeekerSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TransactionFinanceManagerListRelationFilter = {
    every?: TransactionFinanceManagerWhereInput
    some?: TransactionFinanceManagerWhereInput
    none?: TransactionFinanceManagerWhereInput
  }

  export type GoalFinanceManagerListRelationFilter = {
    every?: GoalFinanceManagerWhereInput
    some?: GoalFinanceManagerWhereInput
    none?: GoalFinanceManagerWhereInput
  }

  export type TransactionFinanceManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoalFinanceManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFinanceManagerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFinanceManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFinanceManagerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserFinanceManagerScalarRelationFilter = {
    is?: UserFinanceManagerWhereInput
    isNot?: UserFinanceManagerWhereInput
  }

  export type TransactionFinanceManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category?: SortOrder
    source?: SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionFinanceManagerAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionFinanceManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category?: SortOrder
    source?: SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionFinanceManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    category?: SortOrder
    source?: SortOrder
    date?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionFinanceManagerSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type GoalFinanceManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type GoalFinanceManagerAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
  }

  export type GoalFinanceManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type GoalFinanceManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    targetAmount?: SortOrder
    deadline?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type GoalFinanceManagerSumOrderByAggregateInput = {
    targetAmount?: SortOrder
  }

  export type JournalMentalWellnessListRelationFilter = {
    every?: JournalMentalWellnessWhereInput
    some?: JournalMentalWellnessWhereInput
    none?: JournalMentalWellnessWhereInput
  }

  export type AssessmentMentalWellnessListRelationFilter = {
    every?: AssessmentMentalWellnessWhereInput
    some?: AssessmentMentalWellnessWhereInput
    none?: AssessmentMentalWellnessWhereInput
  }

  export type MeditationFeedbackListRelationFilter = {
    every?: MeditationFeedbackWhereInput
    some?: MeditationFeedbackWhereInput
    none?: MeditationFeedbackWhereInput
  }

  export type JournalMentalWellnessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentMentalWellnessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeditationFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMentalWellnessCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMentalWellnessMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMentalWellnessMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserMentalWellnessScalarRelationFilter = {
    is?: UserMentalWellnessWhereInput
    isNot?: UserMentalWellnessWhereInput
  }

  export type JournalMentalWellnessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    entryText?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalMentalWellnessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    entryText?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalMentalWellnessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mood?: SortOrder
    entryText?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AssessmentMentalWellnessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    responses?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentMentalWellnessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentMentalWellnessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type MeditationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationScalarRelationFilter = {
    is?: MeditationWhereInput
    isNot?: MeditationWhereInput
  }

  export type MeditationFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    meditationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationFeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type MeditationFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    meditationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    meditationId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type MeditationFeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type HospitalMentalWellnessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type HospitalMentalWellnessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type HospitalMentalWellnessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostDIYHomesCreateNestedManyWithoutUserInput = {
    create?: XOR<PostDIYHomesCreateWithoutUserInput, PostDIYHomesUncheckedCreateWithoutUserInput> | PostDIYHomesCreateWithoutUserInput[] | PostDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutUserInput | PostDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: PostDIYHomesCreateManyUserInputEnvelope
    connect?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
  }

  export type ReviewDIYHomesCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutUserInput, ReviewDIYHomesUncheckedCreateWithoutUserInput> | ReviewDIYHomesCreateWithoutUserInput[] | ReviewDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutUserInput | ReviewDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: ReviewDIYHomesCreateManyUserInputEnvelope
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
  }

  export type LikeDIYHomesCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeDIYHomesCreateWithoutUserInput, LikeDIYHomesUncheckedCreateWithoutUserInput> | LikeDIYHomesCreateWithoutUserInput[] | LikeDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutUserInput | LikeDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: LikeDIYHomesCreateManyUserInputEnvelope
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
  }

  export type BookmarkDIYHomesCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutUserInput, BookmarkDIYHomesUncheckedCreateWithoutUserInput> | BookmarkDIYHomesCreateWithoutUserInput[] | BookmarkDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutUserInput | BookmarkDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkDIYHomesCreateManyUserInputEnvelope
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
  }

  export type ReportDIYHomesCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportDIYHomesCreateWithoutUserInput, ReportDIYHomesUncheckedCreateWithoutUserInput> | ReportDIYHomesCreateWithoutUserInput[] | ReportDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutUserInput | ReportDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: ReportDIYHomesCreateManyUserInputEnvelope
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
  }

  export type PostDIYHomesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostDIYHomesCreateWithoutUserInput, PostDIYHomesUncheckedCreateWithoutUserInput> | PostDIYHomesCreateWithoutUserInput[] | PostDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutUserInput | PostDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: PostDIYHomesCreateManyUserInputEnvelope
    connect?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
  }

  export type ReviewDIYHomesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutUserInput, ReviewDIYHomesUncheckedCreateWithoutUserInput> | ReviewDIYHomesCreateWithoutUserInput[] | ReviewDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutUserInput | ReviewDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: ReviewDIYHomesCreateManyUserInputEnvelope
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
  }

  export type LikeDIYHomesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeDIYHomesCreateWithoutUserInput, LikeDIYHomesUncheckedCreateWithoutUserInput> | LikeDIYHomesCreateWithoutUserInput[] | LikeDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutUserInput | LikeDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: LikeDIYHomesCreateManyUserInputEnvelope
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
  }

  export type BookmarkDIYHomesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutUserInput, BookmarkDIYHomesUncheckedCreateWithoutUserInput> | BookmarkDIYHomesCreateWithoutUserInput[] | BookmarkDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutUserInput | BookmarkDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkDIYHomesCreateManyUserInputEnvelope
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
  }

  export type ReportDIYHomesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportDIYHomesCreateWithoutUserInput, ReportDIYHomesUncheckedCreateWithoutUserInput> | ReportDIYHomesCreateWithoutUserInput[] | ReportDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutUserInput | ReportDIYHomesCreateOrConnectWithoutUserInput[]
    createMany?: ReportDIYHomesCreateManyUserInputEnvelope
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PostDIYHomesUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostDIYHomesCreateWithoutUserInput, PostDIYHomesUncheckedCreateWithoutUserInput> | PostDIYHomesCreateWithoutUserInput[] | PostDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutUserInput | PostDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: PostDIYHomesUpsertWithWhereUniqueWithoutUserInput | PostDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostDIYHomesCreateManyUserInputEnvelope
    set?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    disconnect?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    delete?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    connect?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    update?: PostDIYHomesUpdateWithWhereUniqueWithoutUserInput | PostDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostDIYHomesUpdateManyWithWhereWithoutUserInput | PostDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostDIYHomesScalarWhereInput | PostDIYHomesScalarWhereInput[]
  }

  export type ReviewDIYHomesUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutUserInput, ReviewDIYHomesUncheckedCreateWithoutUserInput> | ReviewDIYHomesCreateWithoutUserInput[] | ReviewDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutUserInput | ReviewDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: ReviewDIYHomesUpsertWithWhereUniqueWithoutUserInput | ReviewDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewDIYHomesCreateManyUserInputEnvelope
    set?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    disconnect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    delete?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    update?: ReviewDIYHomesUpdateWithWhereUniqueWithoutUserInput | ReviewDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewDIYHomesUpdateManyWithWhereWithoutUserInput | ReviewDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewDIYHomesScalarWhereInput | ReviewDIYHomesScalarWhereInput[]
  }

  export type LikeDIYHomesUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeDIYHomesCreateWithoutUserInput, LikeDIYHomesUncheckedCreateWithoutUserInput> | LikeDIYHomesCreateWithoutUserInput[] | LikeDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutUserInput | LikeDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: LikeDIYHomesUpsertWithWhereUniqueWithoutUserInput | LikeDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeDIYHomesCreateManyUserInputEnvelope
    set?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    disconnect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    delete?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    update?: LikeDIYHomesUpdateWithWhereUniqueWithoutUserInput | LikeDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeDIYHomesUpdateManyWithWhereWithoutUserInput | LikeDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeDIYHomesScalarWhereInput | LikeDIYHomesScalarWhereInput[]
  }

  export type BookmarkDIYHomesUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutUserInput, BookmarkDIYHomesUncheckedCreateWithoutUserInput> | BookmarkDIYHomesCreateWithoutUserInput[] | BookmarkDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutUserInput | BookmarkDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkDIYHomesUpsertWithWhereUniqueWithoutUserInput | BookmarkDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkDIYHomesCreateManyUserInputEnvelope
    set?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    disconnect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    delete?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    update?: BookmarkDIYHomesUpdateWithWhereUniqueWithoutUserInput | BookmarkDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkDIYHomesUpdateManyWithWhereWithoutUserInput | BookmarkDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkDIYHomesScalarWhereInput | BookmarkDIYHomesScalarWhereInput[]
  }

  export type ReportDIYHomesUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportDIYHomesCreateWithoutUserInput, ReportDIYHomesUncheckedCreateWithoutUserInput> | ReportDIYHomesCreateWithoutUserInput[] | ReportDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutUserInput | ReportDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: ReportDIYHomesUpsertWithWhereUniqueWithoutUserInput | ReportDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportDIYHomesCreateManyUserInputEnvelope
    set?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    disconnect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    delete?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    update?: ReportDIYHomesUpdateWithWhereUniqueWithoutUserInput | ReportDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportDIYHomesUpdateManyWithWhereWithoutUserInput | ReportDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
  }

  export type PostDIYHomesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostDIYHomesCreateWithoutUserInput, PostDIYHomesUncheckedCreateWithoutUserInput> | PostDIYHomesCreateWithoutUserInput[] | PostDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutUserInput | PostDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: PostDIYHomesUpsertWithWhereUniqueWithoutUserInput | PostDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostDIYHomesCreateManyUserInputEnvelope
    set?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    disconnect?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    delete?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    connect?: PostDIYHomesWhereUniqueInput | PostDIYHomesWhereUniqueInput[]
    update?: PostDIYHomesUpdateWithWhereUniqueWithoutUserInput | PostDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostDIYHomesUpdateManyWithWhereWithoutUserInput | PostDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostDIYHomesScalarWhereInput | PostDIYHomesScalarWhereInput[]
  }

  export type ReviewDIYHomesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutUserInput, ReviewDIYHomesUncheckedCreateWithoutUserInput> | ReviewDIYHomesCreateWithoutUserInput[] | ReviewDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutUserInput | ReviewDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: ReviewDIYHomesUpsertWithWhereUniqueWithoutUserInput | ReviewDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewDIYHomesCreateManyUserInputEnvelope
    set?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    disconnect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    delete?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    update?: ReviewDIYHomesUpdateWithWhereUniqueWithoutUserInput | ReviewDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewDIYHomesUpdateManyWithWhereWithoutUserInput | ReviewDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewDIYHomesScalarWhereInput | ReviewDIYHomesScalarWhereInput[]
  }

  export type LikeDIYHomesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeDIYHomesCreateWithoutUserInput, LikeDIYHomesUncheckedCreateWithoutUserInput> | LikeDIYHomesCreateWithoutUserInput[] | LikeDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutUserInput | LikeDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: LikeDIYHomesUpsertWithWhereUniqueWithoutUserInput | LikeDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeDIYHomesCreateManyUserInputEnvelope
    set?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    disconnect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    delete?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    update?: LikeDIYHomesUpdateWithWhereUniqueWithoutUserInput | LikeDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeDIYHomesUpdateManyWithWhereWithoutUserInput | LikeDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeDIYHomesScalarWhereInput | LikeDIYHomesScalarWhereInput[]
  }

  export type BookmarkDIYHomesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutUserInput, BookmarkDIYHomesUncheckedCreateWithoutUserInput> | BookmarkDIYHomesCreateWithoutUserInput[] | BookmarkDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutUserInput | BookmarkDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkDIYHomesUpsertWithWhereUniqueWithoutUserInput | BookmarkDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkDIYHomesCreateManyUserInputEnvelope
    set?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    disconnect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    delete?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    update?: BookmarkDIYHomesUpdateWithWhereUniqueWithoutUserInput | BookmarkDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkDIYHomesUpdateManyWithWhereWithoutUserInput | BookmarkDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkDIYHomesScalarWhereInput | BookmarkDIYHomesScalarWhereInput[]
  }

  export type ReportDIYHomesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportDIYHomesCreateWithoutUserInput, ReportDIYHomesUncheckedCreateWithoutUserInput> | ReportDIYHomesCreateWithoutUserInput[] | ReportDIYHomesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutUserInput | ReportDIYHomesCreateOrConnectWithoutUserInput[]
    upsert?: ReportDIYHomesUpsertWithWhereUniqueWithoutUserInput | ReportDIYHomesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportDIYHomesCreateManyUserInputEnvelope
    set?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    disconnect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    delete?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    update?: ReportDIYHomesUpdateWithWhereUniqueWithoutUserInput | ReportDIYHomesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportDIYHomesUpdateManyWithWhereWithoutUserInput | ReportDIYHomesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
  }

  export type UserDIYHomesCreateNestedOneWithoutPostDIYHomesInput = {
    create?: XOR<UserDIYHomesCreateWithoutPostDIYHomesInput, UserDIYHomesUncheckedCreateWithoutPostDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutPostDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
  }

  export type ReviewDIYHomesCreateNestedManyWithoutPostInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutPostInput, ReviewDIYHomesUncheckedCreateWithoutPostInput> | ReviewDIYHomesCreateWithoutPostInput[] | ReviewDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutPostInput | ReviewDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: ReviewDIYHomesCreateManyPostInputEnvelope
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
  }

  export type BookmarkDIYHomesCreateNestedManyWithoutPostInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutPostInput, BookmarkDIYHomesUncheckedCreateWithoutPostInput> | BookmarkDIYHomesCreateWithoutPostInput[] | BookmarkDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutPostInput | BookmarkDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: BookmarkDIYHomesCreateManyPostInputEnvelope
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
  }

  export type LikeDIYHomesCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeDIYHomesCreateWithoutPostInput, LikeDIYHomesUncheckedCreateWithoutPostInput> | LikeDIYHomesCreateWithoutPostInput[] | LikeDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutPostInput | LikeDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: LikeDIYHomesCreateManyPostInputEnvelope
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
  }

  export type ReportDIYHomesCreateNestedManyWithoutPostInput = {
    create?: XOR<ReportDIYHomesCreateWithoutPostInput, ReportDIYHomesUncheckedCreateWithoutPostInput> | ReportDIYHomesCreateWithoutPostInput[] | ReportDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutPostInput | ReportDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: ReportDIYHomesCreateManyPostInputEnvelope
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
  }

  export type ReviewDIYHomesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutPostInput, ReviewDIYHomesUncheckedCreateWithoutPostInput> | ReviewDIYHomesCreateWithoutPostInput[] | ReviewDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutPostInput | ReviewDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: ReviewDIYHomesCreateManyPostInputEnvelope
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
  }

  export type BookmarkDIYHomesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutPostInput, BookmarkDIYHomesUncheckedCreateWithoutPostInput> | BookmarkDIYHomesCreateWithoutPostInput[] | BookmarkDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutPostInput | BookmarkDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: BookmarkDIYHomesCreateManyPostInputEnvelope
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
  }

  export type LikeDIYHomesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<LikeDIYHomesCreateWithoutPostInput, LikeDIYHomesUncheckedCreateWithoutPostInput> | LikeDIYHomesCreateWithoutPostInput[] | LikeDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutPostInput | LikeDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: LikeDIYHomesCreateManyPostInputEnvelope
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
  }

  export type ReportDIYHomesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReportDIYHomesCreateWithoutPostInput, ReportDIYHomesUncheckedCreateWithoutPostInput> | ReportDIYHomesCreateWithoutPostInput[] | ReportDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutPostInput | ReportDIYHomesCreateOrConnectWithoutPostInput[]
    createMany?: ReportDIYHomesCreateManyPostInputEnvelope
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
  }

  export type UserDIYHomesUpdateOneRequiredWithoutPostDIYHomesNestedInput = {
    create?: XOR<UserDIYHomesCreateWithoutPostDIYHomesInput, UserDIYHomesUncheckedCreateWithoutPostDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutPostDIYHomesInput
    upsert?: UserDIYHomesUpsertWithoutPostDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
    update?: XOR<XOR<UserDIYHomesUpdateToOneWithWhereWithoutPostDIYHomesInput, UserDIYHomesUpdateWithoutPostDIYHomesInput>, UserDIYHomesUncheckedUpdateWithoutPostDIYHomesInput>
  }

  export type ReviewDIYHomesUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutPostInput, ReviewDIYHomesUncheckedCreateWithoutPostInput> | ReviewDIYHomesCreateWithoutPostInput[] | ReviewDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutPostInput | ReviewDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: ReviewDIYHomesUpsertWithWhereUniqueWithoutPostInput | ReviewDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReviewDIYHomesCreateManyPostInputEnvelope
    set?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    disconnect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    delete?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    update?: ReviewDIYHomesUpdateWithWhereUniqueWithoutPostInput | ReviewDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReviewDIYHomesUpdateManyWithWhereWithoutPostInput | ReviewDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReviewDIYHomesScalarWhereInput | ReviewDIYHomesScalarWhereInput[]
  }

  export type BookmarkDIYHomesUpdateManyWithoutPostNestedInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutPostInput, BookmarkDIYHomesUncheckedCreateWithoutPostInput> | BookmarkDIYHomesCreateWithoutPostInput[] | BookmarkDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutPostInput | BookmarkDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: BookmarkDIYHomesUpsertWithWhereUniqueWithoutPostInput | BookmarkDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BookmarkDIYHomesCreateManyPostInputEnvelope
    set?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    disconnect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    delete?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    update?: BookmarkDIYHomesUpdateWithWhereUniqueWithoutPostInput | BookmarkDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BookmarkDIYHomesUpdateManyWithWhereWithoutPostInput | BookmarkDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BookmarkDIYHomesScalarWhereInput | BookmarkDIYHomesScalarWhereInput[]
  }

  export type LikeDIYHomesUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeDIYHomesCreateWithoutPostInput, LikeDIYHomesUncheckedCreateWithoutPostInput> | LikeDIYHomesCreateWithoutPostInput[] | LikeDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutPostInput | LikeDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: LikeDIYHomesUpsertWithWhereUniqueWithoutPostInput | LikeDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeDIYHomesCreateManyPostInputEnvelope
    set?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    disconnect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    delete?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    update?: LikeDIYHomesUpdateWithWhereUniqueWithoutPostInput | LikeDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeDIYHomesUpdateManyWithWhereWithoutPostInput | LikeDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeDIYHomesScalarWhereInput | LikeDIYHomesScalarWhereInput[]
  }

  export type ReportDIYHomesUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReportDIYHomesCreateWithoutPostInput, ReportDIYHomesUncheckedCreateWithoutPostInput> | ReportDIYHomesCreateWithoutPostInput[] | ReportDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutPostInput | ReportDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: ReportDIYHomesUpsertWithWhereUniqueWithoutPostInput | ReportDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReportDIYHomesCreateManyPostInputEnvelope
    set?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    disconnect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    delete?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    update?: ReportDIYHomesUpdateWithWhereUniqueWithoutPostInput | ReportDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReportDIYHomesUpdateManyWithWhereWithoutPostInput | ReportDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
  }

  export type ReviewDIYHomesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutPostInput, ReviewDIYHomesUncheckedCreateWithoutPostInput> | ReviewDIYHomesCreateWithoutPostInput[] | ReviewDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutPostInput | ReviewDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: ReviewDIYHomesUpsertWithWhereUniqueWithoutPostInput | ReviewDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReviewDIYHomesCreateManyPostInputEnvelope
    set?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    disconnect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    delete?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    connect?: ReviewDIYHomesWhereUniqueInput | ReviewDIYHomesWhereUniqueInput[]
    update?: ReviewDIYHomesUpdateWithWhereUniqueWithoutPostInput | ReviewDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReviewDIYHomesUpdateManyWithWhereWithoutPostInput | ReviewDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReviewDIYHomesScalarWhereInput | ReviewDIYHomesScalarWhereInput[]
  }

  export type BookmarkDIYHomesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<BookmarkDIYHomesCreateWithoutPostInput, BookmarkDIYHomesUncheckedCreateWithoutPostInput> | BookmarkDIYHomesCreateWithoutPostInput[] | BookmarkDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: BookmarkDIYHomesCreateOrConnectWithoutPostInput | BookmarkDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: BookmarkDIYHomesUpsertWithWhereUniqueWithoutPostInput | BookmarkDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: BookmarkDIYHomesCreateManyPostInputEnvelope
    set?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    disconnect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    delete?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    connect?: BookmarkDIYHomesWhereUniqueInput | BookmarkDIYHomesWhereUniqueInput[]
    update?: BookmarkDIYHomesUpdateWithWhereUniqueWithoutPostInput | BookmarkDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: BookmarkDIYHomesUpdateManyWithWhereWithoutPostInput | BookmarkDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: BookmarkDIYHomesScalarWhereInput | BookmarkDIYHomesScalarWhereInput[]
  }

  export type LikeDIYHomesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<LikeDIYHomesCreateWithoutPostInput, LikeDIYHomesUncheckedCreateWithoutPostInput> | LikeDIYHomesCreateWithoutPostInput[] | LikeDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: LikeDIYHomesCreateOrConnectWithoutPostInput | LikeDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: LikeDIYHomesUpsertWithWhereUniqueWithoutPostInput | LikeDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: LikeDIYHomesCreateManyPostInputEnvelope
    set?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    disconnect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    delete?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    connect?: LikeDIYHomesWhereUniqueInput | LikeDIYHomesWhereUniqueInput[]
    update?: LikeDIYHomesUpdateWithWhereUniqueWithoutPostInput | LikeDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: LikeDIYHomesUpdateManyWithWhereWithoutPostInput | LikeDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: LikeDIYHomesScalarWhereInput | LikeDIYHomesScalarWhereInput[]
  }

  export type ReportDIYHomesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReportDIYHomesCreateWithoutPostInput, ReportDIYHomesUncheckedCreateWithoutPostInput> | ReportDIYHomesCreateWithoutPostInput[] | ReportDIYHomesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutPostInput | ReportDIYHomesCreateOrConnectWithoutPostInput[]
    upsert?: ReportDIYHomesUpsertWithWhereUniqueWithoutPostInput | ReportDIYHomesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReportDIYHomesCreateManyPostInputEnvelope
    set?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    disconnect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    delete?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    update?: ReportDIYHomesUpdateWithWhereUniqueWithoutPostInput | ReportDIYHomesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReportDIYHomesUpdateManyWithWhereWithoutPostInput | ReportDIYHomesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
  }

  export type UserDIYHomesCreateNestedOneWithoutReviewDIYHomesInput = {
    create?: XOR<UserDIYHomesCreateWithoutReviewDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReviewDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutReviewDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
  }

  export type PostDIYHomesCreateNestedOneWithoutReviewsInput = {
    create?: XOR<PostDIYHomesCreateWithoutReviewsInput, PostDIYHomesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutReviewsInput
    connect?: PostDIYHomesWhereUniqueInput
  }

  export type ReportDIYHomesCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReportDIYHomesCreateWithoutReviewInput, ReportDIYHomesUncheckedCreateWithoutReviewInput> | ReportDIYHomesCreateWithoutReviewInput[] | ReportDIYHomesUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutReviewInput | ReportDIYHomesCreateOrConnectWithoutReviewInput[]
    createMany?: ReportDIYHomesCreateManyReviewInputEnvelope
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
  }

  export type ReportDIYHomesUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReportDIYHomesCreateWithoutReviewInput, ReportDIYHomesUncheckedCreateWithoutReviewInput> | ReportDIYHomesCreateWithoutReviewInput[] | ReportDIYHomesUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutReviewInput | ReportDIYHomesCreateOrConnectWithoutReviewInput[]
    createMany?: ReportDIYHomesCreateManyReviewInputEnvelope
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserDIYHomesUpdateOneRequiredWithoutReviewDIYHomesNestedInput = {
    create?: XOR<UserDIYHomesCreateWithoutReviewDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReviewDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutReviewDIYHomesInput
    upsert?: UserDIYHomesUpsertWithoutReviewDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
    update?: XOR<XOR<UserDIYHomesUpdateToOneWithWhereWithoutReviewDIYHomesInput, UserDIYHomesUpdateWithoutReviewDIYHomesInput>, UserDIYHomesUncheckedUpdateWithoutReviewDIYHomesInput>
  }

  export type PostDIYHomesUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<PostDIYHomesCreateWithoutReviewsInput, PostDIYHomesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutReviewsInput
    upsert?: PostDIYHomesUpsertWithoutReviewsInput
    connect?: PostDIYHomesWhereUniqueInput
    update?: XOR<XOR<PostDIYHomesUpdateToOneWithWhereWithoutReviewsInput, PostDIYHomesUpdateWithoutReviewsInput>, PostDIYHomesUncheckedUpdateWithoutReviewsInput>
  }

  export type ReportDIYHomesUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReportDIYHomesCreateWithoutReviewInput, ReportDIYHomesUncheckedCreateWithoutReviewInput> | ReportDIYHomesCreateWithoutReviewInput[] | ReportDIYHomesUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutReviewInput | ReportDIYHomesCreateOrConnectWithoutReviewInput[]
    upsert?: ReportDIYHomesUpsertWithWhereUniqueWithoutReviewInput | ReportDIYHomesUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReportDIYHomesCreateManyReviewInputEnvelope
    set?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    disconnect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    delete?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    update?: ReportDIYHomesUpdateWithWhereUniqueWithoutReviewInput | ReportDIYHomesUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReportDIYHomesUpdateManyWithWhereWithoutReviewInput | ReportDIYHomesUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
  }

  export type ReportDIYHomesUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReportDIYHomesCreateWithoutReviewInput, ReportDIYHomesUncheckedCreateWithoutReviewInput> | ReportDIYHomesCreateWithoutReviewInput[] | ReportDIYHomesUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportDIYHomesCreateOrConnectWithoutReviewInput | ReportDIYHomesCreateOrConnectWithoutReviewInput[]
    upsert?: ReportDIYHomesUpsertWithWhereUniqueWithoutReviewInput | ReportDIYHomesUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReportDIYHomesCreateManyReviewInputEnvelope
    set?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    disconnect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    delete?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    connect?: ReportDIYHomesWhereUniqueInput | ReportDIYHomesWhereUniqueInput[]
    update?: ReportDIYHomesUpdateWithWhereUniqueWithoutReviewInput | ReportDIYHomesUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReportDIYHomesUpdateManyWithWhereWithoutReviewInput | ReportDIYHomesUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
  }

  export type UserDIYHomesCreateNestedOneWithoutLikeDIYHomesInput = {
    create?: XOR<UserDIYHomesCreateWithoutLikeDIYHomesInput, UserDIYHomesUncheckedCreateWithoutLikeDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutLikeDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
  }

  export type PostDIYHomesCreateNestedOneWithoutLikeInput = {
    create?: XOR<PostDIYHomesCreateWithoutLikeInput, PostDIYHomesUncheckedCreateWithoutLikeInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutLikeInput
    connect?: PostDIYHomesWhereUniqueInput
  }

  export type UserDIYHomesUpdateOneRequiredWithoutLikeDIYHomesNestedInput = {
    create?: XOR<UserDIYHomesCreateWithoutLikeDIYHomesInput, UserDIYHomesUncheckedCreateWithoutLikeDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutLikeDIYHomesInput
    upsert?: UserDIYHomesUpsertWithoutLikeDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
    update?: XOR<XOR<UserDIYHomesUpdateToOneWithWhereWithoutLikeDIYHomesInput, UserDIYHomesUpdateWithoutLikeDIYHomesInput>, UserDIYHomesUncheckedUpdateWithoutLikeDIYHomesInput>
  }

  export type PostDIYHomesUpdateOneRequiredWithoutLikeNestedInput = {
    create?: XOR<PostDIYHomesCreateWithoutLikeInput, PostDIYHomesUncheckedCreateWithoutLikeInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutLikeInput
    upsert?: PostDIYHomesUpsertWithoutLikeInput
    connect?: PostDIYHomesWhereUniqueInput
    update?: XOR<XOR<PostDIYHomesUpdateToOneWithWhereWithoutLikeInput, PostDIYHomesUpdateWithoutLikeInput>, PostDIYHomesUncheckedUpdateWithoutLikeInput>
  }

  export type UserDIYHomesCreateNestedOneWithoutBookmarkDIYHomesInput = {
    create?: XOR<UserDIYHomesCreateWithoutBookmarkDIYHomesInput, UserDIYHomesUncheckedCreateWithoutBookmarkDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutBookmarkDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
  }

  export type PostDIYHomesCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<PostDIYHomesCreateWithoutBookmarksInput, PostDIYHomesUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutBookmarksInput
    connect?: PostDIYHomesWhereUniqueInput
  }

  export type UserDIYHomesUpdateOneRequiredWithoutBookmarkDIYHomesNestedInput = {
    create?: XOR<UserDIYHomesCreateWithoutBookmarkDIYHomesInput, UserDIYHomesUncheckedCreateWithoutBookmarkDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutBookmarkDIYHomesInput
    upsert?: UserDIYHomesUpsertWithoutBookmarkDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
    update?: XOR<XOR<UserDIYHomesUpdateToOneWithWhereWithoutBookmarkDIYHomesInput, UserDIYHomesUpdateWithoutBookmarkDIYHomesInput>, UserDIYHomesUncheckedUpdateWithoutBookmarkDIYHomesInput>
  }

  export type PostDIYHomesUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<PostDIYHomesCreateWithoutBookmarksInput, PostDIYHomesUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutBookmarksInput
    upsert?: PostDIYHomesUpsertWithoutBookmarksInput
    connect?: PostDIYHomesWhereUniqueInput
    update?: XOR<XOR<PostDIYHomesUpdateToOneWithWhereWithoutBookmarksInput, PostDIYHomesUpdateWithoutBookmarksInput>, PostDIYHomesUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserDIYHomesCreateNestedOneWithoutReportDIYHomesInput = {
    create?: XOR<UserDIYHomesCreateWithoutReportDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReportDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutReportDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
  }

  export type PostDIYHomesCreateNestedOneWithoutReportInput = {
    create?: XOR<PostDIYHomesCreateWithoutReportInput, PostDIYHomesUncheckedCreateWithoutReportInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutReportInput
    connect?: PostDIYHomesWhereUniqueInput
  }

  export type ReviewDIYHomesCreateNestedOneWithoutReportInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutReportInput, ReviewDIYHomesUncheckedCreateWithoutReportInput>
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutReportInput
    connect?: ReviewDIYHomesWhereUniqueInput
  }

  export type UserDIYHomesUpdateOneRequiredWithoutReportDIYHomesNestedInput = {
    create?: XOR<UserDIYHomesCreateWithoutReportDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReportDIYHomesInput>
    connectOrCreate?: UserDIYHomesCreateOrConnectWithoutReportDIYHomesInput
    upsert?: UserDIYHomesUpsertWithoutReportDIYHomesInput
    connect?: UserDIYHomesWhereUniqueInput
    update?: XOR<XOR<UserDIYHomesUpdateToOneWithWhereWithoutReportDIYHomesInput, UserDIYHomesUpdateWithoutReportDIYHomesInput>, UserDIYHomesUncheckedUpdateWithoutReportDIYHomesInput>
  }

  export type PostDIYHomesUpdateOneWithoutReportNestedInput = {
    create?: XOR<PostDIYHomesCreateWithoutReportInput, PostDIYHomesUncheckedCreateWithoutReportInput>
    connectOrCreate?: PostDIYHomesCreateOrConnectWithoutReportInput
    upsert?: PostDIYHomesUpsertWithoutReportInput
    disconnect?: PostDIYHomesWhereInput | boolean
    delete?: PostDIYHomesWhereInput | boolean
    connect?: PostDIYHomesWhereUniqueInput
    update?: XOR<XOR<PostDIYHomesUpdateToOneWithWhereWithoutReportInput, PostDIYHomesUpdateWithoutReportInput>, PostDIYHomesUncheckedUpdateWithoutReportInput>
  }

  export type ReviewDIYHomesUpdateOneWithoutReportNestedInput = {
    create?: XOR<ReviewDIYHomesCreateWithoutReportInput, ReviewDIYHomesUncheckedCreateWithoutReportInput>
    connectOrCreate?: ReviewDIYHomesCreateOrConnectWithoutReportInput
    upsert?: ReviewDIYHomesUpsertWithoutReportInput
    disconnect?: ReviewDIYHomesWhereInput | boolean
    delete?: ReviewDIYHomesWhereInput | boolean
    connect?: ReviewDIYHomesWhereUniqueInput
    update?: XOR<XOR<ReviewDIYHomesUpdateToOneWithWhereWithoutReportInput, ReviewDIYHomesUpdateWithoutReportInput>, ReviewDIYHomesUncheckedUpdateWithoutReportInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PlaceUrbanExplorerCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutOwnerInput, PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput> | PlaceUrbanExplorerCreateWithoutOwnerInput[] | PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput | PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput[]
    createMany?: PlaceUrbanExplorerCreateManyOwnerInputEnvelope
    connect?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
  }

  export type ReviewUrbanExplorerCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutUserInput, ReviewUrbanExplorerUncheckedCreateWithoutUserInput> | ReviewUrbanExplorerCreateWithoutUserInput[] | ReviewUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutUserInput | ReviewUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: ReviewUrbanExplorerCreateManyUserInputEnvelope
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
  }

  export type LikeUrbanExplorerCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutUserInput, LikeUrbanExplorerUncheckedCreateWithoutUserInput> | LikeUrbanExplorerCreateWithoutUserInput[] | LikeUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutUserInput | LikeUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: LikeUrbanExplorerCreateManyUserInputEnvelope
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
  }

  export type BookmarkUrbanExplorerCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutUserInput, BookmarkUrbanExplorerUncheckedCreateWithoutUserInput> | BookmarkUrbanExplorerCreateWithoutUserInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutUserInput | BookmarkUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkUrbanExplorerCreateManyUserInputEnvelope
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
  }

  export type ReportUrbanExplorerCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutUserInput, ReportUrbanExplorerUncheckedCreateWithoutUserInput> | ReportUrbanExplorerCreateWithoutUserInput[] | ReportUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutUserInput | ReportUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: ReportUrbanExplorerCreateManyUserInputEnvelope
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
  }

  export type PlaceUrbanExplorerUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutOwnerInput, PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput> | PlaceUrbanExplorerCreateWithoutOwnerInput[] | PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput | PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput[]
    createMany?: PlaceUrbanExplorerCreateManyOwnerInputEnvelope
    connect?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
  }

  export type ReviewUrbanExplorerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutUserInput, ReviewUrbanExplorerUncheckedCreateWithoutUserInput> | ReviewUrbanExplorerCreateWithoutUserInput[] | ReviewUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutUserInput | ReviewUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: ReviewUrbanExplorerCreateManyUserInputEnvelope
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
  }

  export type LikeUrbanExplorerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutUserInput, LikeUrbanExplorerUncheckedCreateWithoutUserInput> | LikeUrbanExplorerCreateWithoutUserInput[] | LikeUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutUserInput | LikeUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: LikeUrbanExplorerCreateManyUserInputEnvelope
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
  }

  export type BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutUserInput, BookmarkUrbanExplorerUncheckedCreateWithoutUserInput> | BookmarkUrbanExplorerCreateWithoutUserInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutUserInput | BookmarkUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkUrbanExplorerCreateManyUserInputEnvelope
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
  }

  export type ReportUrbanExplorerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutUserInput, ReportUrbanExplorerUncheckedCreateWithoutUserInput> | ReportUrbanExplorerCreateWithoutUserInput[] | ReportUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutUserInput | ReportUrbanExplorerCreateOrConnectWithoutUserInput[]
    createMany?: ReportUrbanExplorerCreateManyUserInputEnvelope
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
  }

  export type PlaceUrbanExplorerUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutOwnerInput, PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput> | PlaceUrbanExplorerCreateWithoutOwnerInput[] | PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput | PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput[]
    upsert?: PlaceUrbanExplorerUpsertWithWhereUniqueWithoutOwnerInput | PlaceUrbanExplorerUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PlaceUrbanExplorerCreateManyOwnerInputEnvelope
    set?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    disconnect?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    delete?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    connect?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    update?: PlaceUrbanExplorerUpdateWithWhereUniqueWithoutOwnerInput | PlaceUrbanExplorerUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PlaceUrbanExplorerUpdateManyWithWhereWithoutOwnerInput | PlaceUrbanExplorerUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PlaceUrbanExplorerScalarWhereInput | PlaceUrbanExplorerScalarWhereInput[]
  }

  export type ReviewUrbanExplorerUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutUserInput, ReviewUrbanExplorerUncheckedCreateWithoutUserInput> | ReviewUrbanExplorerCreateWithoutUserInput[] | ReviewUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutUserInput | ReviewUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | ReviewUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewUrbanExplorerCreateManyUserInputEnvelope
    set?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    disconnect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    delete?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    update?: ReviewUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | ReviewUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUrbanExplorerUpdateManyWithWhereWithoutUserInput | ReviewUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewUrbanExplorerScalarWhereInput | ReviewUrbanExplorerScalarWhereInput[]
  }

  export type LikeUrbanExplorerUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutUserInput, LikeUrbanExplorerUncheckedCreateWithoutUserInput> | LikeUrbanExplorerCreateWithoutUserInput[] | LikeUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutUserInput | LikeUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: LikeUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | LikeUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeUrbanExplorerCreateManyUserInputEnvelope
    set?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    disconnect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    delete?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    update?: LikeUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | LikeUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUrbanExplorerUpdateManyWithWhereWithoutUserInput | LikeUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeUrbanExplorerScalarWhereInput | LikeUrbanExplorerScalarWhereInput[]
  }

  export type BookmarkUrbanExplorerUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutUserInput, BookmarkUrbanExplorerUncheckedCreateWithoutUserInput> | BookmarkUrbanExplorerCreateWithoutUserInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutUserInput | BookmarkUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkUrbanExplorerCreateManyUserInputEnvelope
    set?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    disconnect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    delete?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    update?: BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUrbanExplorerUpdateManyWithWhereWithoutUserInput | BookmarkUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkUrbanExplorerScalarWhereInput | BookmarkUrbanExplorerScalarWhereInput[]
  }

  export type ReportUrbanExplorerUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutUserInput, ReportUrbanExplorerUncheckedCreateWithoutUserInput> | ReportUrbanExplorerCreateWithoutUserInput[] | ReportUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutUserInput | ReportUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: ReportUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | ReportUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportUrbanExplorerCreateManyUserInputEnvelope
    set?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    disconnect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    delete?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    update?: ReportUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | ReportUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUrbanExplorerUpdateManyWithWhereWithoutUserInput | ReportUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
  }

  export type PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutOwnerInput, PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput> | PlaceUrbanExplorerCreateWithoutOwnerInput[] | PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput | PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput[]
    upsert?: PlaceUrbanExplorerUpsertWithWhereUniqueWithoutOwnerInput | PlaceUrbanExplorerUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PlaceUrbanExplorerCreateManyOwnerInputEnvelope
    set?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    disconnect?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    delete?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    connect?: PlaceUrbanExplorerWhereUniqueInput | PlaceUrbanExplorerWhereUniqueInput[]
    update?: PlaceUrbanExplorerUpdateWithWhereUniqueWithoutOwnerInput | PlaceUrbanExplorerUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PlaceUrbanExplorerUpdateManyWithWhereWithoutOwnerInput | PlaceUrbanExplorerUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PlaceUrbanExplorerScalarWhereInput | PlaceUrbanExplorerScalarWhereInput[]
  }

  export type ReviewUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutUserInput, ReviewUrbanExplorerUncheckedCreateWithoutUserInput> | ReviewUrbanExplorerCreateWithoutUserInput[] | ReviewUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutUserInput | ReviewUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | ReviewUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewUrbanExplorerCreateManyUserInputEnvelope
    set?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    disconnect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    delete?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    update?: ReviewUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | ReviewUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUrbanExplorerUpdateManyWithWhereWithoutUserInput | ReviewUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewUrbanExplorerScalarWhereInput | ReviewUrbanExplorerScalarWhereInput[]
  }

  export type LikeUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutUserInput, LikeUrbanExplorerUncheckedCreateWithoutUserInput> | LikeUrbanExplorerCreateWithoutUserInput[] | LikeUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutUserInput | LikeUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: LikeUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | LikeUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeUrbanExplorerCreateManyUserInputEnvelope
    set?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    disconnect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    delete?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    update?: LikeUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | LikeUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUrbanExplorerUpdateManyWithWhereWithoutUserInput | LikeUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeUrbanExplorerScalarWhereInput | LikeUrbanExplorerScalarWhereInput[]
  }

  export type BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutUserInput, BookmarkUrbanExplorerUncheckedCreateWithoutUserInput> | BookmarkUrbanExplorerCreateWithoutUserInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutUserInput | BookmarkUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkUrbanExplorerCreateManyUserInputEnvelope
    set?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    disconnect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    delete?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    update?: BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUrbanExplorerUpdateManyWithWhereWithoutUserInput | BookmarkUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkUrbanExplorerScalarWhereInput | BookmarkUrbanExplorerScalarWhereInput[]
  }

  export type ReportUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutUserInput, ReportUrbanExplorerUncheckedCreateWithoutUserInput> | ReportUrbanExplorerCreateWithoutUserInput[] | ReportUrbanExplorerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutUserInput | ReportUrbanExplorerCreateOrConnectWithoutUserInput[]
    upsert?: ReportUrbanExplorerUpsertWithWhereUniqueWithoutUserInput | ReportUrbanExplorerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportUrbanExplorerCreateManyUserInputEnvelope
    set?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    disconnect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    delete?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    update?: ReportUrbanExplorerUpdateWithWhereUniqueWithoutUserInput | ReportUrbanExplorerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUrbanExplorerUpdateManyWithWhereWithoutUserInput | ReportUrbanExplorerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
  }

  export type UserUrbanExplorerCreateNestedOneWithoutPlaceUrbanExplorerInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutPlaceUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutPlaceUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
  }

  export type ReviewUrbanExplorerCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutPlaceInput, ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReviewUrbanExplorerCreateWithoutPlaceInput[] | ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput | ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: ReviewUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
  }

  export type BookmarkUrbanExplorerCreateNestedManyWithoutPlaceInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput> | BookmarkUrbanExplorerCreateWithoutPlaceInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput | BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: BookmarkUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
  }

  export type LikeUrbanExplorerCreateNestedManyWithoutPlaceInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutPlaceInput, LikeUrbanExplorerUncheckedCreateWithoutPlaceInput> | LikeUrbanExplorerCreateWithoutPlaceInput[] | LikeUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutPlaceInput | LikeUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: LikeUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
  }

  export type ReportUrbanExplorerCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutPlaceInput, ReportUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReportUrbanExplorerCreateWithoutPlaceInput[] | ReportUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutPlaceInput | ReportUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: ReportUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
  }

  export type ReviewUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutPlaceInput, ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReviewUrbanExplorerCreateWithoutPlaceInput[] | ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput | ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: ReviewUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
  }

  export type BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput> | BookmarkUrbanExplorerCreateWithoutPlaceInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput | BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: BookmarkUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
  }

  export type LikeUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutPlaceInput, LikeUrbanExplorerUncheckedCreateWithoutPlaceInput> | LikeUrbanExplorerCreateWithoutPlaceInput[] | LikeUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutPlaceInput | LikeUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: LikeUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
  }

  export type ReportUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutPlaceInput, ReportUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReportUrbanExplorerCreateWithoutPlaceInput[] | ReportUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutPlaceInput | ReportUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    createMany?: ReportUrbanExplorerCreateManyPlaceInputEnvelope
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUrbanExplorerUpdateOneRequiredWithoutPlaceUrbanExplorerNestedInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutPlaceUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutPlaceUrbanExplorerInput
    upsert?: UserUrbanExplorerUpsertWithoutPlaceUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<UserUrbanExplorerUpdateToOneWithWhereWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUpdateWithoutPlaceUrbanExplorerInput>, UserUrbanExplorerUncheckedUpdateWithoutPlaceUrbanExplorerInput>
  }

  export type ReviewUrbanExplorerUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutPlaceInput, ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReviewUrbanExplorerCreateWithoutPlaceInput[] | ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput | ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: ReviewUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | ReviewUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ReviewUrbanExplorerCreateManyPlaceInputEnvelope
    set?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    disconnect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    delete?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    update?: ReviewUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | ReviewUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ReviewUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | ReviewUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ReviewUrbanExplorerScalarWhereInput | ReviewUrbanExplorerScalarWhereInput[]
  }

  export type BookmarkUrbanExplorerUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput> | BookmarkUrbanExplorerCreateWithoutPlaceInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput | BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: BookmarkUrbanExplorerCreateManyPlaceInputEnvelope
    set?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    disconnect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    delete?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    update?: BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: BookmarkUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | BookmarkUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: BookmarkUrbanExplorerScalarWhereInput | BookmarkUrbanExplorerScalarWhereInput[]
  }

  export type LikeUrbanExplorerUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutPlaceInput, LikeUrbanExplorerUncheckedCreateWithoutPlaceInput> | LikeUrbanExplorerCreateWithoutPlaceInput[] | LikeUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutPlaceInput | LikeUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: LikeUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | LikeUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: LikeUrbanExplorerCreateManyPlaceInputEnvelope
    set?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    disconnect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    delete?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    update?: LikeUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | LikeUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: LikeUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | LikeUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: LikeUrbanExplorerScalarWhereInput | LikeUrbanExplorerScalarWhereInput[]
  }

  export type ReportUrbanExplorerUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutPlaceInput, ReportUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReportUrbanExplorerCreateWithoutPlaceInput[] | ReportUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutPlaceInput | ReportUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: ReportUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | ReportUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ReportUrbanExplorerCreateManyPlaceInputEnvelope
    set?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    disconnect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    delete?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    update?: ReportUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | ReportUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ReportUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | ReportUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
  }

  export type ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutPlaceInput, ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReviewUrbanExplorerCreateWithoutPlaceInput[] | ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput | ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: ReviewUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | ReviewUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ReviewUrbanExplorerCreateManyPlaceInputEnvelope
    set?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    disconnect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    delete?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    connect?: ReviewUrbanExplorerWhereUniqueInput | ReviewUrbanExplorerWhereUniqueInput[]
    update?: ReviewUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | ReviewUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ReviewUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | ReviewUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ReviewUrbanExplorerScalarWhereInput | ReviewUrbanExplorerScalarWhereInput[]
  }

  export type BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<BookmarkUrbanExplorerCreateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput> | BookmarkUrbanExplorerCreateWithoutPlaceInput[] | BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput | BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: BookmarkUrbanExplorerCreateManyPlaceInputEnvelope
    set?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    disconnect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    delete?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    connect?: BookmarkUrbanExplorerWhereUniqueInput | BookmarkUrbanExplorerWhereUniqueInput[]
    update?: BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: BookmarkUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | BookmarkUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: BookmarkUrbanExplorerScalarWhereInput | BookmarkUrbanExplorerScalarWhereInput[]
  }

  export type LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<LikeUrbanExplorerCreateWithoutPlaceInput, LikeUrbanExplorerUncheckedCreateWithoutPlaceInput> | LikeUrbanExplorerCreateWithoutPlaceInput[] | LikeUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: LikeUrbanExplorerCreateOrConnectWithoutPlaceInput | LikeUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: LikeUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | LikeUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: LikeUrbanExplorerCreateManyPlaceInputEnvelope
    set?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    disconnect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    delete?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    connect?: LikeUrbanExplorerWhereUniqueInput | LikeUrbanExplorerWhereUniqueInput[]
    update?: LikeUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | LikeUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: LikeUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | LikeUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: LikeUrbanExplorerScalarWhereInput | LikeUrbanExplorerScalarWhereInput[]
  }

  export type ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutPlaceInput, ReportUrbanExplorerUncheckedCreateWithoutPlaceInput> | ReportUrbanExplorerCreateWithoutPlaceInput[] | ReportUrbanExplorerUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutPlaceInput | ReportUrbanExplorerCreateOrConnectWithoutPlaceInput[]
    upsert?: ReportUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput | ReportUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ReportUrbanExplorerCreateManyPlaceInputEnvelope
    set?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    disconnect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    delete?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    update?: ReportUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput | ReportUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ReportUrbanExplorerUpdateManyWithWhereWithoutPlaceInput | ReportUrbanExplorerUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
  }

  export type UserUrbanExplorerCreateNestedOneWithoutReviewUrbanExplorerInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutReviewUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReviewUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutReviewUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
  }

  export type PlaceUrbanExplorerCreateNestedOneWithoutReviewsInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutReviewsInput, PlaceUrbanExplorerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutReviewsInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
  }

  export type ReportUrbanExplorerCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutReviewInput, ReportUrbanExplorerUncheckedCreateWithoutReviewInput> | ReportUrbanExplorerCreateWithoutReviewInput[] | ReportUrbanExplorerUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutReviewInput | ReportUrbanExplorerCreateOrConnectWithoutReviewInput[]
    createMany?: ReportUrbanExplorerCreateManyReviewInputEnvelope
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
  }

  export type ReportUrbanExplorerUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutReviewInput, ReportUrbanExplorerUncheckedCreateWithoutReviewInput> | ReportUrbanExplorerCreateWithoutReviewInput[] | ReportUrbanExplorerUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutReviewInput | ReportUrbanExplorerCreateOrConnectWithoutReviewInput[]
    createMany?: ReportUrbanExplorerCreateManyReviewInputEnvelope
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
  }

  export type UserUrbanExplorerUpdateOneRequiredWithoutReviewUrbanExplorerNestedInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutReviewUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReviewUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutReviewUrbanExplorerInput
    upsert?: UserUrbanExplorerUpsertWithoutReviewUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<UserUrbanExplorerUpdateToOneWithWhereWithoutReviewUrbanExplorerInput, UserUrbanExplorerUpdateWithoutReviewUrbanExplorerInput>, UserUrbanExplorerUncheckedUpdateWithoutReviewUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutReviewsInput, PlaceUrbanExplorerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutReviewsInput
    upsert?: PlaceUrbanExplorerUpsertWithoutReviewsInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<PlaceUrbanExplorerUpdateToOneWithWhereWithoutReviewsInput, PlaceUrbanExplorerUpdateWithoutReviewsInput>, PlaceUrbanExplorerUncheckedUpdateWithoutReviewsInput>
  }

  export type ReportUrbanExplorerUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutReviewInput, ReportUrbanExplorerUncheckedCreateWithoutReviewInput> | ReportUrbanExplorerCreateWithoutReviewInput[] | ReportUrbanExplorerUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutReviewInput | ReportUrbanExplorerCreateOrConnectWithoutReviewInput[]
    upsert?: ReportUrbanExplorerUpsertWithWhereUniqueWithoutReviewInput | ReportUrbanExplorerUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReportUrbanExplorerCreateManyReviewInputEnvelope
    set?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    disconnect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    delete?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    update?: ReportUrbanExplorerUpdateWithWhereUniqueWithoutReviewInput | ReportUrbanExplorerUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReportUrbanExplorerUpdateManyWithWhereWithoutReviewInput | ReportUrbanExplorerUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
  }

  export type ReportUrbanExplorerUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReportUrbanExplorerCreateWithoutReviewInput, ReportUrbanExplorerUncheckedCreateWithoutReviewInput> | ReportUrbanExplorerCreateWithoutReviewInput[] | ReportUrbanExplorerUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReportUrbanExplorerCreateOrConnectWithoutReviewInput | ReportUrbanExplorerCreateOrConnectWithoutReviewInput[]
    upsert?: ReportUrbanExplorerUpsertWithWhereUniqueWithoutReviewInput | ReportUrbanExplorerUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReportUrbanExplorerCreateManyReviewInputEnvelope
    set?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    disconnect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    delete?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    connect?: ReportUrbanExplorerWhereUniqueInput | ReportUrbanExplorerWhereUniqueInput[]
    update?: ReportUrbanExplorerUpdateWithWhereUniqueWithoutReviewInput | ReportUrbanExplorerUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReportUrbanExplorerUpdateManyWithWhereWithoutReviewInput | ReportUrbanExplorerUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
  }

  export type UserUrbanExplorerCreateNestedOneWithoutLikeUrbanExplorerInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutLikeUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutLikeUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutLikeUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
  }

  export type PlaceUrbanExplorerCreateNestedOneWithoutLikesInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutLikesInput, PlaceUrbanExplorerUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutLikesInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
  }

  export type UserUrbanExplorerUpdateOneRequiredWithoutLikeUrbanExplorerNestedInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutLikeUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutLikeUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutLikeUrbanExplorerInput
    upsert?: UserUrbanExplorerUpsertWithoutLikeUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<UserUrbanExplorerUpdateToOneWithWhereWithoutLikeUrbanExplorerInput, UserUrbanExplorerUpdateWithoutLikeUrbanExplorerInput>, UserUrbanExplorerUncheckedUpdateWithoutLikeUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutLikesInput, PlaceUrbanExplorerUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutLikesInput
    upsert?: PlaceUrbanExplorerUpsertWithoutLikesInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<PlaceUrbanExplorerUpdateToOneWithWhereWithoutLikesInput, PlaceUrbanExplorerUpdateWithoutLikesInput>, PlaceUrbanExplorerUncheckedUpdateWithoutLikesInput>
  }

  export type UserUrbanExplorerCreateNestedOneWithoutBookmarkUrbanExplorerInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutBookmarkUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutBookmarkUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
  }

  export type PlaceUrbanExplorerCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutBookmarksInput, PlaceUrbanExplorerUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutBookmarksInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
  }

  export type UserUrbanExplorerUpdateOneRequiredWithoutBookmarkUrbanExplorerNestedInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutBookmarkUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutBookmarkUrbanExplorerInput
    upsert?: UserUrbanExplorerUpsertWithoutBookmarkUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<UserUrbanExplorerUpdateToOneWithWhereWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUpdateWithoutBookmarkUrbanExplorerInput>, UserUrbanExplorerUncheckedUpdateWithoutBookmarkUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutBookmarksInput, PlaceUrbanExplorerUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutBookmarksInput
    upsert?: PlaceUrbanExplorerUpsertWithoutBookmarksInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<PlaceUrbanExplorerUpdateToOneWithWhereWithoutBookmarksInput, PlaceUrbanExplorerUpdateWithoutBookmarksInput>, PlaceUrbanExplorerUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserUrbanExplorerCreateNestedOneWithoutReportUrbanExplorerInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutReportUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReportUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutReportUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
  }

  export type PlaceUrbanExplorerCreateNestedOneWithoutReportsInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutReportsInput, PlaceUrbanExplorerUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutReportsInput
    connect?: PlaceUrbanExplorerWhereUniqueInput
  }

  export type ReviewUrbanExplorerCreateNestedOneWithoutReportsInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutReportsInput, ReviewUrbanExplorerUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutReportsInput
    connect?: ReviewUrbanExplorerWhereUniqueInput
  }

  export type UserUrbanExplorerUpdateOneRequiredWithoutReportUrbanExplorerNestedInput = {
    create?: XOR<UserUrbanExplorerCreateWithoutReportUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReportUrbanExplorerInput>
    connectOrCreate?: UserUrbanExplorerCreateOrConnectWithoutReportUrbanExplorerInput
    upsert?: UserUrbanExplorerUpsertWithoutReportUrbanExplorerInput
    connect?: UserUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<UserUrbanExplorerUpdateToOneWithWhereWithoutReportUrbanExplorerInput, UserUrbanExplorerUpdateWithoutReportUrbanExplorerInput>, UserUrbanExplorerUncheckedUpdateWithoutReportUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerUpdateOneWithoutReportsNestedInput = {
    create?: XOR<PlaceUrbanExplorerCreateWithoutReportsInput, PlaceUrbanExplorerUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PlaceUrbanExplorerCreateOrConnectWithoutReportsInput
    upsert?: PlaceUrbanExplorerUpsertWithoutReportsInput
    disconnect?: PlaceUrbanExplorerWhereInput | boolean
    delete?: PlaceUrbanExplorerWhereInput | boolean
    connect?: PlaceUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<PlaceUrbanExplorerUpdateToOneWithWhereWithoutReportsInput, PlaceUrbanExplorerUpdateWithoutReportsInput>, PlaceUrbanExplorerUncheckedUpdateWithoutReportsInput>
  }

  export type ReviewUrbanExplorerUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ReviewUrbanExplorerCreateWithoutReportsInput, ReviewUrbanExplorerUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReviewUrbanExplorerCreateOrConnectWithoutReportsInput
    upsert?: ReviewUrbanExplorerUpsertWithoutReportsInput
    disconnect?: ReviewUrbanExplorerWhereInput | boolean
    delete?: ReviewUrbanExplorerWhereInput | boolean
    connect?: ReviewUrbanExplorerWhereUniqueInput
    update?: XOR<XOR<ReviewUrbanExplorerUpdateToOneWithWhereWithoutReportsInput, ReviewUrbanExplorerUpdateWithoutReportsInput>, ReviewUrbanExplorerUncheckedUpdateWithoutReportsInput>
  }

  export type FoodieFoodCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieFoodCreateWithoutUserInput, FoodieFoodUncheckedCreateWithoutUserInput> | FoodieFoodCreateWithoutUserInput[] | FoodieFoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutUserInput | FoodieFoodCreateOrConnectWithoutUserInput[]
    createMany?: FoodieFoodCreateManyUserInputEnvelope
    connect?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
  }

  export type FoodieLocationCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieLocationCreateWithoutUserInput, FoodieLocationUncheckedCreateWithoutUserInput> | FoodieLocationCreateWithoutUserInput[] | FoodieLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutUserInput | FoodieLocationCreateOrConnectWithoutUserInput[]
    createMany?: FoodieLocationCreateManyUserInputEnvelope
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
  }

  export type FoodieReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieReviewCreateWithoutUserInput, FoodieReviewUncheckedCreateWithoutUserInput> | FoodieReviewCreateWithoutUserInput[] | FoodieReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutUserInput | FoodieReviewCreateOrConnectWithoutUserInput[]
    createMany?: FoodieReviewCreateManyUserInputEnvelope
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
  }

  export type FoodieLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieLikeCreateWithoutUserInput, FoodieLikeUncheckedCreateWithoutUserInput> | FoodieLikeCreateWithoutUserInput[] | FoodieLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutUserInput | FoodieLikeCreateOrConnectWithoutUserInput[]
    createMany?: FoodieLikeCreateManyUserInputEnvelope
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
  }

  export type FoodieFoodUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieFoodCreateWithoutUserInput, FoodieFoodUncheckedCreateWithoutUserInput> | FoodieFoodCreateWithoutUserInput[] | FoodieFoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutUserInput | FoodieFoodCreateOrConnectWithoutUserInput[]
    createMany?: FoodieFoodCreateManyUserInputEnvelope
    connect?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
  }

  export type FoodieLocationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieLocationCreateWithoutUserInput, FoodieLocationUncheckedCreateWithoutUserInput> | FoodieLocationCreateWithoutUserInput[] | FoodieLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutUserInput | FoodieLocationCreateOrConnectWithoutUserInput[]
    createMany?: FoodieLocationCreateManyUserInputEnvelope
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
  }

  export type FoodieReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieReviewCreateWithoutUserInput, FoodieReviewUncheckedCreateWithoutUserInput> | FoodieReviewCreateWithoutUserInput[] | FoodieReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutUserInput | FoodieReviewCreateOrConnectWithoutUserInput[]
    createMany?: FoodieReviewCreateManyUserInputEnvelope
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
  }

  export type FoodieLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FoodieLikeCreateWithoutUserInput, FoodieLikeUncheckedCreateWithoutUserInput> | FoodieLikeCreateWithoutUserInput[] | FoodieLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutUserInput | FoodieLikeCreateOrConnectWithoutUserInput[]
    createMany?: FoodieLikeCreateManyUserInputEnvelope
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
  }

  export type FoodieFoodUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieFoodCreateWithoutUserInput, FoodieFoodUncheckedCreateWithoutUserInput> | FoodieFoodCreateWithoutUserInput[] | FoodieFoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutUserInput | FoodieFoodCreateOrConnectWithoutUserInput[]
    upsert?: FoodieFoodUpsertWithWhereUniqueWithoutUserInput | FoodieFoodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieFoodCreateManyUserInputEnvelope
    set?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    disconnect?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    delete?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    connect?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    update?: FoodieFoodUpdateWithWhereUniqueWithoutUserInput | FoodieFoodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieFoodUpdateManyWithWhereWithoutUserInput | FoodieFoodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieFoodScalarWhereInput | FoodieFoodScalarWhereInput[]
  }

  export type FoodieLocationUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieLocationCreateWithoutUserInput, FoodieLocationUncheckedCreateWithoutUserInput> | FoodieLocationCreateWithoutUserInput[] | FoodieLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutUserInput | FoodieLocationCreateOrConnectWithoutUserInput[]
    upsert?: FoodieLocationUpsertWithWhereUniqueWithoutUserInput | FoodieLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieLocationCreateManyUserInputEnvelope
    set?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    disconnect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    delete?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    update?: FoodieLocationUpdateWithWhereUniqueWithoutUserInput | FoodieLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieLocationUpdateManyWithWhereWithoutUserInput | FoodieLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieLocationScalarWhereInput | FoodieLocationScalarWhereInput[]
  }

  export type FoodieReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieReviewCreateWithoutUserInput, FoodieReviewUncheckedCreateWithoutUserInput> | FoodieReviewCreateWithoutUserInput[] | FoodieReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutUserInput | FoodieReviewCreateOrConnectWithoutUserInput[]
    upsert?: FoodieReviewUpsertWithWhereUniqueWithoutUserInput | FoodieReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieReviewCreateManyUserInputEnvelope
    set?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    disconnect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    delete?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    update?: FoodieReviewUpdateWithWhereUniqueWithoutUserInput | FoodieReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieReviewUpdateManyWithWhereWithoutUserInput | FoodieReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieReviewScalarWhereInput | FoodieReviewScalarWhereInput[]
  }

  export type FoodieLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieLikeCreateWithoutUserInput, FoodieLikeUncheckedCreateWithoutUserInput> | FoodieLikeCreateWithoutUserInput[] | FoodieLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutUserInput | FoodieLikeCreateOrConnectWithoutUserInput[]
    upsert?: FoodieLikeUpsertWithWhereUniqueWithoutUserInput | FoodieLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieLikeCreateManyUserInputEnvelope
    set?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    disconnect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    delete?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    update?: FoodieLikeUpdateWithWhereUniqueWithoutUserInput | FoodieLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieLikeUpdateManyWithWhereWithoutUserInput | FoodieLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieLikeScalarWhereInput | FoodieLikeScalarWhereInput[]
  }

  export type FoodieFoodUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieFoodCreateWithoutUserInput, FoodieFoodUncheckedCreateWithoutUserInput> | FoodieFoodCreateWithoutUserInput[] | FoodieFoodUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutUserInput | FoodieFoodCreateOrConnectWithoutUserInput[]
    upsert?: FoodieFoodUpsertWithWhereUniqueWithoutUserInput | FoodieFoodUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieFoodCreateManyUserInputEnvelope
    set?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    disconnect?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    delete?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    connect?: FoodieFoodWhereUniqueInput | FoodieFoodWhereUniqueInput[]
    update?: FoodieFoodUpdateWithWhereUniqueWithoutUserInput | FoodieFoodUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieFoodUpdateManyWithWhereWithoutUserInput | FoodieFoodUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieFoodScalarWhereInput | FoodieFoodScalarWhereInput[]
  }

  export type FoodieLocationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieLocationCreateWithoutUserInput, FoodieLocationUncheckedCreateWithoutUserInput> | FoodieLocationCreateWithoutUserInput[] | FoodieLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutUserInput | FoodieLocationCreateOrConnectWithoutUserInput[]
    upsert?: FoodieLocationUpsertWithWhereUniqueWithoutUserInput | FoodieLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieLocationCreateManyUserInputEnvelope
    set?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    disconnect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    delete?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    update?: FoodieLocationUpdateWithWhereUniqueWithoutUserInput | FoodieLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieLocationUpdateManyWithWhereWithoutUserInput | FoodieLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieLocationScalarWhereInput | FoodieLocationScalarWhereInput[]
  }

  export type FoodieReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieReviewCreateWithoutUserInput, FoodieReviewUncheckedCreateWithoutUserInput> | FoodieReviewCreateWithoutUserInput[] | FoodieReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutUserInput | FoodieReviewCreateOrConnectWithoutUserInput[]
    upsert?: FoodieReviewUpsertWithWhereUniqueWithoutUserInput | FoodieReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieReviewCreateManyUserInputEnvelope
    set?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    disconnect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    delete?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    update?: FoodieReviewUpdateWithWhereUniqueWithoutUserInput | FoodieReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieReviewUpdateManyWithWhereWithoutUserInput | FoodieReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieReviewScalarWhereInput | FoodieReviewScalarWhereInput[]
  }

  export type FoodieLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FoodieLikeCreateWithoutUserInput, FoodieLikeUncheckedCreateWithoutUserInput> | FoodieLikeCreateWithoutUserInput[] | FoodieLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutUserInput | FoodieLikeCreateOrConnectWithoutUserInput[]
    upsert?: FoodieLikeUpsertWithWhereUniqueWithoutUserInput | FoodieLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FoodieLikeCreateManyUserInputEnvelope
    set?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    disconnect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    delete?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    update?: FoodieLikeUpdateWithWhereUniqueWithoutUserInput | FoodieLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FoodieLikeUpdateManyWithWhereWithoutUserInput | FoodieLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FoodieLikeScalarWhereInput | FoodieLikeScalarWhereInput[]
  }

  export type UserFoodieCreateNestedOneWithoutFoodieFoodInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieFoodInput, UserFoodieUncheckedCreateWithoutFoodieFoodInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieFoodInput
    connect?: UserFoodieWhereUniqueInput
  }

  export type FoodieLocationCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodieLocationCreateWithoutFoodInput, FoodieLocationUncheckedCreateWithoutFoodInput> | FoodieLocationCreateWithoutFoodInput[] | FoodieLocationUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutFoodInput | FoodieLocationCreateOrConnectWithoutFoodInput[]
    createMany?: FoodieLocationCreateManyFoodInputEnvelope
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
  }

  export type FoodieReviewCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodieReviewCreateWithoutFoodInput, FoodieReviewUncheckedCreateWithoutFoodInput> | FoodieReviewCreateWithoutFoodInput[] | FoodieReviewUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutFoodInput | FoodieReviewCreateOrConnectWithoutFoodInput[]
    createMany?: FoodieReviewCreateManyFoodInputEnvelope
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
  }

  export type FoodieLikeCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodieLikeCreateWithoutFoodInput, FoodieLikeUncheckedCreateWithoutFoodInput> | FoodieLikeCreateWithoutFoodInput[] | FoodieLikeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutFoodInput | FoodieLikeCreateOrConnectWithoutFoodInput[]
    createMany?: FoodieLikeCreateManyFoodInputEnvelope
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
  }

  export type FoodieLocationUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodieLocationCreateWithoutFoodInput, FoodieLocationUncheckedCreateWithoutFoodInput> | FoodieLocationCreateWithoutFoodInput[] | FoodieLocationUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutFoodInput | FoodieLocationCreateOrConnectWithoutFoodInput[]
    createMany?: FoodieLocationCreateManyFoodInputEnvelope
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
  }

  export type FoodieReviewUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodieReviewCreateWithoutFoodInput, FoodieReviewUncheckedCreateWithoutFoodInput> | FoodieReviewCreateWithoutFoodInput[] | FoodieReviewUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutFoodInput | FoodieReviewCreateOrConnectWithoutFoodInput[]
    createMany?: FoodieReviewCreateManyFoodInputEnvelope
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
  }

  export type FoodieLikeUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<FoodieLikeCreateWithoutFoodInput, FoodieLikeUncheckedCreateWithoutFoodInput> | FoodieLikeCreateWithoutFoodInput[] | FoodieLikeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutFoodInput | FoodieLikeCreateOrConnectWithoutFoodInput[]
    createMany?: FoodieLikeCreateManyFoodInputEnvelope
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
  }

  export type UserFoodieUpdateOneRequiredWithoutFoodieFoodNestedInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieFoodInput, UserFoodieUncheckedCreateWithoutFoodieFoodInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieFoodInput
    upsert?: UserFoodieUpsertWithoutFoodieFoodInput
    connect?: UserFoodieWhereUniqueInput
    update?: XOR<XOR<UserFoodieUpdateToOneWithWhereWithoutFoodieFoodInput, UserFoodieUpdateWithoutFoodieFoodInput>, UserFoodieUncheckedUpdateWithoutFoodieFoodInput>
  }

  export type FoodieLocationUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodieLocationCreateWithoutFoodInput, FoodieLocationUncheckedCreateWithoutFoodInput> | FoodieLocationCreateWithoutFoodInput[] | FoodieLocationUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutFoodInput | FoodieLocationCreateOrConnectWithoutFoodInput[]
    upsert?: FoodieLocationUpsertWithWhereUniqueWithoutFoodInput | FoodieLocationUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodieLocationCreateManyFoodInputEnvelope
    set?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    disconnect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    delete?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    update?: FoodieLocationUpdateWithWhereUniqueWithoutFoodInput | FoodieLocationUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodieLocationUpdateManyWithWhereWithoutFoodInput | FoodieLocationUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodieLocationScalarWhereInput | FoodieLocationScalarWhereInput[]
  }

  export type FoodieReviewUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodieReviewCreateWithoutFoodInput, FoodieReviewUncheckedCreateWithoutFoodInput> | FoodieReviewCreateWithoutFoodInput[] | FoodieReviewUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutFoodInput | FoodieReviewCreateOrConnectWithoutFoodInput[]
    upsert?: FoodieReviewUpsertWithWhereUniqueWithoutFoodInput | FoodieReviewUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodieReviewCreateManyFoodInputEnvelope
    set?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    disconnect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    delete?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    update?: FoodieReviewUpdateWithWhereUniqueWithoutFoodInput | FoodieReviewUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodieReviewUpdateManyWithWhereWithoutFoodInput | FoodieReviewUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodieReviewScalarWhereInput | FoodieReviewScalarWhereInput[]
  }

  export type FoodieLikeUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodieLikeCreateWithoutFoodInput, FoodieLikeUncheckedCreateWithoutFoodInput> | FoodieLikeCreateWithoutFoodInput[] | FoodieLikeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutFoodInput | FoodieLikeCreateOrConnectWithoutFoodInput[]
    upsert?: FoodieLikeUpsertWithWhereUniqueWithoutFoodInput | FoodieLikeUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodieLikeCreateManyFoodInputEnvelope
    set?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    disconnect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    delete?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    update?: FoodieLikeUpdateWithWhereUniqueWithoutFoodInput | FoodieLikeUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodieLikeUpdateManyWithWhereWithoutFoodInput | FoodieLikeUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodieLikeScalarWhereInput | FoodieLikeScalarWhereInput[]
  }

  export type FoodieLocationUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodieLocationCreateWithoutFoodInput, FoodieLocationUncheckedCreateWithoutFoodInput> | FoodieLocationCreateWithoutFoodInput[] | FoodieLocationUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLocationCreateOrConnectWithoutFoodInput | FoodieLocationCreateOrConnectWithoutFoodInput[]
    upsert?: FoodieLocationUpsertWithWhereUniqueWithoutFoodInput | FoodieLocationUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodieLocationCreateManyFoodInputEnvelope
    set?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    disconnect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    delete?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    connect?: FoodieLocationWhereUniqueInput | FoodieLocationWhereUniqueInput[]
    update?: FoodieLocationUpdateWithWhereUniqueWithoutFoodInput | FoodieLocationUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodieLocationUpdateManyWithWhereWithoutFoodInput | FoodieLocationUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodieLocationScalarWhereInput | FoodieLocationScalarWhereInput[]
  }

  export type FoodieReviewUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodieReviewCreateWithoutFoodInput, FoodieReviewUncheckedCreateWithoutFoodInput> | FoodieReviewCreateWithoutFoodInput[] | FoodieReviewUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieReviewCreateOrConnectWithoutFoodInput | FoodieReviewCreateOrConnectWithoutFoodInput[]
    upsert?: FoodieReviewUpsertWithWhereUniqueWithoutFoodInput | FoodieReviewUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodieReviewCreateManyFoodInputEnvelope
    set?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    disconnect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    delete?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    connect?: FoodieReviewWhereUniqueInput | FoodieReviewWhereUniqueInput[]
    update?: FoodieReviewUpdateWithWhereUniqueWithoutFoodInput | FoodieReviewUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodieReviewUpdateManyWithWhereWithoutFoodInput | FoodieReviewUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodieReviewScalarWhereInput | FoodieReviewScalarWhereInput[]
  }

  export type FoodieLikeUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<FoodieLikeCreateWithoutFoodInput, FoodieLikeUncheckedCreateWithoutFoodInput> | FoodieLikeCreateWithoutFoodInput[] | FoodieLikeUncheckedCreateWithoutFoodInput[]
    connectOrCreate?: FoodieLikeCreateOrConnectWithoutFoodInput | FoodieLikeCreateOrConnectWithoutFoodInput[]
    upsert?: FoodieLikeUpsertWithWhereUniqueWithoutFoodInput | FoodieLikeUpsertWithWhereUniqueWithoutFoodInput[]
    createMany?: FoodieLikeCreateManyFoodInputEnvelope
    set?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    disconnect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    delete?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    connect?: FoodieLikeWhereUniqueInput | FoodieLikeWhereUniqueInput[]
    update?: FoodieLikeUpdateWithWhereUniqueWithoutFoodInput | FoodieLikeUpdateWithWhereUniqueWithoutFoodInput[]
    updateMany?: FoodieLikeUpdateManyWithWhereWithoutFoodInput | FoodieLikeUpdateManyWithWhereWithoutFoodInput[]
    deleteMany?: FoodieLikeScalarWhereInput | FoodieLikeScalarWhereInput[]
  }

  export type UserFoodieCreateNestedOneWithoutFoodieLocationInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieLocationInput, UserFoodieUncheckedCreateWithoutFoodieLocationInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieLocationInput
    connect?: UserFoodieWhereUniqueInput
  }

  export type FoodieFoodCreateNestedOneWithoutLocationsInput = {
    create?: XOR<FoodieFoodCreateWithoutLocationsInput, FoodieFoodUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutLocationsInput
    connect?: FoodieFoodWhereUniqueInput
  }

  export type UserFoodieUpdateOneRequiredWithoutFoodieLocationNestedInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieLocationInput, UserFoodieUncheckedCreateWithoutFoodieLocationInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieLocationInput
    upsert?: UserFoodieUpsertWithoutFoodieLocationInput
    connect?: UserFoodieWhereUniqueInput
    update?: XOR<XOR<UserFoodieUpdateToOneWithWhereWithoutFoodieLocationInput, UserFoodieUpdateWithoutFoodieLocationInput>, UserFoodieUncheckedUpdateWithoutFoodieLocationInput>
  }

  export type FoodieFoodUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<FoodieFoodCreateWithoutLocationsInput, FoodieFoodUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutLocationsInput
    upsert?: FoodieFoodUpsertWithoutLocationsInput
    connect?: FoodieFoodWhereUniqueInput
    update?: XOR<XOR<FoodieFoodUpdateToOneWithWhereWithoutLocationsInput, FoodieFoodUpdateWithoutLocationsInput>, FoodieFoodUncheckedUpdateWithoutLocationsInput>
  }

  export type UserFoodieCreateNestedOneWithoutFoodieReviewInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieReviewInput, UserFoodieUncheckedCreateWithoutFoodieReviewInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieReviewInput
    connect?: UserFoodieWhereUniqueInput
  }

  export type FoodieFoodCreateNestedOneWithoutReviewsInput = {
    create?: XOR<FoodieFoodCreateWithoutReviewsInput, FoodieFoodUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutReviewsInput
    connect?: FoodieFoodWhereUniqueInput
  }

  export type UserFoodieUpdateOneRequiredWithoutFoodieReviewNestedInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieReviewInput, UserFoodieUncheckedCreateWithoutFoodieReviewInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieReviewInput
    upsert?: UserFoodieUpsertWithoutFoodieReviewInput
    connect?: UserFoodieWhereUniqueInput
    update?: XOR<XOR<UserFoodieUpdateToOneWithWhereWithoutFoodieReviewInput, UserFoodieUpdateWithoutFoodieReviewInput>, UserFoodieUncheckedUpdateWithoutFoodieReviewInput>
  }

  export type FoodieFoodUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<FoodieFoodCreateWithoutReviewsInput, FoodieFoodUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutReviewsInput
    upsert?: FoodieFoodUpsertWithoutReviewsInput
    connect?: FoodieFoodWhereUniqueInput
    update?: XOR<XOR<FoodieFoodUpdateToOneWithWhereWithoutReviewsInput, FoodieFoodUpdateWithoutReviewsInput>, FoodieFoodUncheckedUpdateWithoutReviewsInput>
  }

  export type UserFoodieCreateNestedOneWithoutFoodieLikeInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieLikeInput, UserFoodieUncheckedCreateWithoutFoodieLikeInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieLikeInput
    connect?: UserFoodieWhereUniqueInput
  }

  export type FoodieFoodCreateNestedOneWithoutLikesInput = {
    create?: XOR<FoodieFoodCreateWithoutLikesInput, FoodieFoodUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutLikesInput
    connect?: FoodieFoodWhereUniqueInput
  }

  export type UserFoodieUpdateOneRequiredWithoutFoodieLikeNestedInput = {
    create?: XOR<UserFoodieCreateWithoutFoodieLikeInput, UserFoodieUncheckedCreateWithoutFoodieLikeInput>
    connectOrCreate?: UserFoodieCreateOrConnectWithoutFoodieLikeInput
    upsert?: UserFoodieUpsertWithoutFoodieLikeInput
    connect?: UserFoodieWhereUniqueInput
    update?: XOR<XOR<UserFoodieUpdateToOneWithWhereWithoutFoodieLikeInput, UserFoodieUpdateWithoutFoodieLikeInput>, UserFoodieUncheckedUpdateWithoutFoodieLikeInput>
  }

  export type FoodieFoodUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<FoodieFoodCreateWithoutLikesInput, FoodieFoodUncheckedCreateWithoutLikesInput>
    connectOrCreate?: FoodieFoodCreateOrConnectWithoutLikesInput
    upsert?: FoodieFoodUpsertWithoutLikesInput
    connect?: FoodieFoodWhereUniqueInput
    update?: XOR<XOR<FoodieFoodUpdateToOneWithWhereWithoutLikesInput, FoodieFoodUpdateWithoutLikesInput>, FoodieFoodUncheckedUpdateWithoutLikesInput>
  }

  export type PetPetLoverCreateNestedManyWithoutUserInput = {
    create?: XOR<PetPetLoverCreateWithoutUserInput, PetPetLoverUncheckedCreateWithoutUserInput> | PetPetLoverCreateWithoutUserInput[] | PetPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutUserInput | PetPetLoverCreateOrConnectWithoutUserInput[]
    createMany?: PetPetLoverCreateManyUserInputEnvelope
    connect?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
  }

  export type AppointmentPetLoverCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutUserInput, AppointmentPetLoverUncheckedCreateWithoutUserInput> | AppointmentPetLoverCreateWithoutUserInput[] | AppointmentPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutUserInput | AppointmentPetLoverCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentPetLoverCreateManyUserInputEnvelope
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
  }

  export type PetPetLoverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PetPetLoverCreateWithoutUserInput, PetPetLoverUncheckedCreateWithoutUserInput> | PetPetLoverCreateWithoutUserInput[] | PetPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutUserInput | PetPetLoverCreateOrConnectWithoutUserInput[]
    createMany?: PetPetLoverCreateManyUserInputEnvelope
    connect?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
  }

  export type AppointmentPetLoverUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutUserInput, AppointmentPetLoverUncheckedCreateWithoutUserInput> | AppointmentPetLoverCreateWithoutUserInput[] | AppointmentPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutUserInput | AppointmentPetLoverCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentPetLoverCreateManyUserInputEnvelope
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
  }

  export type PetPetLoverUpdateManyWithoutUserNestedInput = {
    create?: XOR<PetPetLoverCreateWithoutUserInput, PetPetLoverUncheckedCreateWithoutUserInput> | PetPetLoverCreateWithoutUserInput[] | PetPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutUserInput | PetPetLoverCreateOrConnectWithoutUserInput[]
    upsert?: PetPetLoverUpsertWithWhereUniqueWithoutUserInput | PetPetLoverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PetPetLoverCreateManyUserInputEnvelope
    set?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    disconnect?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    delete?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    connect?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    update?: PetPetLoverUpdateWithWhereUniqueWithoutUserInput | PetPetLoverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PetPetLoverUpdateManyWithWhereWithoutUserInput | PetPetLoverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PetPetLoverScalarWhereInput | PetPetLoverScalarWhereInput[]
  }

  export type AppointmentPetLoverUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutUserInput, AppointmentPetLoverUncheckedCreateWithoutUserInput> | AppointmentPetLoverCreateWithoutUserInput[] | AppointmentPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutUserInput | AppointmentPetLoverCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentPetLoverUpsertWithWhereUniqueWithoutUserInput | AppointmentPetLoverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentPetLoverCreateManyUserInputEnvelope
    set?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    disconnect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    delete?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    update?: AppointmentPetLoverUpdateWithWhereUniqueWithoutUserInput | AppointmentPetLoverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentPetLoverUpdateManyWithWhereWithoutUserInput | AppointmentPetLoverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentPetLoverScalarWhereInput | AppointmentPetLoverScalarWhereInput[]
  }

  export type PetPetLoverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PetPetLoverCreateWithoutUserInput, PetPetLoverUncheckedCreateWithoutUserInput> | PetPetLoverCreateWithoutUserInput[] | PetPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutUserInput | PetPetLoverCreateOrConnectWithoutUserInput[]
    upsert?: PetPetLoverUpsertWithWhereUniqueWithoutUserInput | PetPetLoverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PetPetLoverCreateManyUserInputEnvelope
    set?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    disconnect?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    delete?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    connect?: PetPetLoverWhereUniqueInput | PetPetLoverWhereUniqueInput[]
    update?: PetPetLoverUpdateWithWhereUniqueWithoutUserInput | PetPetLoverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PetPetLoverUpdateManyWithWhereWithoutUserInput | PetPetLoverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PetPetLoverScalarWhereInput | PetPetLoverScalarWhereInput[]
  }

  export type AppointmentPetLoverUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutUserInput, AppointmentPetLoverUncheckedCreateWithoutUserInput> | AppointmentPetLoverCreateWithoutUserInput[] | AppointmentPetLoverUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutUserInput | AppointmentPetLoverCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentPetLoverUpsertWithWhereUniqueWithoutUserInput | AppointmentPetLoverUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentPetLoverCreateManyUserInputEnvelope
    set?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    disconnect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    delete?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    update?: AppointmentPetLoverUpdateWithWhereUniqueWithoutUserInput | AppointmentPetLoverUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentPetLoverUpdateManyWithWhereWithoutUserInput | AppointmentPetLoverUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentPetLoverScalarWhereInput | AppointmentPetLoverScalarWhereInput[]
  }

  export type UserPetLoverCreateNestedOneWithoutPetPetLoverInput = {
    create?: XOR<UserPetLoverCreateWithoutPetPetLoverInput, UserPetLoverUncheckedCreateWithoutPetPetLoverInput>
    connectOrCreate?: UserPetLoverCreateOrConnectWithoutPetPetLoverInput
    connect?: UserPetLoverWhereUniqueInput
  }

  export type VaccinationPetLoverCreateNestedManyWithoutPetInput = {
    create?: XOR<VaccinationPetLoverCreateWithoutPetInput, VaccinationPetLoverUncheckedCreateWithoutPetInput> | VaccinationPetLoverCreateWithoutPetInput[] | VaccinationPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationPetLoverCreateOrConnectWithoutPetInput | VaccinationPetLoverCreateOrConnectWithoutPetInput[]
    createMany?: VaccinationPetLoverCreateManyPetInputEnvelope
    connect?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
  }

  export type AppointmentPetLoverCreateNestedManyWithoutPetInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutPetInput, AppointmentPetLoverUncheckedCreateWithoutPetInput> | AppointmentPetLoverCreateWithoutPetInput[] | AppointmentPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutPetInput | AppointmentPetLoverCreateOrConnectWithoutPetInput[]
    createMany?: AppointmentPetLoverCreateManyPetInputEnvelope
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
  }

  export type VaccinationPetLoverUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<VaccinationPetLoverCreateWithoutPetInput, VaccinationPetLoverUncheckedCreateWithoutPetInput> | VaccinationPetLoverCreateWithoutPetInput[] | VaccinationPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationPetLoverCreateOrConnectWithoutPetInput | VaccinationPetLoverCreateOrConnectWithoutPetInput[]
    createMany?: VaccinationPetLoverCreateManyPetInputEnvelope
    connect?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
  }

  export type AppointmentPetLoverUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutPetInput, AppointmentPetLoverUncheckedCreateWithoutPetInput> | AppointmentPetLoverCreateWithoutPetInput[] | AppointmentPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutPetInput | AppointmentPetLoverCreateOrConnectWithoutPetInput[]
    createMany?: AppointmentPetLoverCreateManyPetInputEnvelope
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
  }

  export type UserPetLoverUpdateOneRequiredWithoutPetPetLoverNestedInput = {
    create?: XOR<UserPetLoverCreateWithoutPetPetLoverInput, UserPetLoverUncheckedCreateWithoutPetPetLoverInput>
    connectOrCreate?: UserPetLoverCreateOrConnectWithoutPetPetLoverInput
    upsert?: UserPetLoverUpsertWithoutPetPetLoverInput
    connect?: UserPetLoverWhereUniqueInput
    update?: XOR<XOR<UserPetLoverUpdateToOneWithWhereWithoutPetPetLoverInput, UserPetLoverUpdateWithoutPetPetLoverInput>, UserPetLoverUncheckedUpdateWithoutPetPetLoverInput>
  }

  export type VaccinationPetLoverUpdateManyWithoutPetNestedInput = {
    create?: XOR<VaccinationPetLoverCreateWithoutPetInput, VaccinationPetLoverUncheckedCreateWithoutPetInput> | VaccinationPetLoverCreateWithoutPetInput[] | VaccinationPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationPetLoverCreateOrConnectWithoutPetInput | VaccinationPetLoverCreateOrConnectWithoutPetInput[]
    upsert?: VaccinationPetLoverUpsertWithWhereUniqueWithoutPetInput | VaccinationPetLoverUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: VaccinationPetLoverCreateManyPetInputEnvelope
    set?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    disconnect?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    delete?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    connect?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    update?: VaccinationPetLoverUpdateWithWhereUniqueWithoutPetInput | VaccinationPetLoverUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: VaccinationPetLoverUpdateManyWithWhereWithoutPetInput | VaccinationPetLoverUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: VaccinationPetLoverScalarWhereInput | VaccinationPetLoverScalarWhereInput[]
  }

  export type AppointmentPetLoverUpdateManyWithoutPetNestedInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutPetInput, AppointmentPetLoverUncheckedCreateWithoutPetInput> | AppointmentPetLoverCreateWithoutPetInput[] | AppointmentPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutPetInput | AppointmentPetLoverCreateOrConnectWithoutPetInput[]
    upsert?: AppointmentPetLoverUpsertWithWhereUniqueWithoutPetInput | AppointmentPetLoverUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: AppointmentPetLoverCreateManyPetInputEnvelope
    set?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    disconnect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    delete?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    update?: AppointmentPetLoverUpdateWithWhereUniqueWithoutPetInput | AppointmentPetLoverUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: AppointmentPetLoverUpdateManyWithWhereWithoutPetInput | AppointmentPetLoverUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: AppointmentPetLoverScalarWhereInput | AppointmentPetLoverScalarWhereInput[]
  }

  export type VaccinationPetLoverUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<VaccinationPetLoverCreateWithoutPetInput, VaccinationPetLoverUncheckedCreateWithoutPetInput> | VaccinationPetLoverCreateWithoutPetInput[] | VaccinationPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: VaccinationPetLoverCreateOrConnectWithoutPetInput | VaccinationPetLoverCreateOrConnectWithoutPetInput[]
    upsert?: VaccinationPetLoverUpsertWithWhereUniqueWithoutPetInput | VaccinationPetLoverUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: VaccinationPetLoverCreateManyPetInputEnvelope
    set?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    disconnect?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    delete?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    connect?: VaccinationPetLoverWhereUniqueInput | VaccinationPetLoverWhereUniqueInput[]
    update?: VaccinationPetLoverUpdateWithWhereUniqueWithoutPetInput | VaccinationPetLoverUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: VaccinationPetLoverUpdateManyWithWhereWithoutPetInput | VaccinationPetLoverUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: VaccinationPetLoverScalarWhereInput | VaccinationPetLoverScalarWhereInput[]
  }

  export type AppointmentPetLoverUncheckedUpdateManyWithoutPetNestedInput = {
    create?: XOR<AppointmentPetLoverCreateWithoutPetInput, AppointmentPetLoverUncheckedCreateWithoutPetInput> | AppointmentPetLoverCreateWithoutPetInput[] | AppointmentPetLoverUncheckedCreateWithoutPetInput[]
    connectOrCreate?: AppointmentPetLoverCreateOrConnectWithoutPetInput | AppointmentPetLoverCreateOrConnectWithoutPetInput[]
    upsert?: AppointmentPetLoverUpsertWithWhereUniqueWithoutPetInput | AppointmentPetLoverUpsertWithWhereUniqueWithoutPetInput[]
    createMany?: AppointmentPetLoverCreateManyPetInputEnvelope
    set?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    disconnect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    delete?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    connect?: AppointmentPetLoverWhereUniqueInput | AppointmentPetLoverWhereUniqueInput[]
    update?: AppointmentPetLoverUpdateWithWhereUniqueWithoutPetInput | AppointmentPetLoverUpdateWithWhereUniqueWithoutPetInput[]
    updateMany?: AppointmentPetLoverUpdateManyWithWhereWithoutPetInput | AppointmentPetLoverUpdateManyWithWhereWithoutPetInput[]
    deleteMany?: AppointmentPetLoverScalarWhereInput | AppointmentPetLoverScalarWhereInput[]
  }

  export type UserPetLoverCreateNestedOneWithoutAppointmentPetLoverInput = {
    create?: XOR<UserPetLoverCreateWithoutAppointmentPetLoverInput, UserPetLoverUncheckedCreateWithoutAppointmentPetLoverInput>
    connectOrCreate?: UserPetLoverCreateOrConnectWithoutAppointmentPetLoverInput
    connect?: UserPetLoverWhereUniqueInput
  }

  export type PetPetLoverCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PetPetLoverCreateWithoutAppointmentsInput, PetPetLoverUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutAppointmentsInput
    connect?: PetPetLoverWhereUniqueInput
  }

  export type UserPetLoverUpdateOneRequiredWithoutAppointmentPetLoverNestedInput = {
    create?: XOR<UserPetLoverCreateWithoutAppointmentPetLoverInput, UserPetLoverUncheckedCreateWithoutAppointmentPetLoverInput>
    connectOrCreate?: UserPetLoverCreateOrConnectWithoutAppointmentPetLoverInput
    upsert?: UserPetLoverUpsertWithoutAppointmentPetLoverInput
    connect?: UserPetLoverWhereUniqueInput
    update?: XOR<XOR<UserPetLoverUpdateToOneWithWhereWithoutAppointmentPetLoverInput, UserPetLoverUpdateWithoutAppointmentPetLoverInput>, UserPetLoverUncheckedUpdateWithoutAppointmentPetLoverInput>
  }

  export type PetPetLoverUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PetPetLoverCreateWithoutAppointmentsInput, PetPetLoverUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutAppointmentsInput
    upsert?: PetPetLoverUpsertWithoutAppointmentsInput
    connect?: PetPetLoverWhereUniqueInput
    update?: XOR<XOR<PetPetLoverUpdateToOneWithWhereWithoutAppointmentsInput, PetPetLoverUpdateWithoutAppointmentsInput>, PetPetLoverUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PetPetLoverCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<PetPetLoverCreateWithoutVaccinationsInput, PetPetLoverUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutVaccinationsInput
    connect?: PetPetLoverWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PetPetLoverUpdateOneRequiredWithoutVaccinationsNestedInput = {
    create?: XOR<PetPetLoverCreateWithoutVaccinationsInput, PetPetLoverUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: PetPetLoverCreateOrConnectWithoutVaccinationsInput
    upsert?: PetPetLoverUpsertWithoutVaccinationsInput
    connect?: PetPetLoverWhereUniqueInput
    update?: XOR<XOR<PetPetLoverUpdateToOneWithWhereWithoutVaccinationsInput, PetPetLoverUpdateWithoutVaccinationsInput>, PetPetLoverUncheckedUpdateWithoutVaccinationsInput>
  }

  export type ElderlyCareCompanionAppointmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ElderlyCareCompanionAppointmentCreateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput> | ElderlyCareCompanionAppointmentCreateWithoutUserInput[] | ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput | ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput[]
    createMany?: ElderlyCareCompanionAppointmentCreateManyUserInputEnvelope
    connect?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
  }

  export type ElderlyCareCompanionRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<ElderlyCareCompanionRecordCreateWithoutUserInput, ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput> | ElderlyCareCompanionRecordCreateWithoutUserInput[] | ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput | ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput[]
    createMany?: ElderlyCareCompanionRecordCreateManyUserInputEnvelope
    connect?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
  }

  export type ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutUserInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyUserInputEnvelope
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
  }

  export type ElderlyCareCompanionAppointmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ElderlyCareCompanionAppointmentCreateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput> | ElderlyCareCompanionAppointmentCreateWithoutUserInput[] | ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput | ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput[]
    createMany?: ElderlyCareCompanionAppointmentCreateManyUserInputEnvelope
    connect?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
  }

  export type ElderlyCareCompanionRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ElderlyCareCompanionRecordCreateWithoutUserInput, ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput> | ElderlyCareCompanionRecordCreateWithoutUserInput[] | ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput | ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput[]
    createMany?: ElderlyCareCompanionRecordCreateManyUserInputEnvelope
    connect?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyUserInputEnvelope
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
  }

  export type ElderlyCareCompanionAppointmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ElderlyCareCompanionAppointmentCreateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput> | ElderlyCareCompanionAppointmentCreateWithoutUserInput[] | ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput | ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput[]
    upsert?: ElderlyCareCompanionAppointmentUpsertWithWhereUniqueWithoutUserInput | ElderlyCareCompanionAppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ElderlyCareCompanionAppointmentCreateManyUserInputEnvelope
    set?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    delete?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    connect?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    update?: ElderlyCareCompanionAppointmentUpdateWithWhereUniqueWithoutUserInput | ElderlyCareCompanionAppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ElderlyCareCompanionAppointmentUpdateManyWithWhereWithoutUserInput | ElderlyCareCompanionAppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ElderlyCareCompanionAppointmentScalarWhereInput | ElderlyCareCompanionAppointmentScalarWhereInput[]
  }

  export type ElderlyCareCompanionRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<ElderlyCareCompanionRecordCreateWithoutUserInput, ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput> | ElderlyCareCompanionRecordCreateWithoutUserInput[] | ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput | ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput[]
    upsert?: ElderlyCareCompanionRecordUpsertWithWhereUniqueWithoutUserInput | ElderlyCareCompanionRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ElderlyCareCompanionRecordCreateManyUserInputEnvelope
    set?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    delete?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    connect?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    update?: ElderlyCareCompanionRecordUpdateWithWhereUniqueWithoutUserInput | ElderlyCareCompanionRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ElderlyCareCompanionRecordUpdateManyWithWhereWithoutUserInput | ElderlyCareCompanionRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ElderlyCareCompanionRecordScalarWhereInput | ElderlyCareCompanionRecordScalarWhereInput[]
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput[]
    upsert?: ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutUserInput | ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyUserInputEnvelope
    set?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    delete?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    update?: ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutUserInput | ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutUserInput | ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ElderlyCareCompanionMedicationTrackingScalarWhereInput | ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
  }

  export type ElderlyCareCompanionAppointmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ElderlyCareCompanionAppointmentCreateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput> | ElderlyCareCompanionAppointmentCreateWithoutUserInput[] | ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput | ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput[]
    upsert?: ElderlyCareCompanionAppointmentUpsertWithWhereUniqueWithoutUserInput | ElderlyCareCompanionAppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ElderlyCareCompanionAppointmentCreateManyUserInputEnvelope
    set?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    delete?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    connect?: ElderlyCareCompanionAppointmentWhereUniqueInput | ElderlyCareCompanionAppointmentWhereUniqueInput[]
    update?: ElderlyCareCompanionAppointmentUpdateWithWhereUniqueWithoutUserInput | ElderlyCareCompanionAppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ElderlyCareCompanionAppointmentUpdateManyWithWhereWithoutUserInput | ElderlyCareCompanionAppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ElderlyCareCompanionAppointmentScalarWhereInput | ElderlyCareCompanionAppointmentScalarWhereInput[]
  }

  export type ElderlyCareCompanionRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ElderlyCareCompanionRecordCreateWithoutUserInput, ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput> | ElderlyCareCompanionRecordCreateWithoutUserInput[] | ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput | ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput[]
    upsert?: ElderlyCareCompanionRecordUpsertWithWhereUniqueWithoutUserInput | ElderlyCareCompanionRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ElderlyCareCompanionRecordCreateManyUserInputEnvelope
    set?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    delete?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    connect?: ElderlyCareCompanionRecordWhereUniqueInput | ElderlyCareCompanionRecordWhereUniqueInput[]
    update?: ElderlyCareCompanionRecordUpdateWithWhereUniqueWithoutUserInput | ElderlyCareCompanionRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ElderlyCareCompanionRecordUpdateManyWithWhereWithoutUserInput | ElderlyCareCompanionRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ElderlyCareCompanionRecordScalarWhereInput | ElderlyCareCompanionRecordScalarWhereInput[]
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput[]
    upsert?: ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutUserInput | ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyUserInputEnvelope
    set?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    delete?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    update?: ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutUserInput | ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutUserInput | ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ElderlyCareCompanionMedicationTrackingScalarWhereInput | ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
  }

  export type UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionAppointmentInput = {
    create?: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionAppointmentInput>
    connectOrCreate?: UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionAppointmentInput
    connect?: UserElderlyCareCompanionWhereUniqueInput
  }

  export type ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutMedicationInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyMedicationInputEnvelope
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyMedicationInputEnvelope
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
  }

  export type UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionAppointmentNestedInput = {
    create?: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionAppointmentInput>
    connectOrCreate?: UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionAppointmentInput
    upsert?: UserElderlyCareCompanionUpsertWithoutElderlyCareCompanionAppointmentInput
    connect?: UserElderlyCareCompanionWhereUniqueInput
    update?: XOR<XOR<UserElderlyCareCompanionUpdateToOneWithWhereWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionAppointmentInput>, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionAppointmentInput>
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput[]
    upsert?: ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyMedicationInputEnvelope
    set?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    delete?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    update?: ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: ElderlyCareCompanionMedicationTrackingScalarWhereInput | ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput> | ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput[] | ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput[]
    upsert?: ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: ElderlyCareCompanionMedicationTrackingCreateManyMedicationInputEnvelope
    set?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    disconnect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    delete?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    connect?: ElderlyCareCompanionMedicationTrackingWhereUniqueInput | ElderlyCareCompanionMedicationTrackingWhereUniqueInput[]
    update?: ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutMedicationInput | ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: ElderlyCareCompanionMedicationTrackingScalarWhereInput | ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
  }

  export type UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionRecordInput = {
    create?: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionRecordInput>
    connectOrCreate?: UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionRecordInput
    connect?: UserElderlyCareCompanionWhereUniqueInput
  }

  export type UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionRecordNestedInput = {
    create?: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionRecordInput>
    connectOrCreate?: UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionRecordInput
    upsert?: UserElderlyCareCompanionUpsertWithoutElderlyCareCompanionRecordInput
    connect?: UserElderlyCareCompanionWhereUniqueInput
    update?: XOR<XOR<UserElderlyCareCompanionUpdateToOneWithWhereWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionRecordInput>, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionRecordInput>
  }

  export type UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionMedicationTrackingInput = {
    create?: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionMedicationTrackingInput>
    connectOrCreate?: UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionMedicationTrackingInput
    connect?: UserElderlyCareCompanionWhereUniqueInput
  }

  export type ElderlyCareCompanionAppointmentCreateNestedOneWithoutMedicationLogsInput = {
    create?: XOR<ElderlyCareCompanionAppointmentCreateWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutMedicationLogsInput>
    connectOrCreate?: ElderlyCareCompanionAppointmentCreateOrConnectWithoutMedicationLogsInput
    connect?: ElderlyCareCompanionAppointmentWhereUniqueInput
  }

  export type UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionMedicationTrackingNestedInput = {
    create?: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionMedicationTrackingInput>
    connectOrCreate?: UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionMedicationTrackingInput
    upsert?: UserElderlyCareCompanionUpsertWithoutElderlyCareCompanionMedicationTrackingInput
    connect?: UserElderlyCareCompanionWhereUniqueInput
    update?: XOR<XOR<UserElderlyCareCompanionUpdateToOneWithWhereWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionMedicationTrackingInput>, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionMedicationTrackingInput>
  }

  export type ElderlyCareCompanionAppointmentUpdateOneRequiredWithoutMedicationLogsNestedInput = {
    create?: XOR<ElderlyCareCompanionAppointmentCreateWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutMedicationLogsInput>
    connectOrCreate?: ElderlyCareCompanionAppointmentCreateOrConnectWithoutMedicationLogsInput
    upsert?: ElderlyCareCompanionAppointmentUpsertWithoutMedicationLogsInput
    connect?: ElderlyCareCompanionAppointmentWhereUniqueInput
    update?: XOR<XOR<ElderlyCareCompanionAppointmentUpdateToOneWithWhereWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUpdateWithoutMedicationLogsInput>, ElderlyCareCompanionAppointmentUncheckedUpdateWithoutMedicationLogsInput>
  }

  export type PlatformEduSeekerCreateNestedManyWithoutSubmitterInput = {
    create?: XOR<PlatformEduSeekerCreateWithoutSubmitterInput, PlatformEduSeekerUncheckedCreateWithoutSubmitterInput> | PlatformEduSeekerCreateWithoutSubmitterInput[] | PlatformEduSeekerUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: PlatformEduSeekerCreateOrConnectWithoutSubmitterInput | PlatformEduSeekerCreateOrConnectWithoutSubmitterInput[]
    createMany?: PlatformEduSeekerCreateManySubmitterInputEnvelope
    connect?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
  }

  export type ReviewEduSeekerCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutUserInput, ReviewEduSeekerUncheckedCreateWithoutUserInput> | ReviewEduSeekerCreateWithoutUserInput[] | ReviewEduSeekerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutUserInput | ReviewEduSeekerCreateOrConnectWithoutUserInput[]
    createMany?: ReviewEduSeekerCreateManyUserInputEnvelope
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
  }

  export type PlatformEduSeekerUncheckedCreateNestedManyWithoutSubmitterInput = {
    create?: XOR<PlatformEduSeekerCreateWithoutSubmitterInput, PlatformEduSeekerUncheckedCreateWithoutSubmitterInput> | PlatformEduSeekerCreateWithoutSubmitterInput[] | PlatformEduSeekerUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: PlatformEduSeekerCreateOrConnectWithoutSubmitterInput | PlatformEduSeekerCreateOrConnectWithoutSubmitterInput[]
    createMany?: PlatformEduSeekerCreateManySubmitterInputEnvelope
    connect?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
  }

  export type ReviewEduSeekerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutUserInput, ReviewEduSeekerUncheckedCreateWithoutUserInput> | ReviewEduSeekerCreateWithoutUserInput[] | ReviewEduSeekerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutUserInput | ReviewEduSeekerCreateOrConnectWithoutUserInput[]
    createMany?: ReviewEduSeekerCreateManyUserInputEnvelope
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
  }

  export type PlatformEduSeekerUpdateManyWithoutSubmitterNestedInput = {
    create?: XOR<PlatformEduSeekerCreateWithoutSubmitterInput, PlatformEduSeekerUncheckedCreateWithoutSubmitterInput> | PlatformEduSeekerCreateWithoutSubmitterInput[] | PlatformEduSeekerUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: PlatformEduSeekerCreateOrConnectWithoutSubmitterInput | PlatformEduSeekerCreateOrConnectWithoutSubmitterInput[]
    upsert?: PlatformEduSeekerUpsertWithWhereUniqueWithoutSubmitterInput | PlatformEduSeekerUpsertWithWhereUniqueWithoutSubmitterInput[]
    createMany?: PlatformEduSeekerCreateManySubmitterInputEnvelope
    set?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    disconnect?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    delete?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    connect?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    update?: PlatformEduSeekerUpdateWithWhereUniqueWithoutSubmitterInput | PlatformEduSeekerUpdateWithWhereUniqueWithoutSubmitterInput[]
    updateMany?: PlatformEduSeekerUpdateManyWithWhereWithoutSubmitterInput | PlatformEduSeekerUpdateManyWithWhereWithoutSubmitterInput[]
    deleteMany?: PlatformEduSeekerScalarWhereInput | PlatformEduSeekerScalarWhereInput[]
  }

  export type ReviewEduSeekerUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutUserInput, ReviewEduSeekerUncheckedCreateWithoutUserInput> | ReviewEduSeekerCreateWithoutUserInput[] | ReviewEduSeekerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutUserInput | ReviewEduSeekerCreateOrConnectWithoutUserInput[]
    upsert?: ReviewEduSeekerUpsertWithWhereUniqueWithoutUserInput | ReviewEduSeekerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewEduSeekerCreateManyUserInputEnvelope
    set?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    disconnect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    delete?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    update?: ReviewEduSeekerUpdateWithWhereUniqueWithoutUserInput | ReviewEduSeekerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewEduSeekerUpdateManyWithWhereWithoutUserInput | ReviewEduSeekerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewEduSeekerScalarWhereInput | ReviewEduSeekerScalarWhereInput[]
  }

  export type PlatformEduSeekerUncheckedUpdateManyWithoutSubmitterNestedInput = {
    create?: XOR<PlatformEduSeekerCreateWithoutSubmitterInput, PlatformEduSeekerUncheckedCreateWithoutSubmitterInput> | PlatformEduSeekerCreateWithoutSubmitterInput[] | PlatformEduSeekerUncheckedCreateWithoutSubmitterInput[]
    connectOrCreate?: PlatformEduSeekerCreateOrConnectWithoutSubmitterInput | PlatformEduSeekerCreateOrConnectWithoutSubmitterInput[]
    upsert?: PlatformEduSeekerUpsertWithWhereUniqueWithoutSubmitterInput | PlatformEduSeekerUpsertWithWhereUniqueWithoutSubmitterInput[]
    createMany?: PlatformEduSeekerCreateManySubmitterInputEnvelope
    set?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    disconnect?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    delete?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    connect?: PlatformEduSeekerWhereUniqueInput | PlatformEduSeekerWhereUniqueInput[]
    update?: PlatformEduSeekerUpdateWithWhereUniqueWithoutSubmitterInput | PlatformEduSeekerUpdateWithWhereUniqueWithoutSubmitterInput[]
    updateMany?: PlatformEduSeekerUpdateManyWithWhereWithoutSubmitterInput | PlatformEduSeekerUpdateManyWithWhereWithoutSubmitterInput[]
    deleteMany?: PlatformEduSeekerScalarWhereInput | PlatformEduSeekerScalarWhereInput[]
  }

  export type ReviewEduSeekerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutUserInput, ReviewEduSeekerUncheckedCreateWithoutUserInput> | ReviewEduSeekerCreateWithoutUserInput[] | ReviewEduSeekerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutUserInput | ReviewEduSeekerCreateOrConnectWithoutUserInput[]
    upsert?: ReviewEduSeekerUpsertWithWhereUniqueWithoutUserInput | ReviewEduSeekerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewEduSeekerCreateManyUserInputEnvelope
    set?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    disconnect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    delete?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    update?: ReviewEduSeekerUpdateWithWhereUniqueWithoutUserInput | ReviewEduSeekerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewEduSeekerUpdateManyWithWhereWithoutUserInput | ReviewEduSeekerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewEduSeekerScalarWhereInput | ReviewEduSeekerScalarWhereInput[]
  }

  export type UserEduSeekerCreateNestedOneWithoutPlatformsInput = {
    create?: XOR<UserEduSeekerCreateWithoutPlatformsInput, UserEduSeekerUncheckedCreateWithoutPlatformsInput>
    connectOrCreate?: UserEduSeekerCreateOrConnectWithoutPlatformsInput
    connect?: UserEduSeekerWhereUniqueInput
  }

  export type ReviewEduSeekerCreateNestedManyWithoutPlatformInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutPlatformInput, ReviewEduSeekerUncheckedCreateWithoutPlatformInput> | ReviewEduSeekerCreateWithoutPlatformInput[] | ReviewEduSeekerUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutPlatformInput | ReviewEduSeekerCreateOrConnectWithoutPlatformInput[]
    createMany?: ReviewEduSeekerCreateManyPlatformInputEnvelope
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
  }

  export type ReviewEduSeekerUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutPlatformInput, ReviewEduSeekerUncheckedCreateWithoutPlatformInput> | ReviewEduSeekerCreateWithoutPlatformInput[] | ReviewEduSeekerUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutPlatformInput | ReviewEduSeekerCreateOrConnectWithoutPlatformInput[]
    createMany?: ReviewEduSeekerCreateManyPlatformInputEnvelope
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
  }

  export type UserEduSeekerUpdateOneRequiredWithoutPlatformsNestedInput = {
    create?: XOR<UserEduSeekerCreateWithoutPlatformsInput, UserEduSeekerUncheckedCreateWithoutPlatformsInput>
    connectOrCreate?: UserEduSeekerCreateOrConnectWithoutPlatformsInput
    upsert?: UserEduSeekerUpsertWithoutPlatformsInput
    connect?: UserEduSeekerWhereUniqueInput
    update?: XOR<XOR<UserEduSeekerUpdateToOneWithWhereWithoutPlatformsInput, UserEduSeekerUpdateWithoutPlatformsInput>, UserEduSeekerUncheckedUpdateWithoutPlatformsInput>
  }

  export type ReviewEduSeekerUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutPlatformInput, ReviewEduSeekerUncheckedCreateWithoutPlatformInput> | ReviewEduSeekerCreateWithoutPlatformInput[] | ReviewEduSeekerUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutPlatformInput | ReviewEduSeekerCreateOrConnectWithoutPlatformInput[]
    upsert?: ReviewEduSeekerUpsertWithWhereUniqueWithoutPlatformInput | ReviewEduSeekerUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: ReviewEduSeekerCreateManyPlatformInputEnvelope
    set?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    disconnect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    delete?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    update?: ReviewEduSeekerUpdateWithWhereUniqueWithoutPlatformInput | ReviewEduSeekerUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: ReviewEduSeekerUpdateManyWithWhereWithoutPlatformInput | ReviewEduSeekerUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: ReviewEduSeekerScalarWhereInput | ReviewEduSeekerScalarWhereInput[]
  }

  export type ReviewEduSeekerUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<ReviewEduSeekerCreateWithoutPlatformInput, ReviewEduSeekerUncheckedCreateWithoutPlatformInput> | ReviewEduSeekerCreateWithoutPlatformInput[] | ReviewEduSeekerUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ReviewEduSeekerCreateOrConnectWithoutPlatformInput | ReviewEduSeekerCreateOrConnectWithoutPlatformInput[]
    upsert?: ReviewEduSeekerUpsertWithWhereUniqueWithoutPlatformInput | ReviewEduSeekerUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: ReviewEduSeekerCreateManyPlatformInputEnvelope
    set?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    disconnect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    delete?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    connect?: ReviewEduSeekerWhereUniqueInput | ReviewEduSeekerWhereUniqueInput[]
    update?: ReviewEduSeekerUpdateWithWhereUniqueWithoutPlatformInput | ReviewEduSeekerUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: ReviewEduSeekerUpdateManyWithWhereWithoutPlatformInput | ReviewEduSeekerUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: ReviewEduSeekerScalarWhereInput | ReviewEduSeekerScalarWhereInput[]
  }

  export type PlatformEduSeekerCreateNestedOneWithoutReviewsInput = {
    create?: XOR<PlatformEduSeekerCreateWithoutReviewsInput, PlatformEduSeekerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PlatformEduSeekerCreateOrConnectWithoutReviewsInput
    connect?: PlatformEduSeekerWhereUniqueInput
  }

  export type UserEduSeekerCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserEduSeekerCreateWithoutReviewsInput, UserEduSeekerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserEduSeekerCreateOrConnectWithoutReviewsInput
    connect?: UserEduSeekerWhereUniqueInput
  }

  export type PlatformEduSeekerUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<PlatformEduSeekerCreateWithoutReviewsInput, PlatformEduSeekerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PlatformEduSeekerCreateOrConnectWithoutReviewsInput
    upsert?: PlatformEduSeekerUpsertWithoutReviewsInput
    connect?: PlatformEduSeekerWhereUniqueInput
    update?: XOR<XOR<PlatformEduSeekerUpdateToOneWithWhereWithoutReviewsInput, PlatformEduSeekerUpdateWithoutReviewsInput>, PlatformEduSeekerUncheckedUpdateWithoutReviewsInput>
  }

  export type UserEduSeekerUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserEduSeekerCreateWithoutReviewsInput, UserEduSeekerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserEduSeekerCreateOrConnectWithoutReviewsInput
    upsert?: UserEduSeekerUpsertWithoutReviewsInput
    connect?: UserEduSeekerWhereUniqueInput
    update?: XOR<XOR<UserEduSeekerUpdateToOneWithWhereWithoutReviewsInput, UserEduSeekerUpdateWithoutReviewsInput>, UserEduSeekerUncheckedUpdateWithoutReviewsInput>
  }

  export type TransactionFinanceManagerCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionFinanceManagerCreateWithoutUserInput, TransactionFinanceManagerUncheckedCreateWithoutUserInput> | TransactionFinanceManagerCreateWithoutUserInput[] | TransactionFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionFinanceManagerCreateOrConnectWithoutUserInput | TransactionFinanceManagerCreateOrConnectWithoutUserInput[]
    createMany?: TransactionFinanceManagerCreateManyUserInputEnvelope
    connect?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
  }

  export type GoalFinanceManagerCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalFinanceManagerCreateWithoutUserInput, GoalFinanceManagerUncheckedCreateWithoutUserInput> | GoalFinanceManagerCreateWithoutUserInput[] | GoalFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalFinanceManagerCreateOrConnectWithoutUserInput | GoalFinanceManagerCreateOrConnectWithoutUserInput[]
    createMany?: GoalFinanceManagerCreateManyUserInputEnvelope
    connect?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
  }

  export type TransactionFinanceManagerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionFinanceManagerCreateWithoutUserInput, TransactionFinanceManagerUncheckedCreateWithoutUserInput> | TransactionFinanceManagerCreateWithoutUserInput[] | TransactionFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionFinanceManagerCreateOrConnectWithoutUserInput | TransactionFinanceManagerCreateOrConnectWithoutUserInput[]
    createMany?: TransactionFinanceManagerCreateManyUserInputEnvelope
    connect?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
  }

  export type GoalFinanceManagerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GoalFinanceManagerCreateWithoutUserInput, GoalFinanceManagerUncheckedCreateWithoutUserInput> | GoalFinanceManagerCreateWithoutUserInput[] | GoalFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalFinanceManagerCreateOrConnectWithoutUserInput | GoalFinanceManagerCreateOrConnectWithoutUserInput[]
    createMany?: GoalFinanceManagerCreateManyUserInputEnvelope
    connect?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
  }

  export type TransactionFinanceManagerUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionFinanceManagerCreateWithoutUserInput, TransactionFinanceManagerUncheckedCreateWithoutUserInput> | TransactionFinanceManagerCreateWithoutUserInput[] | TransactionFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionFinanceManagerCreateOrConnectWithoutUserInput | TransactionFinanceManagerCreateOrConnectWithoutUserInput[]
    upsert?: TransactionFinanceManagerUpsertWithWhereUniqueWithoutUserInput | TransactionFinanceManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionFinanceManagerCreateManyUserInputEnvelope
    set?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    disconnect?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    delete?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    connect?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    update?: TransactionFinanceManagerUpdateWithWhereUniqueWithoutUserInput | TransactionFinanceManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionFinanceManagerUpdateManyWithWhereWithoutUserInput | TransactionFinanceManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionFinanceManagerScalarWhereInput | TransactionFinanceManagerScalarWhereInput[]
  }

  export type GoalFinanceManagerUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalFinanceManagerCreateWithoutUserInput, GoalFinanceManagerUncheckedCreateWithoutUserInput> | GoalFinanceManagerCreateWithoutUserInput[] | GoalFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalFinanceManagerCreateOrConnectWithoutUserInput | GoalFinanceManagerCreateOrConnectWithoutUserInput[]
    upsert?: GoalFinanceManagerUpsertWithWhereUniqueWithoutUserInput | GoalFinanceManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalFinanceManagerCreateManyUserInputEnvelope
    set?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    disconnect?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    delete?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    connect?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    update?: GoalFinanceManagerUpdateWithWhereUniqueWithoutUserInput | GoalFinanceManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalFinanceManagerUpdateManyWithWhereWithoutUserInput | GoalFinanceManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalFinanceManagerScalarWhereInput | GoalFinanceManagerScalarWhereInput[]
  }

  export type TransactionFinanceManagerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionFinanceManagerCreateWithoutUserInput, TransactionFinanceManagerUncheckedCreateWithoutUserInput> | TransactionFinanceManagerCreateWithoutUserInput[] | TransactionFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionFinanceManagerCreateOrConnectWithoutUserInput | TransactionFinanceManagerCreateOrConnectWithoutUserInput[]
    upsert?: TransactionFinanceManagerUpsertWithWhereUniqueWithoutUserInput | TransactionFinanceManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionFinanceManagerCreateManyUserInputEnvelope
    set?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    disconnect?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    delete?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    connect?: TransactionFinanceManagerWhereUniqueInput | TransactionFinanceManagerWhereUniqueInput[]
    update?: TransactionFinanceManagerUpdateWithWhereUniqueWithoutUserInput | TransactionFinanceManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionFinanceManagerUpdateManyWithWhereWithoutUserInput | TransactionFinanceManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionFinanceManagerScalarWhereInput | TransactionFinanceManagerScalarWhereInput[]
  }

  export type GoalFinanceManagerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GoalFinanceManagerCreateWithoutUserInput, GoalFinanceManagerUncheckedCreateWithoutUserInput> | GoalFinanceManagerCreateWithoutUserInput[] | GoalFinanceManagerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GoalFinanceManagerCreateOrConnectWithoutUserInput | GoalFinanceManagerCreateOrConnectWithoutUserInput[]
    upsert?: GoalFinanceManagerUpsertWithWhereUniqueWithoutUserInput | GoalFinanceManagerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GoalFinanceManagerCreateManyUserInputEnvelope
    set?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    disconnect?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    delete?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    connect?: GoalFinanceManagerWhereUniqueInput | GoalFinanceManagerWhereUniqueInput[]
    update?: GoalFinanceManagerUpdateWithWhereUniqueWithoutUserInput | GoalFinanceManagerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GoalFinanceManagerUpdateManyWithWhereWithoutUserInput | GoalFinanceManagerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GoalFinanceManagerScalarWhereInput | GoalFinanceManagerScalarWhereInput[]
  }

  export type UserFinanceManagerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserFinanceManagerCreateWithoutTransactionsInput, UserFinanceManagerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserFinanceManagerCreateOrConnectWithoutTransactionsInput
    connect?: UserFinanceManagerWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserFinanceManagerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserFinanceManagerCreateWithoutTransactionsInput, UserFinanceManagerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserFinanceManagerCreateOrConnectWithoutTransactionsInput
    upsert?: UserFinanceManagerUpsertWithoutTransactionsInput
    connect?: UserFinanceManagerWhereUniqueInput
    update?: XOR<XOR<UserFinanceManagerUpdateToOneWithWhereWithoutTransactionsInput, UserFinanceManagerUpdateWithoutTransactionsInput>, UserFinanceManagerUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserFinanceManagerCreateNestedOneWithoutGoalsInput = {
    create?: XOR<UserFinanceManagerCreateWithoutGoalsInput, UserFinanceManagerUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: UserFinanceManagerCreateOrConnectWithoutGoalsInput
    connect?: UserFinanceManagerWhereUniqueInput
  }

  export type UserFinanceManagerUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<UserFinanceManagerCreateWithoutGoalsInput, UserFinanceManagerUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: UserFinanceManagerCreateOrConnectWithoutGoalsInput
    upsert?: UserFinanceManagerUpsertWithoutGoalsInput
    connect?: UserFinanceManagerWhereUniqueInput
    update?: XOR<XOR<UserFinanceManagerUpdateToOneWithWhereWithoutGoalsInput, UserFinanceManagerUpdateWithoutGoalsInput>, UserFinanceManagerUncheckedUpdateWithoutGoalsInput>
  }

  export type JournalMentalWellnessCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalMentalWellnessCreateWithoutUserInput, JournalMentalWellnessUncheckedCreateWithoutUserInput> | JournalMentalWellnessCreateWithoutUserInput[] | JournalMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalMentalWellnessCreateOrConnectWithoutUserInput | JournalMentalWellnessCreateOrConnectWithoutUserInput[]
    createMany?: JournalMentalWellnessCreateManyUserInputEnvelope
    connect?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
  }

  export type AssessmentMentalWellnessCreateNestedManyWithoutUserInput = {
    create?: XOR<AssessmentMentalWellnessCreateWithoutUserInput, AssessmentMentalWellnessUncheckedCreateWithoutUserInput> | AssessmentMentalWellnessCreateWithoutUserInput[] | AssessmentMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentMentalWellnessCreateOrConnectWithoutUserInput | AssessmentMentalWellnessCreateOrConnectWithoutUserInput[]
    createMany?: AssessmentMentalWellnessCreateManyUserInputEnvelope
    connect?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
  }

  export type MeditationFeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<MeditationFeedbackCreateWithoutUserInput, MeditationFeedbackUncheckedCreateWithoutUserInput> | MeditationFeedbackCreateWithoutUserInput[] | MeditationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutUserInput | MeditationFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: MeditationFeedbackCreateManyUserInputEnvelope
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
  }

  export type JournalMentalWellnessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalMentalWellnessCreateWithoutUserInput, JournalMentalWellnessUncheckedCreateWithoutUserInput> | JournalMentalWellnessCreateWithoutUserInput[] | JournalMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalMentalWellnessCreateOrConnectWithoutUserInput | JournalMentalWellnessCreateOrConnectWithoutUserInput[]
    createMany?: JournalMentalWellnessCreateManyUserInputEnvelope
    connect?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
  }

  export type AssessmentMentalWellnessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AssessmentMentalWellnessCreateWithoutUserInput, AssessmentMentalWellnessUncheckedCreateWithoutUserInput> | AssessmentMentalWellnessCreateWithoutUserInput[] | AssessmentMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentMentalWellnessCreateOrConnectWithoutUserInput | AssessmentMentalWellnessCreateOrConnectWithoutUserInput[]
    createMany?: AssessmentMentalWellnessCreateManyUserInputEnvelope
    connect?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
  }

  export type MeditationFeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MeditationFeedbackCreateWithoutUserInput, MeditationFeedbackUncheckedCreateWithoutUserInput> | MeditationFeedbackCreateWithoutUserInput[] | MeditationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutUserInput | MeditationFeedbackCreateOrConnectWithoutUserInput[]
    createMany?: MeditationFeedbackCreateManyUserInputEnvelope
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
  }

  export type JournalMentalWellnessUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalMentalWellnessCreateWithoutUserInput, JournalMentalWellnessUncheckedCreateWithoutUserInput> | JournalMentalWellnessCreateWithoutUserInput[] | JournalMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalMentalWellnessCreateOrConnectWithoutUserInput | JournalMentalWellnessCreateOrConnectWithoutUserInput[]
    upsert?: JournalMentalWellnessUpsertWithWhereUniqueWithoutUserInput | JournalMentalWellnessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalMentalWellnessCreateManyUserInputEnvelope
    set?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    disconnect?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    delete?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    connect?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    update?: JournalMentalWellnessUpdateWithWhereUniqueWithoutUserInput | JournalMentalWellnessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalMentalWellnessUpdateManyWithWhereWithoutUserInput | JournalMentalWellnessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalMentalWellnessScalarWhereInput | JournalMentalWellnessScalarWhereInput[]
  }

  export type AssessmentMentalWellnessUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssessmentMentalWellnessCreateWithoutUserInput, AssessmentMentalWellnessUncheckedCreateWithoutUserInput> | AssessmentMentalWellnessCreateWithoutUserInput[] | AssessmentMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentMentalWellnessCreateOrConnectWithoutUserInput | AssessmentMentalWellnessCreateOrConnectWithoutUserInput[]
    upsert?: AssessmentMentalWellnessUpsertWithWhereUniqueWithoutUserInput | AssessmentMentalWellnessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssessmentMentalWellnessCreateManyUserInputEnvelope
    set?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    disconnect?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    delete?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    connect?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    update?: AssessmentMentalWellnessUpdateWithWhereUniqueWithoutUserInput | AssessmentMentalWellnessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssessmentMentalWellnessUpdateManyWithWhereWithoutUserInput | AssessmentMentalWellnessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssessmentMentalWellnessScalarWhereInput | AssessmentMentalWellnessScalarWhereInput[]
  }

  export type MeditationFeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeditationFeedbackCreateWithoutUserInput, MeditationFeedbackUncheckedCreateWithoutUserInput> | MeditationFeedbackCreateWithoutUserInput[] | MeditationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutUserInput | MeditationFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: MeditationFeedbackUpsertWithWhereUniqueWithoutUserInput | MeditationFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeditationFeedbackCreateManyUserInputEnvelope
    set?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    disconnect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    delete?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    update?: MeditationFeedbackUpdateWithWhereUniqueWithoutUserInput | MeditationFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeditationFeedbackUpdateManyWithWhereWithoutUserInput | MeditationFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeditationFeedbackScalarWhereInput | MeditationFeedbackScalarWhereInput[]
  }

  export type JournalMentalWellnessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalMentalWellnessCreateWithoutUserInput, JournalMentalWellnessUncheckedCreateWithoutUserInput> | JournalMentalWellnessCreateWithoutUserInput[] | JournalMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalMentalWellnessCreateOrConnectWithoutUserInput | JournalMentalWellnessCreateOrConnectWithoutUserInput[]
    upsert?: JournalMentalWellnessUpsertWithWhereUniqueWithoutUserInput | JournalMentalWellnessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalMentalWellnessCreateManyUserInputEnvelope
    set?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    disconnect?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    delete?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    connect?: JournalMentalWellnessWhereUniqueInput | JournalMentalWellnessWhereUniqueInput[]
    update?: JournalMentalWellnessUpdateWithWhereUniqueWithoutUserInput | JournalMentalWellnessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalMentalWellnessUpdateManyWithWhereWithoutUserInput | JournalMentalWellnessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalMentalWellnessScalarWhereInput | JournalMentalWellnessScalarWhereInput[]
  }

  export type AssessmentMentalWellnessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssessmentMentalWellnessCreateWithoutUserInput, AssessmentMentalWellnessUncheckedCreateWithoutUserInput> | AssessmentMentalWellnessCreateWithoutUserInput[] | AssessmentMentalWellnessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentMentalWellnessCreateOrConnectWithoutUserInput | AssessmentMentalWellnessCreateOrConnectWithoutUserInput[]
    upsert?: AssessmentMentalWellnessUpsertWithWhereUniqueWithoutUserInput | AssessmentMentalWellnessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssessmentMentalWellnessCreateManyUserInputEnvelope
    set?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    disconnect?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    delete?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    connect?: AssessmentMentalWellnessWhereUniqueInput | AssessmentMentalWellnessWhereUniqueInput[]
    update?: AssessmentMentalWellnessUpdateWithWhereUniqueWithoutUserInput | AssessmentMentalWellnessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssessmentMentalWellnessUpdateManyWithWhereWithoutUserInput | AssessmentMentalWellnessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssessmentMentalWellnessScalarWhereInput | AssessmentMentalWellnessScalarWhereInput[]
  }

  export type MeditationFeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeditationFeedbackCreateWithoutUserInput, MeditationFeedbackUncheckedCreateWithoutUserInput> | MeditationFeedbackCreateWithoutUserInput[] | MeditationFeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutUserInput | MeditationFeedbackCreateOrConnectWithoutUserInput[]
    upsert?: MeditationFeedbackUpsertWithWhereUniqueWithoutUserInput | MeditationFeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeditationFeedbackCreateManyUserInputEnvelope
    set?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    disconnect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    delete?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    update?: MeditationFeedbackUpdateWithWhereUniqueWithoutUserInput | MeditationFeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeditationFeedbackUpdateManyWithWhereWithoutUserInput | MeditationFeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeditationFeedbackScalarWhereInput | MeditationFeedbackScalarWhereInput[]
  }

  export type JournalMentalWellnessCreatetagsInput = {
    set: string[]
  }

  export type UserMentalWellnessCreateNestedOneWithoutJournalsInput = {
    create?: XOR<UserMentalWellnessCreateWithoutJournalsInput, UserMentalWellnessUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: UserMentalWellnessCreateOrConnectWithoutJournalsInput
    connect?: UserMentalWellnessWhereUniqueInput
  }

  export type JournalMentalWellnessUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserMentalWellnessUpdateOneRequiredWithoutJournalsNestedInput = {
    create?: XOR<UserMentalWellnessCreateWithoutJournalsInput, UserMentalWellnessUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: UserMentalWellnessCreateOrConnectWithoutJournalsInput
    upsert?: UserMentalWellnessUpsertWithoutJournalsInput
    connect?: UserMentalWellnessWhereUniqueInput
    update?: XOR<XOR<UserMentalWellnessUpdateToOneWithWhereWithoutJournalsInput, UserMentalWellnessUpdateWithoutJournalsInput>, UserMentalWellnessUncheckedUpdateWithoutJournalsInput>
  }

  export type UserMentalWellnessCreateNestedOneWithoutAssessmentsInput = {
    create?: XOR<UserMentalWellnessCreateWithoutAssessmentsInput, UserMentalWellnessUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: UserMentalWellnessCreateOrConnectWithoutAssessmentsInput
    connect?: UserMentalWellnessWhereUniqueInput
  }

  export type UserMentalWellnessUpdateOneRequiredWithoutAssessmentsNestedInput = {
    create?: XOR<UserMentalWellnessCreateWithoutAssessmentsInput, UserMentalWellnessUncheckedCreateWithoutAssessmentsInput>
    connectOrCreate?: UserMentalWellnessCreateOrConnectWithoutAssessmentsInput
    upsert?: UserMentalWellnessUpsertWithoutAssessmentsInput
    connect?: UserMentalWellnessWhereUniqueInput
    update?: XOR<XOR<UserMentalWellnessUpdateToOneWithWhereWithoutAssessmentsInput, UserMentalWellnessUpdateWithoutAssessmentsInput>, UserMentalWellnessUncheckedUpdateWithoutAssessmentsInput>
  }

  export type MeditationFeedbackCreateNestedManyWithoutMeditationInput = {
    create?: XOR<MeditationFeedbackCreateWithoutMeditationInput, MeditationFeedbackUncheckedCreateWithoutMeditationInput> | MeditationFeedbackCreateWithoutMeditationInput[] | MeditationFeedbackUncheckedCreateWithoutMeditationInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutMeditationInput | MeditationFeedbackCreateOrConnectWithoutMeditationInput[]
    createMany?: MeditationFeedbackCreateManyMeditationInputEnvelope
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
  }

  export type MeditationFeedbackUncheckedCreateNestedManyWithoutMeditationInput = {
    create?: XOR<MeditationFeedbackCreateWithoutMeditationInput, MeditationFeedbackUncheckedCreateWithoutMeditationInput> | MeditationFeedbackCreateWithoutMeditationInput[] | MeditationFeedbackUncheckedCreateWithoutMeditationInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutMeditationInput | MeditationFeedbackCreateOrConnectWithoutMeditationInput[]
    createMany?: MeditationFeedbackCreateManyMeditationInputEnvelope
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
  }

  export type MeditationFeedbackUpdateManyWithoutMeditationNestedInput = {
    create?: XOR<MeditationFeedbackCreateWithoutMeditationInput, MeditationFeedbackUncheckedCreateWithoutMeditationInput> | MeditationFeedbackCreateWithoutMeditationInput[] | MeditationFeedbackUncheckedCreateWithoutMeditationInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutMeditationInput | MeditationFeedbackCreateOrConnectWithoutMeditationInput[]
    upsert?: MeditationFeedbackUpsertWithWhereUniqueWithoutMeditationInput | MeditationFeedbackUpsertWithWhereUniqueWithoutMeditationInput[]
    createMany?: MeditationFeedbackCreateManyMeditationInputEnvelope
    set?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    disconnect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    delete?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    update?: MeditationFeedbackUpdateWithWhereUniqueWithoutMeditationInput | MeditationFeedbackUpdateWithWhereUniqueWithoutMeditationInput[]
    updateMany?: MeditationFeedbackUpdateManyWithWhereWithoutMeditationInput | MeditationFeedbackUpdateManyWithWhereWithoutMeditationInput[]
    deleteMany?: MeditationFeedbackScalarWhereInput | MeditationFeedbackScalarWhereInput[]
  }

  export type MeditationFeedbackUncheckedUpdateManyWithoutMeditationNestedInput = {
    create?: XOR<MeditationFeedbackCreateWithoutMeditationInput, MeditationFeedbackUncheckedCreateWithoutMeditationInput> | MeditationFeedbackCreateWithoutMeditationInput[] | MeditationFeedbackUncheckedCreateWithoutMeditationInput[]
    connectOrCreate?: MeditationFeedbackCreateOrConnectWithoutMeditationInput | MeditationFeedbackCreateOrConnectWithoutMeditationInput[]
    upsert?: MeditationFeedbackUpsertWithWhereUniqueWithoutMeditationInput | MeditationFeedbackUpsertWithWhereUniqueWithoutMeditationInput[]
    createMany?: MeditationFeedbackCreateManyMeditationInputEnvelope
    set?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    disconnect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    delete?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    connect?: MeditationFeedbackWhereUniqueInput | MeditationFeedbackWhereUniqueInput[]
    update?: MeditationFeedbackUpdateWithWhereUniqueWithoutMeditationInput | MeditationFeedbackUpdateWithWhereUniqueWithoutMeditationInput[]
    updateMany?: MeditationFeedbackUpdateManyWithWhereWithoutMeditationInput | MeditationFeedbackUpdateManyWithWhereWithoutMeditationInput[]
    deleteMany?: MeditationFeedbackScalarWhereInput | MeditationFeedbackScalarWhereInput[]
  }

  export type UserMentalWellnessCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserMentalWellnessCreateWithoutFeedbacksInput, UserMentalWellnessUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserMentalWellnessCreateOrConnectWithoutFeedbacksInput
    connect?: UserMentalWellnessWhereUniqueInput
  }

  export type MeditationCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<MeditationCreateWithoutFeedbacksInput, MeditationUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: MeditationCreateOrConnectWithoutFeedbacksInput
    connect?: MeditationWhereUniqueInput
  }

  export type UserMentalWellnessUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserMentalWellnessCreateWithoutFeedbacksInput, UserMentalWellnessUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserMentalWellnessCreateOrConnectWithoutFeedbacksInput
    upsert?: UserMentalWellnessUpsertWithoutFeedbacksInput
    connect?: UserMentalWellnessWhereUniqueInput
    update?: XOR<XOR<UserMentalWellnessUpdateToOneWithWhereWithoutFeedbacksInput, UserMentalWellnessUpdateWithoutFeedbacksInput>, UserMentalWellnessUncheckedUpdateWithoutFeedbacksInput>
  }

  export type MeditationUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<MeditationCreateWithoutFeedbacksInput, MeditationUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: MeditationCreateOrConnectWithoutFeedbacksInput
    upsert?: MeditationUpsertWithoutFeedbacksInput
    connect?: MeditationWhereUniqueInput
    update?: XOR<XOR<MeditationUpdateToOneWithWhereWithoutFeedbacksInput, MeditationUpdateWithoutFeedbacksInput>, MeditationUncheckedUpdateWithoutFeedbacksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PostDIYHomesCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    reviews?: ReviewDIYHomesCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    reviews?: ReviewDIYHomesUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesCreateOrConnectWithoutUserInput = {
    where: PostDIYHomesWhereUniqueInput
    create: XOR<PostDIYHomesCreateWithoutUserInput, PostDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type PostDIYHomesCreateManyUserInputEnvelope = {
    data: PostDIYHomesCreateManyUserInput | PostDIYHomesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewDIYHomesCreateWithoutUserInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    post: PostDIYHomesCreateNestedOneWithoutReviewsInput
    Report?: ReportDIYHomesCreateNestedManyWithoutReviewInput
  }

  export type ReviewDIYHomesUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    rating: number
    comment: string
    createdAt?: Date | string
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewDIYHomesCreateOrConnectWithoutUserInput = {
    where: ReviewDIYHomesWhereUniqueInput
    create: XOR<ReviewDIYHomesCreateWithoutUserInput, ReviewDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type ReviewDIYHomesCreateManyUserInputEnvelope = {
    data: ReviewDIYHomesCreateManyUserInput | ReviewDIYHomesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeDIYHomesCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    post: PostDIYHomesCreateNestedOneWithoutLikeInput
  }

  export type LikeDIYHomesUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type LikeDIYHomesCreateOrConnectWithoutUserInput = {
    where: LikeDIYHomesWhereUniqueInput
    create: XOR<LikeDIYHomesCreateWithoutUserInput, LikeDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type LikeDIYHomesCreateManyUserInputEnvelope = {
    data: LikeDIYHomesCreateManyUserInput | LikeDIYHomesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkDIYHomesCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    post: PostDIYHomesCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkDIYHomesUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type BookmarkDIYHomesCreateOrConnectWithoutUserInput = {
    where: BookmarkDIYHomesWhereUniqueInput
    create: XOR<BookmarkDIYHomesCreateWithoutUserInput, BookmarkDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type BookmarkDIYHomesCreateManyUserInputEnvelope = {
    data: BookmarkDIYHomesCreateManyUserInput | BookmarkDIYHomesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportDIYHomesCreateWithoutUserInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    post?: PostDIYHomesCreateNestedOneWithoutReportInput
    review?: ReviewDIYHomesCreateNestedOneWithoutReportInput
  }

  export type ReportDIYHomesUncheckedCreateWithoutUserInput = {
    id?: string
    postId?: string | null
    reviewId?: string | null
    reason: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesCreateOrConnectWithoutUserInput = {
    where: ReportDIYHomesWhereUniqueInput
    create: XOR<ReportDIYHomesCreateWithoutUserInput, ReportDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type ReportDIYHomesCreateManyUserInputEnvelope = {
    data: ReportDIYHomesCreateManyUserInput | ReportDIYHomesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostDIYHomesUpsertWithWhereUniqueWithoutUserInput = {
    where: PostDIYHomesWhereUniqueInput
    update: XOR<PostDIYHomesUpdateWithoutUserInput, PostDIYHomesUncheckedUpdateWithoutUserInput>
    create: XOR<PostDIYHomesCreateWithoutUserInput, PostDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type PostDIYHomesUpdateWithWhereUniqueWithoutUserInput = {
    where: PostDIYHomesWhereUniqueInput
    data: XOR<PostDIYHomesUpdateWithoutUserInput, PostDIYHomesUncheckedUpdateWithoutUserInput>
  }

  export type PostDIYHomesUpdateManyWithWhereWithoutUserInput = {
    where: PostDIYHomesScalarWhereInput
    data: XOR<PostDIYHomesUpdateManyMutationInput, PostDIYHomesUncheckedUpdateManyWithoutUserInput>
  }

  export type PostDIYHomesScalarWhereInput = {
    AND?: PostDIYHomesScalarWhereInput | PostDIYHomesScalarWhereInput[]
    OR?: PostDIYHomesScalarWhereInput[]
    NOT?: PostDIYHomesScalarWhereInput | PostDIYHomesScalarWhereInput[]
    id?: StringFilter<"PostDIYHomes"> | string
    title?: StringFilter<"PostDIYHomes"> | string
    content?: StringFilter<"PostDIYHomes"> | string
    category?: StringFilter<"PostDIYHomes"> | string
    userId?: StringFilter<"PostDIYHomes"> | string
    createdAt?: DateTimeFilter<"PostDIYHomes"> | Date | string
  }

  export type ReviewDIYHomesUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewDIYHomesWhereUniqueInput
    update: XOR<ReviewDIYHomesUpdateWithoutUserInput, ReviewDIYHomesUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewDIYHomesCreateWithoutUserInput, ReviewDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type ReviewDIYHomesUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewDIYHomesWhereUniqueInput
    data: XOR<ReviewDIYHomesUpdateWithoutUserInput, ReviewDIYHomesUncheckedUpdateWithoutUserInput>
  }

  export type ReviewDIYHomesUpdateManyWithWhereWithoutUserInput = {
    where: ReviewDIYHomesScalarWhereInput
    data: XOR<ReviewDIYHomesUpdateManyMutationInput, ReviewDIYHomesUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewDIYHomesScalarWhereInput = {
    AND?: ReviewDIYHomesScalarWhereInput | ReviewDIYHomesScalarWhereInput[]
    OR?: ReviewDIYHomesScalarWhereInput[]
    NOT?: ReviewDIYHomesScalarWhereInput | ReviewDIYHomesScalarWhereInput[]
    id?: StringFilter<"ReviewDIYHomes"> | string
    postId?: StringFilter<"ReviewDIYHomes"> | string
    userId?: StringFilter<"ReviewDIYHomes"> | string
    rating?: IntFilter<"ReviewDIYHomes"> | number
    comment?: StringFilter<"ReviewDIYHomes"> | string
    createdAt?: DateTimeFilter<"ReviewDIYHomes"> | Date | string
  }

  export type LikeDIYHomesUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeDIYHomesWhereUniqueInput
    update: XOR<LikeDIYHomesUpdateWithoutUserInput, LikeDIYHomesUncheckedUpdateWithoutUserInput>
    create: XOR<LikeDIYHomesCreateWithoutUserInput, LikeDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type LikeDIYHomesUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeDIYHomesWhereUniqueInput
    data: XOR<LikeDIYHomesUpdateWithoutUserInput, LikeDIYHomesUncheckedUpdateWithoutUserInput>
  }

  export type LikeDIYHomesUpdateManyWithWhereWithoutUserInput = {
    where: LikeDIYHomesScalarWhereInput
    data: XOR<LikeDIYHomesUpdateManyMutationInput, LikeDIYHomesUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeDIYHomesScalarWhereInput = {
    AND?: LikeDIYHomesScalarWhereInput | LikeDIYHomesScalarWhereInput[]
    OR?: LikeDIYHomesScalarWhereInput[]
    NOT?: LikeDIYHomesScalarWhereInput | LikeDIYHomesScalarWhereInput[]
    id?: StringFilter<"LikeDIYHomes"> | string
    postId?: StringFilter<"LikeDIYHomes"> | string
    userId?: StringFilter<"LikeDIYHomes"> | string
    createdAt?: DateTimeFilter<"LikeDIYHomes"> | Date | string
  }

  export type BookmarkDIYHomesUpsertWithWhereUniqueWithoutUserInput = {
    where: BookmarkDIYHomesWhereUniqueInput
    update: XOR<BookmarkDIYHomesUpdateWithoutUserInput, BookmarkDIYHomesUncheckedUpdateWithoutUserInput>
    create: XOR<BookmarkDIYHomesCreateWithoutUserInput, BookmarkDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type BookmarkDIYHomesUpdateWithWhereUniqueWithoutUserInput = {
    where: BookmarkDIYHomesWhereUniqueInput
    data: XOR<BookmarkDIYHomesUpdateWithoutUserInput, BookmarkDIYHomesUncheckedUpdateWithoutUserInput>
  }

  export type BookmarkDIYHomesUpdateManyWithWhereWithoutUserInput = {
    where: BookmarkDIYHomesScalarWhereInput
    data: XOR<BookmarkDIYHomesUpdateManyMutationInput, BookmarkDIYHomesUncheckedUpdateManyWithoutUserInput>
  }

  export type BookmarkDIYHomesScalarWhereInput = {
    AND?: BookmarkDIYHomesScalarWhereInput | BookmarkDIYHomesScalarWhereInput[]
    OR?: BookmarkDIYHomesScalarWhereInput[]
    NOT?: BookmarkDIYHomesScalarWhereInput | BookmarkDIYHomesScalarWhereInput[]
    id?: StringFilter<"BookmarkDIYHomes"> | string
    postId?: StringFilter<"BookmarkDIYHomes"> | string
    userId?: StringFilter<"BookmarkDIYHomes"> | string
    createdAt?: DateTimeFilter<"BookmarkDIYHomes"> | Date | string
  }

  export type ReportDIYHomesUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportDIYHomesWhereUniqueInput
    update: XOR<ReportDIYHomesUpdateWithoutUserInput, ReportDIYHomesUncheckedUpdateWithoutUserInput>
    create: XOR<ReportDIYHomesCreateWithoutUserInput, ReportDIYHomesUncheckedCreateWithoutUserInput>
  }

  export type ReportDIYHomesUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportDIYHomesWhereUniqueInput
    data: XOR<ReportDIYHomesUpdateWithoutUserInput, ReportDIYHomesUncheckedUpdateWithoutUserInput>
  }

  export type ReportDIYHomesUpdateManyWithWhereWithoutUserInput = {
    where: ReportDIYHomesScalarWhereInput
    data: XOR<ReportDIYHomesUpdateManyMutationInput, ReportDIYHomesUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportDIYHomesScalarWhereInput = {
    AND?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
    OR?: ReportDIYHomesScalarWhereInput[]
    NOT?: ReportDIYHomesScalarWhereInput | ReportDIYHomesScalarWhereInput[]
    id?: StringFilter<"ReportDIYHomes"> | string
    postId?: StringNullableFilter<"ReportDIYHomes"> | string | null
    reviewId?: StringNullableFilter<"ReportDIYHomes"> | string | null
    userId?: StringFilter<"ReportDIYHomes"> | string
    reason?: StringFilter<"ReportDIYHomes"> | string
    createdAt?: DateTimeFilter<"ReportDIYHomes"> | Date | string
  }

  export type UserDIYHomesCreateWithoutPostDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ReviewDIYHomes?: ReviewDIYHomesCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUncheckedCreateWithoutPostDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ReviewDIYHomes?: ReviewDIYHomesUncheckedCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesUncheckedCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesCreateOrConnectWithoutPostDIYHomesInput = {
    where: UserDIYHomesWhereUniqueInput
    create: XOR<UserDIYHomesCreateWithoutPostDIYHomesInput, UserDIYHomesUncheckedCreateWithoutPostDIYHomesInput>
  }

  export type ReviewDIYHomesCreateWithoutPostInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutReviewDIYHomesInput
    Report?: ReportDIYHomesCreateNestedManyWithoutReviewInput
  }

  export type ReviewDIYHomesUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewDIYHomesCreateOrConnectWithoutPostInput = {
    where: ReviewDIYHomesWhereUniqueInput
    create: XOR<ReviewDIYHomesCreateWithoutPostInput, ReviewDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type ReviewDIYHomesCreateManyPostInputEnvelope = {
    data: ReviewDIYHomesCreateManyPostInput | ReviewDIYHomesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkDIYHomesCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutBookmarkDIYHomesInput
  }

  export type BookmarkDIYHomesUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkDIYHomesCreateOrConnectWithoutPostInput = {
    where: BookmarkDIYHomesWhereUniqueInput
    create: XOR<BookmarkDIYHomesCreateWithoutPostInput, BookmarkDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type BookmarkDIYHomesCreateManyPostInputEnvelope = {
    data: BookmarkDIYHomesCreateManyPostInput | BookmarkDIYHomesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LikeDIYHomesCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutLikeDIYHomesInput
  }

  export type LikeDIYHomesUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeDIYHomesCreateOrConnectWithoutPostInput = {
    where: LikeDIYHomesWhereUniqueInput
    create: XOR<LikeDIYHomesCreateWithoutPostInput, LikeDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type LikeDIYHomesCreateManyPostInputEnvelope = {
    data: LikeDIYHomesCreateManyPostInput | LikeDIYHomesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ReportDIYHomesCreateWithoutPostInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutReportDIYHomesInput
    review?: ReviewDIYHomesCreateNestedOneWithoutReportInput
  }

  export type ReportDIYHomesUncheckedCreateWithoutPostInput = {
    id?: string
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesCreateOrConnectWithoutPostInput = {
    where: ReportDIYHomesWhereUniqueInput
    create: XOR<ReportDIYHomesCreateWithoutPostInput, ReportDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type ReportDIYHomesCreateManyPostInputEnvelope = {
    data: ReportDIYHomesCreateManyPostInput | ReportDIYHomesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserDIYHomesUpsertWithoutPostDIYHomesInput = {
    update: XOR<UserDIYHomesUpdateWithoutPostDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutPostDIYHomesInput>
    create: XOR<UserDIYHomesCreateWithoutPostDIYHomesInput, UserDIYHomesUncheckedCreateWithoutPostDIYHomesInput>
    where?: UserDIYHomesWhereInput
  }

  export type UserDIYHomesUpdateToOneWithWhereWithoutPostDIYHomesInput = {
    where?: UserDIYHomesWhereInput
    data: XOR<UserDIYHomesUpdateWithoutPostDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutPostDIYHomesInput>
  }

  export type UserDIYHomesUpdateWithoutPostDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ReviewDIYHomes?: ReviewDIYHomesUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesUncheckedUpdateWithoutPostDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ReviewDIYHomes?: ReviewDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewDIYHomesUpsertWithWhereUniqueWithoutPostInput = {
    where: ReviewDIYHomesWhereUniqueInput
    update: XOR<ReviewDIYHomesUpdateWithoutPostInput, ReviewDIYHomesUncheckedUpdateWithoutPostInput>
    create: XOR<ReviewDIYHomesCreateWithoutPostInput, ReviewDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type ReviewDIYHomesUpdateWithWhereUniqueWithoutPostInput = {
    where: ReviewDIYHomesWhereUniqueInput
    data: XOR<ReviewDIYHomesUpdateWithoutPostInput, ReviewDIYHomesUncheckedUpdateWithoutPostInput>
  }

  export type ReviewDIYHomesUpdateManyWithWhereWithoutPostInput = {
    where: ReviewDIYHomesScalarWhereInput
    data: XOR<ReviewDIYHomesUpdateManyMutationInput, ReviewDIYHomesUncheckedUpdateManyWithoutPostInput>
  }

  export type BookmarkDIYHomesUpsertWithWhereUniqueWithoutPostInput = {
    where: BookmarkDIYHomesWhereUniqueInput
    update: XOR<BookmarkDIYHomesUpdateWithoutPostInput, BookmarkDIYHomesUncheckedUpdateWithoutPostInput>
    create: XOR<BookmarkDIYHomesCreateWithoutPostInput, BookmarkDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type BookmarkDIYHomesUpdateWithWhereUniqueWithoutPostInput = {
    where: BookmarkDIYHomesWhereUniqueInput
    data: XOR<BookmarkDIYHomesUpdateWithoutPostInput, BookmarkDIYHomesUncheckedUpdateWithoutPostInput>
  }

  export type BookmarkDIYHomesUpdateManyWithWhereWithoutPostInput = {
    where: BookmarkDIYHomesScalarWhereInput
    data: XOR<BookmarkDIYHomesUpdateManyMutationInput, BookmarkDIYHomesUncheckedUpdateManyWithoutPostInput>
  }

  export type LikeDIYHomesUpsertWithWhereUniqueWithoutPostInput = {
    where: LikeDIYHomesWhereUniqueInput
    update: XOR<LikeDIYHomesUpdateWithoutPostInput, LikeDIYHomesUncheckedUpdateWithoutPostInput>
    create: XOR<LikeDIYHomesCreateWithoutPostInput, LikeDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type LikeDIYHomesUpdateWithWhereUniqueWithoutPostInput = {
    where: LikeDIYHomesWhereUniqueInput
    data: XOR<LikeDIYHomesUpdateWithoutPostInput, LikeDIYHomesUncheckedUpdateWithoutPostInput>
  }

  export type LikeDIYHomesUpdateManyWithWhereWithoutPostInput = {
    where: LikeDIYHomesScalarWhereInput
    data: XOR<LikeDIYHomesUpdateManyMutationInput, LikeDIYHomesUncheckedUpdateManyWithoutPostInput>
  }

  export type ReportDIYHomesUpsertWithWhereUniqueWithoutPostInput = {
    where: ReportDIYHomesWhereUniqueInput
    update: XOR<ReportDIYHomesUpdateWithoutPostInput, ReportDIYHomesUncheckedUpdateWithoutPostInput>
    create: XOR<ReportDIYHomesCreateWithoutPostInput, ReportDIYHomesUncheckedCreateWithoutPostInput>
  }

  export type ReportDIYHomesUpdateWithWhereUniqueWithoutPostInput = {
    where: ReportDIYHomesWhereUniqueInput
    data: XOR<ReportDIYHomesUpdateWithoutPostInput, ReportDIYHomesUncheckedUpdateWithoutPostInput>
  }

  export type ReportDIYHomesUpdateManyWithWhereWithoutPostInput = {
    where: ReportDIYHomesScalarWhereInput
    data: XOR<ReportDIYHomesUpdateManyMutationInput, ReportDIYHomesUncheckedUpdateManyWithoutPostInput>
  }

  export type UserDIYHomesCreateWithoutReviewDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUncheckedCreateWithoutReviewDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesUncheckedCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesUncheckedCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesCreateOrConnectWithoutReviewDIYHomesInput = {
    where: UserDIYHomesWhereUniqueInput
    create: XOR<UserDIYHomesCreateWithoutReviewDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReviewDIYHomesInput>
  }

  export type PostDIYHomesCreateWithoutReviewsInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutPostDIYHomesInput
    bookmarks?: BookmarkDIYHomesCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    content: string
    category: string
    userId: string
    createdAt?: Date | string
    bookmarks?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesCreateOrConnectWithoutReviewsInput = {
    where: PostDIYHomesWhereUniqueInput
    create: XOR<PostDIYHomesCreateWithoutReviewsInput, PostDIYHomesUncheckedCreateWithoutReviewsInput>
  }

  export type ReportDIYHomesCreateWithoutReviewInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutReportDIYHomesInput
    post?: PostDIYHomesCreateNestedOneWithoutReportInput
  }

  export type ReportDIYHomesUncheckedCreateWithoutReviewInput = {
    id?: string
    postId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesCreateOrConnectWithoutReviewInput = {
    where: ReportDIYHomesWhereUniqueInput
    create: XOR<ReportDIYHomesCreateWithoutReviewInput, ReportDIYHomesUncheckedCreateWithoutReviewInput>
  }

  export type ReportDIYHomesCreateManyReviewInputEnvelope = {
    data: ReportDIYHomesCreateManyReviewInput | ReportDIYHomesCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type UserDIYHomesUpsertWithoutReviewDIYHomesInput = {
    update: XOR<UserDIYHomesUpdateWithoutReviewDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutReviewDIYHomesInput>
    create: XOR<UserDIYHomesCreateWithoutReviewDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReviewDIYHomesInput>
    where?: UserDIYHomesWhereInput
  }

  export type UserDIYHomesUpdateToOneWithWhereWithoutReviewDIYHomesInput = {
    where?: UserDIYHomesWhereInput
    data: XOR<UserDIYHomesUpdateWithoutReviewDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutReviewDIYHomesInput>
  }

  export type UserDIYHomesUpdateWithoutReviewDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesUncheckedUpdateWithoutReviewDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostDIYHomesUpsertWithoutReviewsInput = {
    update: XOR<PostDIYHomesUpdateWithoutReviewsInput, PostDIYHomesUncheckedUpdateWithoutReviewsInput>
    create: XOR<PostDIYHomesCreateWithoutReviewsInput, PostDIYHomesUncheckedCreateWithoutReviewsInput>
    where?: PostDIYHomesWhereInput
  }

  export type PostDIYHomesUpdateToOneWithWhereWithoutReviewsInput = {
    where?: PostDIYHomesWhereInput
    data: XOR<PostDIYHomesUpdateWithoutReviewsInput, PostDIYHomesUncheckedUpdateWithoutReviewsInput>
  }

  export type PostDIYHomesUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutPostDIYHomesNestedInput
    bookmarks?: BookmarkDIYHomesUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookmarks?: BookmarkDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ReportDIYHomesUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReportDIYHomesWhereUniqueInput
    update: XOR<ReportDIYHomesUpdateWithoutReviewInput, ReportDIYHomesUncheckedUpdateWithoutReviewInput>
    create: XOR<ReportDIYHomesCreateWithoutReviewInput, ReportDIYHomesUncheckedCreateWithoutReviewInput>
  }

  export type ReportDIYHomesUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReportDIYHomesWhereUniqueInput
    data: XOR<ReportDIYHomesUpdateWithoutReviewInput, ReportDIYHomesUncheckedUpdateWithoutReviewInput>
  }

  export type ReportDIYHomesUpdateManyWithWhereWithoutReviewInput = {
    where: ReportDIYHomesScalarWhereInput
    data: XOR<ReportDIYHomesUpdateManyMutationInput, ReportDIYHomesUncheckedUpdateManyWithoutReviewInput>
  }

  export type UserDIYHomesCreateWithoutLikeDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUncheckedCreateWithoutLikeDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesCreateOrConnectWithoutLikeDIYHomesInput = {
    where: UserDIYHomesWhereUniqueInput
    create: XOR<UserDIYHomesCreateWithoutLikeDIYHomesInput, UserDIYHomesUncheckedCreateWithoutLikeDIYHomesInput>
  }

  export type PostDIYHomesCreateWithoutLikeInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutPostDIYHomesInput
    reviews?: ReviewDIYHomesCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUncheckedCreateWithoutLikeInput = {
    id?: string
    title: string
    content: string
    category: string
    userId: string
    createdAt?: Date | string
    reviews?: ReviewDIYHomesUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesCreateOrConnectWithoutLikeInput = {
    where: PostDIYHomesWhereUniqueInput
    create: XOR<PostDIYHomesCreateWithoutLikeInput, PostDIYHomesUncheckedCreateWithoutLikeInput>
  }

  export type UserDIYHomesUpsertWithoutLikeDIYHomesInput = {
    update: XOR<UserDIYHomesUpdateWithoutLikeDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutLikeDIYHomesInput>
    create: XOR<UserDIYHomesCreateWithoutLikeDIYHomesInput, UserDIYHomesUncheckedCreateWithoutLikeDIYHomesInput>
    where?: UserDIYHomesWhereInput
  }

  export type UserDIYHomesUpdateToOneWithWhereWithoutLikeDIYHomesInput = {
    where?: UserDIYHomesWhereInput
    data: XOR<UserDIYHomesUpdateWithoutLikeDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutLikeDIYHomesInput>
  }

  export type UserDIYHomesUpdateWithoutLikeDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesUncheckedUpdateWithoutLikeDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostDIYHomesUpsertWithoutLikeInput = {
    update: XOR<PostDIYHomesUpdateWithoutLikeInput, PostDIYHomesUncheckedUpdateWithoutLikeInput>
    create: XOR<PostDIYHomesCreateWithoutLikeInput, PostDIYHomesUncheckedCreateWithoutLikeInput>
    where?: PostDIYHomesWhereInput
  }

  export type PostDIYHomesUpdateToOneWithWhereWithoutLikeInput = {
    where?: PostDIYHomesWhereInput
    data: XOR<PostDIYHomesUpdateWithoutLikeInput, PostDIYHomesUncheckedUpdateWithoutLikeInput>
  }

  export type PostDIYHomesUpdateWithoutLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutPostDIYHomesNestedInput
    reviews?: ReviewDIYHomesUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateWithoutLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserDIYHomesCreateWithoutBookmarkDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUncheckedCreateWithoutBookmarkDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReportDIYHomes?: ReportDIYHomesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesCreateOrConnectWithoutBookmarkDIYHomesInput = {
    where: UserDIYHomesWhereUniqueInput
    create: XOR<UserDIYHomesCreateWithoutBookmarkDIYHomesInput, UserDIYHomesUncheckedCreateWithoutBookmarkDIYHomesInput>
  }

  export type PostDIYHomesCreateWithoutBookmarksInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutPostDIYHomesInput
    reviews?: ReviewDIYHomesCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUncheckedCreateWithoutBookmarksInput = {
    id?: string
    title: string
    content: string
    category: string
    userId: string
    createdAt?: Date | string
    reviews?: ReviewDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Report?: ReportDIYHomesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesCreateOrConnectWithoutBookmarksInput = {
    where: PostDIYHomesWhereUniqueInput
    create: XOR<PostDIYHomesCreateWithoutBookmarksInput, PostDIYHomesUncheckedCreateWithoutBookmarksInput>
  }

  export type UserDIYHomesUpsertWithoutBookmarkDIYHomesInput = {
    update: XOR<UserDIYHomesUpdateWithoutBookmarkDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutBookmarkDIYHomesInput>
    create: XOR<UserDIYHomesCreateWithoutBookmarkDIYHomesInput, UserDIYHomesUncheckedCreateWithoutBookmarkDIYHomesInput>
    where?: UserDIYHomesWhereInput
  }

  export type UserDIYHomesUpdateToOneWithWhereWithoutBookmarkDIYHomesInput = {
    where?: UserDIYHomesWhereInput
    data: XOR<UserDIYHomesUpdateWithoutBookmarkDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutBookmarkDIYHomesInput>
  }

  export type UserDIYHomesUpdateWithoutBookmarkDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesUncheckedUpdateWithoutBookmarkDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReportDIYHomes?: ReportDIYHomesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostDIYHomesUpsertWithoutBookmarksInput = {
    update: XOR<PostDIYHomesUpdateWithoutBookmarksInput, PostDIYHomesUncheckedUpdateWithoutBookmarksInput>
    create: XOR<PostDIYHomesCreateWithoutBookmarksInput, PostDIYHomesUncheckedCreateWithoutBookmarksInput>
    where?: PostDIYHomesWhereInput
  }

  export type PostDIYHomesUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: PostDIYHomesWhereInput
    data: XOR<PostDIYHomesUpdateWithoutBookmarksInput, PostDIYHomesUncheckedUpdateWithoutBookmarksInput>
  }

  export type PostDIYHomesUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutPostDIYHomesNestedInput
    reviews?: ReviewDIYHomesUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserDIYHomesCreateWithoutReportDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesUncheckedCreateWithoutReportDIYHomesInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PostDIYHomes?: PostDIYHomesUncheckedCreateNestedManyWithoutUserInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedCreateNestedManyWithoutUserInput
    LikeDIYHomes?: LikeDIYHomesUncheckedCreateNestedManyWithoutUserInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserDIYHomesCreateOrConnectWithoutReportDIYHomesInput = {
    where: UserDIYHomesWhereUniqueInput
    create: XOR<UserDIYHomesCreateWithoutReportDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReportDIYHomesInput>
  }

  export type PostDIYHomesCreateWithoutReportInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutPostDIYHomesInput
    reviews?: ReviewDIYHomesCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesUncheckedCreateWithoutReportInput = {
    id?: string
    title: string
    content: string
    category: string
    userId: string
    createdAt?: Date | string
    reviews?: ReviewDIYHomesUncheckedCreateNestedManyWithoutPostInput
    bookmarks?: BookmarkDIYHomesUncheckedCreateNestedManyWithoutPostInput
    Like?: LikeDIYHomesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostDIYHomesCreateOrConnectWithoutReportInput = {
    where: PostDIYHomesWhereUniqueInput
    create: XOR<PostDIYHomesCreateWithoutReportInput, PostDIYHomesUncheckedCreateWithoutReportInput>
  }

  export type ReviewDIYHomesCreateWithoutReportInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserDIYHomesCreateNestedOneWithoutReviewDIYHomesInput
    post: PostDIYHomesCreateNestedOneWithoutReviewsInput
  }

  export type ReviewDIYHomesUncheckedCreateWithoutReportInput = {
    id?: string
    postId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewDIYHomesCreateOrConnectWithoutReportInput = {
    where: ReviewDIYHomesWhereUniqueInput
    create: XOR<ReviewDIYHomesCreateWithoutReportInput, ReviewDIYHomesUncheckedCreateWithoutReportInput>
  }

  export type UserDIYHomesUpsertWithoutReportDIYHomesInput = {
    update: XOR<UserDIYHomesUpdateWithoutReportDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutReportDIYHomesInput>
    create: XOR<UserDIYHomesCreateWithoutReportDIYHomesInput, UserDIYHomesUncheckedCreateWithoutReportDIYHomesInput>
    where?: UserDIYHomesWhereInput
  }

  export type UserDIYHomesUpdateToOneWithWhereWithoutReportDIYHomesInput = {
    where?: UserDIYHomesWhereInput
    data: XOR<UserDIYHomesUpdateWithoutReportDIYHomesInput, UserDIYHomesUncheckedUpdateWithoutReportDIYHomesInput>
  }

  export type UserDIYHomesUpdateWithoutReportDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUpdateManyWithoutUserNestedInput
  }

  export type UserDIYHomesUncheckedUpdateWithoutReportDIYHomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PostDIYHomes?: PostDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    ReviewDIYHomes?: ReviewDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    LikeDIYHomes?: LikeDIYHomesUncheckedUpdateManyWithoutUserNestedInput
    BookmarkDIYHomes?: BookmarkDIYHomesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostDIYHomesUpsertWithoutReportInput = {
    update: XOR<PostDIYHomesUpdateWithoutReportInput, PostDIYHomesUncheckedUpdateWithoutReportInput>
    create: XOR<PostDIYHomesCreateWithoutReportInput, PostDIYHomesUncheckedCreateWithoutReportInput>
    where?: PostDIYHomesWhereInput
  }

  export type PostDIYHomesUpdateToOneWithWhereWithoutReportInput = {
    where?: PostDIYHomesWhereInput
    data: XOR<PostDIYHomesUpdateWithoutReportInput, PostDIYHomesUncheckedUpdateWithoutReportInput>
  }

  export type PostDIYHomesUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutPostDIYHomesNestedInput
    reviews?: ReviewDIYHomesUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ReviewDIYHomesUpsertWithoutReportInput = {
    update: XOR<ReviewDIYHomesUpdateWithoutReportInput, ReviewDIYHomesUncheckedUpdateWithoutReportInput>
    create: XOR<ReviewDIYHomesCreateWithoutReportInput, ReviewDIYHomesUncheckedCreateWithoutReportInput>
    where?: ReviewDIYHomesWhereInput
  }

  export type ReviewDIYHomesUpdateToOneWithWhereWithoutReportInput = {
    where?: ReviewDIYHomesWhereInput
    data: XOR<ReviewDIYHomesUpdateWithoutReportInput, ReviewDIYHomesUncheckedUpdateWithoutReportInput>
  }

  export type ReviewDIYHomesUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutReviewDIYHomesNestedInput
    post?: PostDIYHomesUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewDIYHomesUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUrbanExplorerCreateWithoutOwnerInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewUrbanExplorerCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerCreateOrConnectWithoutOwnerInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    create: XOR<PlaceUrbanExplorerCreateWithoutOwnerInput, PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput>
  }

  export type PlaceUrbanExplorerCreateManyOwnerInputEnvelope = {
    data: PlaceUrbanExplorerCreateManyOwnerInput | PlaceUrbanExplorerCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ReviewUrbanExplorerCreateWithoutUserInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    place: PlaceUrbanExplorerCreateNestedOneWithoutReviewsInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutReviewInput
  }

  export type ReviewUrbanExplorerUncheckedCreateWithoutUserInput = {
    id?: string
    placeId: string
    rating: number
    comment: string
    createdAt?: Date | string
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUrbanExplorerCreateOrConnectWithoutUserInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    create: XOR<ReviewUrbanExplorerCreateWithoutUserInput, ReviewUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type ReviewUrbanExplorerCreateManyUserInputEnvelope = {
    data: ReviewUrbanExplorerCreateManyUserInput | ReviewUrbanExplorerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeUrbanExplorerCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    place: PlaceUrbanExplorerCreateNestedOneWithoutLikesInput
  }

  export type LikeUrbanExplorerUncheckedCreateWithoutUserInput = {
    id?: string
    placeId: string
    createdAt?: Date | string
  }

  export type LikeUrbanExplorerCreateOrConnectWithoutUserInput = {
    where: LikeUrbanExplorerWhereUniqueInput
    create: XOR<LikeUrbanExplorerCreateWithoutUserInput, LikeUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type LikeUrbanExplorerCreateManyUserInputEnvelope = {
    data: LikeUrbanExplorerCreateManyUserInput | LikeUrbanExplorerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkUrbanExplorerCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    place: PlaceUrbanExplorerCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUrbanExplorerUncheckedCreateWithoutUserInput = {
    id?: string
    placeId: string
    createdAt?: Date | string
  }

  export type BookmarkUrbanExplorerCreateOrConnectWithoutUserInput = {
    where: BookmarkUrbanExplorerWhereUniqueInput
    create: XOR<BookmarkUrbanExplorerCreateWithoutUserInput, BookmarkUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type BookmarkUrbanExplorerCreateManyUserInputEnvelope = {
    data: BookmarkUrbanExplorerCreateManyUserInput | BookmarkUrbanExplorerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportUrbanExplorerCreateWithoutUserInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    place?: PlaceUrbanExplorerCreateNestedOneWithoutReportsInput
    review?: ReviewUrbanExplorerCreateNestedOneWithoutReportsInput
  }

  export type ReportUrbanExplorerUncheckedCreateWithoutUserInput = {
    id?: string
    placeId?: string | null
    reviewId?: string | null
    reason: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerCreateOrConnectWithoutUserInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    create: XOR<ReportUrbanExplorerCreateWithoutUserInput, ReportUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type ReportUrbanExplorerCreateManyUserInputEnvelope = {
    data: ReportUrbanExplorerCreateManyUserInput | ReportUrbanExplorerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlaceUrbanExplorerUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    update: XOR<PlaceUrbanExplorerUpdateWithoutOwnerInput, PlaceUrbanExplorerUncheckedUpdateWithoutOwnerInput>
    create: XOR<PlaceUrbanExplorerCreateWithoutOwnerInput, PlaceUrbanExplorerUncheckedCreateWithoutOwnerInput>
  }

  export type PlaceUrbanExplorerUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    data: XOR<PlaceUrbanExplorerUpdateWithoutOwnerInput, PlaceUrbanExplorerUncheckedUpdateWithoutOwnerInput>
  }

  export type PlaceUrbanExplorerUpdateManyWithWhereWithoutOwnerInput = {
    where: PlaceUrbanExplorerScalarWhereInput
    data: XOR<PlaceUrbanExplorerUpdateManyMutationInput, PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PlaceUrbanExplorerScalarWhereInput = {
    AND?: PlaceUrbanExplorerScalarWhereInput | PlaceUrbanExplorerScalarWhereInput[]
    OR?: PlaceUrbanExplorerScalarWhereInput[]
    NOT?: PlaceUrbanExplorerScalarWhereInput | PlaceUrbanExplorerScalarWhereInput[]
    id?: StringFilter<"PlaceUrbanExplorer"> | string
    name?: StringFilter<"PlaceUrbanExplorer"> | string
    category?: StringFilter<"PlaceUrbanExplorer"> | string
    location?: StringFilter<"PlaceUrbanExplorer"> | string
    description?: StringFilter<"PlaceUrbanExplorer"> | string
    ownerId?: StringFilter<"PlaceUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"PlaceUrbanExplorer"> | Date | string
    validated?: BoolFilter<"PlaceUrbanExplorer"> | boolean
  }

  export type ReviewUrbanExplorerUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    update: XOR<ReviewUrbanExplorerUpdateWithoutUserInput, ReviewUrbanExplorerUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewUrbanExplorerCreateWithoutUserInput, ReviewUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type ReviewUrbanExplorerUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    data: XOR<ReviewUrbanExplorerUpdateWithoutUserInput, ReviewUrbanExplorerUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUrbanExplorerUpdateManyWithWhereWithoutUserInput = {
    where: ReviewUrbanExplorerScalarWhereInput
    data: XOR<ReviewUrbanExplorerUpdateManyMutationInput, ReviewUrbanExplorerUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewUrbanExplorerScalarWhereInput = {
    AND?: ReviewUrbanExplorerScalarWhereInput | ReviewUrbanExplorerScalarWhereInput[]
    OR?: ReviewUrbanExplorerScalarWhereInput[]
    NOT?: ReviewUrbanExplorerScalarWhereInput | ReviewUrbanExplorerScalarWhereInput[]
    id?: StringFilter<"ReviewUrbanExplorer"> | string
    placeId?: StringFilter<"ReviewUrbanExplorer"> | string
    userId?: StringFilter<"ReviewUrbanExplorer"> | string
    rating?: IntFilter<"ReviewUrbanExplorer"> | number
    comment?: StringFilter<"ReviewUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"ReviewUrbanExplorer"> | Date | string
  }

  export type LikeUrbanExplorerUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeUrbanExplorerWhereUniqueInput
    update: XOR<LikeUrbanExplorerUpdateWithoutUserInput, LikeUrbanExplorerUncheckedUpdateWithoutUserInput>
    create: XOR<LikeUrbanExplorerCreateWithoutUserInput, LikeUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type LikeUrbanExplorerUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeUrbanExplorerWhereUniqueInput
    data: XOR<LikeUrbanExplorerUpdateWithoutUserInput, LikeUrbanExplorerUncheckedUpdateWithoutUserInput>
  }

  export type LikeUrbanExplorerUpdateManyWithWhereWithoutUserInput = {
    where: LikeUrbanExplorerScalarWhereInput
    data: XOR<LikeUrbanExplorerUpdateManyMutationInput, LikeUrbanExplorerUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeUrbanExplorerScalarWhereInput = {
    AND?: LikeUrbanExplorerScalarWhereInput | LikeUrbanExplorerScalarWhereInput[]
    OR?: LikeUrbanExplorerScalarWhereInput[]
    NOT?: LikeUrbanExplorerScalarWhereInput | LikeUrbanExplorerScalarWhereInput[]
    id?: StringFilter<"LikeUrbanExplorer"> | string
    placeId?: StringFilter<"LikeUrbanExplorer"> | string
    userId?: StringFilter<"LikeUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"LikeUrbanExplorer"> | Date | string
  }

  export type BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutUserInput = {
    where: BookmarkUrbanExplorerWhereUniqueInput
    update: XOR<BookmarkUrbanExplorerUpdateWithoutUserInput, BookmarkUrbanExplorerUncheckedUpdateWithoutUserInput>
    create: XOR<BookmarkUrbanExplorerCreateWithoutUserInput, BookmarkUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutUserInput = {
    where: BookmarkUrbanExplorerWhereUniqueInput
    data: XOR<BookmarkUrbanExplorerUpdateWithoutUserInput, BookmarkUrbanExplorerUncheckedUpdateWithoutUserInput>
  }

  export type BookmarkUrbanExplorerUpdateManyWithWhereWithoutUserInput = {
    where: BookmarkUrbanExplorerScalarWhereInput
    data: XOR<BookmarkUrbanExplorerUpdateManyMutationInput, BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserInput>
  }

  export type BookmarkUrbanExplorerScalarWhereInput = {
    AND?: BookmarkUrbanExplorerScalarWhereInput | BookmarkUrbanExplorerScalarWhereInput[]
    OR?: BookmarkUrbanExplorerScalarWhereInput[]
    NOT?: BookmarkUrbanExplorerScalarWhereInput | BookmarkUrbanExplorerScalarWhereInput[]
    id?: StringFilter<"BookmarkUrbanExplorer"> | string
    placeId?: StringFilter<"BookmarkUrbanExplorer"> | string
    userId?: StringFilter<"BookmarkUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"BookmarkUrbanExplorer"> | Date | string
  }

  export type ReportUrbanExplorerUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    update: XOR<ReportUrbanExplorerUpdateWithoutUserInput, ReportUrbanExplorerUncheckedUpdateWithoutUserInput>
    create: XOR<ReportUrbanExplorerCreateWithoutUserInput, ReportUrbanExplorerUncheckedCreateWithoutUserInput>
  }

  export type ReportUrbanExplorerUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    data: XOR<ReportUrbanExplorerUpdateWithoutUserInput, ReportUrbanExplorerUncheckedUpdateWithoutUserInput>
  }

  export type ReportUrbanExplorerUpdateManyWithWhereWithoutUserInput = {
    where: ReportUrbanExplorerScalarWhereInput
    data: XOR<ReportUrbanExplorerUpdateManyMutationInput, ReportUrbanExplorerUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportUrbanExplorerScalarWhereInput = {
    AND?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
    OR?: ReportUrbanExplorerScalarWhereInput[]
    NOT?: ReportUrbanExplorerScalarWhereInput | ReportUrbanExplorerScalarWhereInput[]
    id?: StringFilter<"ReportUrbanExplorer"> | string
    placeId?: StringNullableFilter<"ReportUrbanExplorer"> | string | null
    reviewId?: StringNullableFilter<"ReportUrbanExplorer"> | string | null
    userId?: StringFilter<"ReportUrbanExplorer"> | string
    reason?: StringFilter<"ReportUrbanExplorer"> | string
    createdAt?: DateTimeFilter<"ReportUrbanExplorer"> | Date | string
  }

  export type UserUrbanExplorerCreateWithoutPlaceUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ReviewUrbanExplorer?: ReviewUrbanExplorerCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUncheckedCreateWithoutPlaceUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerCreateOrConnectWithoutPlaceUrbanExplorerInput = {
    where: UserUrbanExplorerWhereUniqueInput
    create: XOR<UserUrbanExplorerCreateWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutPlaceUrbanExplorerInput>
  }

  export type ReviewUrbanExplorerCreateWithoutPlaceInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutReviewUrbanExplorerInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutReviewInput
  }

  export type ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUrbanExplorerCreateOrConnectWithoutPlaceInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    create: XOR<ReviewUrbanExplorerCreateWithoutPlaceInput, ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type ReviewUrbanExplorerCreateManyPlaceInputEnvelope = {
    data: ReviewUrbanExplorerCreateManyPlaceInput | ReviewUrbanExplorerCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkUrbanExplorerCreateWithoutPlaceInput = {
    id?: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutBookmarkUrbanExplorerInput
  }

  export type BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkUrbanExplorerCreateOrConnectWithoutPlaceInput = {
    where: BookmarkUrbanExplorerWhereUniqueInput
    create: XOR<BookmarkUrbanExplorerCreateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type BookmarkUrbanExplorerCreateManyPlaceInputEnvelope = {
    data: BookmarkUrbanExplorerCreateManyPlaceInput | BookmarkUrbanExplorerCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type LikeUrbanExplorerCreateWithoutPlaceInput = {
    id?: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutLikeUrbanExplorerInput
  }

  export type LikeUrbanExplorerUncheckedCreateWithoutPlaceInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUrbanExplorerCreateOrConnectWithoutPlaceInput = {
    where: LikeUrbanExplorerWhereUniqueInput
    create: XOR<LikeUrbanExplorerCreateWithoutPlaceInput, LikeUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type LikeUrbanExplorerCreateManyPlaceInputEnvelope = {
    data: LikeUrbanExplorerCreateManyPlaceInput | LikeUrbanExplorerCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type ReportUrbanExplorerCreateWithoutPlaceInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutReportUrbanExplorerInput
    review?: ReviewUrbanExplorerCreateNestedOneWithoutReportsInput
  }

  export type ReportUrbanExplorerUncheckedCreateWithoutPlaceInput = {
    id?: string
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerCreateOrConnectWithoutPlaceInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    create: XOR<ReportUrbanExplorerCreateWithoutPlaceInput, ReportUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type ReportUrbanExplorerCreateManyPlaceInputEnvelope = {
    data: ReportUrbanExplorerCreateManyPlaceInput | ReportUrbanExplorerCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type UserUrbanExplorerUpsertWithoutPlaceUrbanExplorerInput = {
    update: XOR<UserUrbanExplorerUpdateWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutPlaceUrbanExplorerInput>
    create: XOR<UserUrbanExplorerCreateWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutPlaceUrbanExplorerInput>
    where?: UserUrbanExplorerWhereInput
  }

  export type UserUrbanExplorerUpdateToOneWithWhereWithoutPlaceUrbanExplorerInput = {
    where?: UserUrbanExplorerWhereInput
    data: XOR<UserUrbanExplorerUpdateWithoutPlaceUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutPlaceUrbanExplorerInput>
  }

  export type UserUrbanExplorerUpdateWithoutPlaceUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ReviewUrbanExplorer?: ReviewUrbanExplorerUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerUncheckedUpdateWithoutPlaceUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    update: XOR<ReviewUrbanExplorerUpdateWithoutPlaceInput, ReviewUrbanExplorerUncheckedUpdateWithoutPlaceInput>
    create: XOR<ReviewUrbanExplorerCreateWithoutPlaceInput, ReviewUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type ReviewUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    data: XOR<ReviewUrbanExplorerUpdateWithoutPlaceInput, ReviewUrbanExplorerUncheckedUpdateWithoutPlaceInput>
  }

  export type ReviewUrbanExplorerUpdateManyWithWhereWithoutPlaceInput = {
    where: ReviewUrbanExplorerScalarWhereInput
    data: XOR<ReviewUrbanExplorerUpdateManyMutationInput, ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceInput>
  }

  export type BookmarkUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput = {
    where: BookmarkUrbanExplorerWhereUniqueInput
    update: XOR<BookmarkUrbanExplorerUpdateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedUpdateWithoutPlaceInput>
    create: XOR<BookmarkUrbanExplorerCreateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type BookmarkUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput = {
    where: BookmarkUrbanExplorerWhereUniqueInput
    data: XOR<BookmarkUrbanExplorerUpdateWithoutPlaceInput, BookmarkUrbanExplorerUncheckedUpdateWithoutPlaceInput>
  }

  export type BookmarkUrbanExplorerUpdateManyWithWhereWithoutPlaceInput = {
    where: BookmarkUrbanExplorerScalarWhereInput
    data: XOR<BookmarkUrbanExplorerUpdateManyMutationInput, BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceInput>
  }

  export type LikeUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput = {
    where: LikeUrbanExplorerWhereUniqueInput
    update: XOR<LikeUrbanExplorerUpdateWithoutPlaceInput, LikeUrbanExplorerUncheckedUpdateWithoutPlaceInput>
    create: XOR<LikeUrbanExplorerCreateWithoutPlaceInput, LikeUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type LikeUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput = {
    where: LikeUrbanExplorerWhereUniqueInput
    data: XOR<LikeUrbanExplorerUpdateWithoutPlaceInput, LikeUrbanExplorerUncheckedUpdateWithoutPlaceInput>
  }

  export type LikeUrbanExplorerUpdateManyWithWhereWithoutPlaceInput = {
    where: LikeUrbanExplorerScalarWhereInput
    data: XOR<LikeUrbanExplorerUpdateManyMutationInput, LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceInput>
  }

  export type ReportUrbanExplorerUpsertWithWhereUniqueWithoutPlaceInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    update: XOR<ReportUrbanExplorerUpdateWithoutPlaceInput, ReportUrbanExplorerUncheckedUpdateWithoutPlaceInput>
    create: XOR<ReportUrbanExplorerCreateWithoutPlaceInput, ReportUrbanExplorerUncheckedCreateWithoutPlaceInput>
  }

  export type ReportUrbanExplorerUpdateWithWhereUniqueWithoutPlaceInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    data: XOR<ReportUrbanExplorerUpdateWithoutPlaceInput, ReportUrbanExplorerUncheckedUpdateWithoutPlaceInput>
  }

  export type ReportUrbanExplorerUpdateManyWithWhereWithoutPlaceInput = {
    where: ReportUrbanExplorerScalarWhereInput
    data: XOR<ReportUrbanExplorerUpdateManyMutationInput, ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceInput>
  }

  export type UserUrbanExplorerCreateWithoutReviewUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerCreateNestedManyWithoutOwnerInput
    LikeUrbanExplorer?: LikeUrbanExplorerCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUncheckedCreateWithoutReviewUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedCreateNestedManyWithoutOwnerInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerCreateOrConnectWithoutReviewUrbanExplorerInput = {
    where: UserUrbanExplorerWhereUniqueInput
    create: XOR<UserUrbanExplorerCreateWithoutReviewUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReviewUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerCreateWithoutReviewsInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    owner: UserUrbanExplorerCreateNestedOneWithoutPlaceUrbanExplorerInput
    bookmarks?: BookmarkUrbanExplorerCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt?: Date | string
    validated?: boolean
    bookmarks?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerCreateOrConnectWithoutReviewsInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    create: XOR<PlaceUrbanExplorerCreateWithoutReviewsInput, PlaceUrbanExplorerUncheckedCreateWithoutReviewsInput>
  }

  export type ReportUrbanExplorerCreateWithoutReviewInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutReportUrbanExplorerInput
    place?: PlaceUrbanExplorerCreateNestedOneWithoutReportsInput
  }

  export type ReportUrbanExplorerUncheckedCreateWithoutReviewInput = {
    id?: string
    placeId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerCreateOrConnectWithoutReviewInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    create: XOR<ReportUrbanExplorerCreateWithoutReviewInput, ReportUrbanExplorerUncheckedCreateWithoutReviewInput>
  }

  export type ReportUrbanExplorerCreateManyReviewInputEnvelope = {
    data: ReportUrbanExplorerCreateManyReviewInput | ReportUrbanExplorerCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type UserUrbanExplorerUpsertWithoutReviewUrbanExplorerInput = {
    update: XOR<UserUrbanExplorerUpdateWithoutReviewUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutReviewUrbanExplorerInput>
    create: XOR<UserUrbanExplorerCreateWithoutReviewUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReviewUrbanExplorerInput>
    where?: UserUrbanExplorerWhereInput
  }

  export type UserUrbanExplorerUpdateToOneWithWhereWithoutReviewUrbanExplorerInput = {
    where?: UserUrbanExplorerWhereInput
    data: XOR<UserUrbanExplorerUpdateWithoutReviewUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutReviewUrbanExplorerInput>
  }

  export type UserUrbanExplorerUpdateWithoutReviewUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUpdateManyWithoutOwnerNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerUncheckedUpdateWithoutReviewUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaceUrbanExplorerUpsertWithoutReviewsInput = {
    update: XOR<PlaceUrbanExplorerUpdateWithoutReviewsInput, PlaceUrbanExplorerUncheckedUpdateWithoutReviewsInput>
    create: XOR<PlaceUrbanExplorerCreateWithoutReviewsInput, PlaceUrbanExplorerUncheckedCreateWithoutReviewsInput>
    where?: PlaceUrbanExplorerWhereInput
  }

  export type PlaceUrbanExplorerUpdateToOneWithWhereWithoutReviewsInput = {
    where?: PlaceUrbanExplorerWhereInput
    data: XOR<PlaceUrbanExplorerUpdateWithoutReviewsInput, PlaceUrbanExplorerUncheckedUpdateWithoutReviewsInput>
  }

  export type PlaceUrbanExplorerUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUrbanExplorerUpdateOneRequiredWithoutPlaceUrbanExplorerNestedInput
    bookmarks?: BookmarkUrbanExplorerUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    bookmarks?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type ReportUrbanExplorerUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    update: XOR<ReportUrbanExplorerUpdateWithoutReviewInput, ReportUrbanExplorerUncheckedUpdateWithoutReviewInput>
    create: XOR<ReportUrbanExplorerCreateWithoutReviewInput, ReportUrbanExplorerUncheckedCreateWithoutReviewInput>
  }

  export type ReportUrbanExplorerUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReportUrbanExplorerWhereUniqueInput
    data: XOR<ReportUrbanExplorerUpdateWithoutReviewInput, ReportUrbanExplorerUncheckedUpdateWithoutReviewInput>
  }

  export type ReportUrbanExplorerUpdateManyWithWhereWithoutReviewInput = {
    where: ReportUrbanExplorerScalarWhereInput
    data: XOR<ReportUrbanExplorerUpdateManyMutationInput, ReportUrbanExplorerUncheckedUpdateManyWithoutReviewInput>
  }

  export type UserUrbanExplorerCreateWithoutLikeUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUncheckedCreateWithoutLikeUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerCreateOrConnectWithoutLikeUrbanExplorerInput = {
    where: UserUrbanExplorerWhereUniqueInput
    create: XOR<UserUrbanExplorerCreateWithoutLikeUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutLikeUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerCreateWithoutLikesInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    owner: UserUrbanExplorerCreateNestedOneWithoutPlaceUrbanExplorerInput
    reviews?: ReviewUrbanExplorerCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUncheckedCreateWithoutLikesInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerCreateOrConnectWithoutLikesInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    create: XOR<PlaceUrbanExplorerCreateWithoutLikesInput, PlaceUrbanExplorerUncheckedCreateWithoutLikesInput>
  }

  export type UserUrbanExplorerUpsertWithoutLikeUrbanExplorerInput = {
    update: XOR<UserUrbanExplorerUpdateWithoutLikeUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutLikeUrbanExplorerInput>
    create: XOR<UserUrbanExplorerCreateWithoutLikeUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutLikeUrbanExplorerInput>
    where?: UserUrbanExplorerWhereInput
  }

  export type UserUrbanExplorerUpdateToOneWithWhereWithoutLikeUrbanExplorerInput = {
    where?: UserUrbanExplorerWhereInput
    data: XOR<UserUrbanExplorerUpdateWithoutLikeUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutLikeUrbanExplorerInput>
  }

  export type UserUrbanExplorerUpdateWithoutLikeUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerUncheckedUpdateWithoutLikeUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaceUrbanExplorerUpsertWithoutLikesInput = {
    update: XOR<PlaceUrbanExplorerUpdateWithoutLikesInput, PlaceUrbanExplorerUncheckedUpdateWithoutLikesInput>
    create: XOR<PlaceUrbanExplorerCreateWithoutLikesInput, PlaceUrbanExplorerUncheckedCreateWithoutLikesInput>
    where?: PlaceUrbanExplorerWhereInput
  }

  export type PlaceUrbanExplorerUpdateToOneWithWhereWithoutLikesInput = {
    where?: PlaceUrbanExplorerWhereInput
    data: XOR<PlaceUrbanExplorerUpdateWithoutLikesInput, PlaceUrbanExplorerUncheckedUpdateWithoutLikesInput>
  }

  export type PlaceUrbanExplorerUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUrbanExplorerUpdateOneRequiredWithoutPlaceUrbanExplorerNestedInput
    reviews?: ReviewUrbanExplorerUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type UserUrbanExplorerCreateWithoutBookmarkUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUncheckedCreateWithoutBookmarkUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerCreateOrConnectWithoutBookmarkUrbanExplorerInput = {
    where: UserUrbanExplorerWhereUniqueInput
    create: XOR<UserUrbanExplorerCreateWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutBookmarkUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerCreateWithoutBookmarksInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    owner: UserUrbanExplorerCreateNestedOneWithoutPlaceUrbanExplorerInput
    reviews?: ReviewUrbanExplorerCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUncheckedCreateWithoutBookmarksInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    reports?: ReportUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerCreateOrConnectWithoutBookmarksInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    create: XOR<PlaceUrbanExplorerCreateWithoutBookmarksInput, PlaceUrbanExplorerUncheckedCreateWithoutBookmarksInput>
  }

  export type UserUrbanExplorerUpsertWithoutBookmarkUrbanExplorerInput = {
    update: XOR<UserUrbanExplorerUpdateWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutBookmarkUrbanExplorerInput>
    create: XOR<UserUrbanExplorerCreateWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutBookmarkUrbanExplorerInput>
    where?: UserUrbanExplorerWhereInput
  }

  export type UserUrbanExplorerUpdateToOneWithWhereWithoutBookmarkUrbanExplorerInput = {
    where?: UserUrbanExplorerWhereInput
    data: XOR<UserUrbanExplorerUpdateWithoutBookmarkUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutBookmarkUrbanExplorerInput>
  }

  export type UserUrbanExplorerUpdateWithoutBookmarkUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerUncheckedUpdateWithoutBookmarkUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    ReportUrbanExplorer?: ReportUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaceUrbanExplorerUpsertWithoutBookmarksInput = {
    update: XOR<PlaceUrbanExplorerUpdateWithoutBookmarksInput, PlaceUrbanExplorerUncheckedUpdateWithoutBookmarksInput>
    create: XOR<PlaceUrbanExplorerCreateWithoutBookmarksInput, PlaceUrbanExplorerUncheckedCreateWithoutBookmarksInput>
    where?: PlaceUrbanExplorerWhereInput
  }

  export type PlaceUrbanExplorerUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: PlaceUrbanExplorerWhereInput
    data: XOR<PlaceUrbanExplorerUpdateWithoutBookmarksInput, PlaceUrbanExplorerUncheckedUpdateWithoutBookmarksInput>
  }

  export type PlaceUrbanExplorerUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUrbanExplorerUpdateOneRequiredWithoutPlaceUrbanExplorerNestedInput
    reviews?: ReviewUrbanExplorerUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type UserUrbanExplorerCreateWithoutReportUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerUncheckedCreateWithoutReportUrbanExplorerInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedCreateNestedManyWithoutOwnerInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUrbanExplorerCreateOrConnectWithoutReportUrbanExplorerInput = {
    where: UserUrbanExplorerWhereUniqueInput
    create: XOR<UserUrbanExplorerCreateWithoutReportUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReportUrbanExplorerInput>
  }

  export type PlaceUrbanExplorerCreateWithoutReportsInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
    owner: UserUrbanExplorerCreateNestedOneWithoutPlaceUrbanExplorerInput
    reviews?: ReviewUrbanExplorerCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    ownerId: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    bookmarks?: BookmarkUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
    likes?: LikeUrbanExplorerUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUrbanExplorerCreateOrConnectWithoutReportsInput = {
    where: PlaceUrbanExplorerWhereUniqueInput
    create: XOR<PlaceUrbanExplorerCreateWithoutReportsInput, PlaceUrbanExplorerUncheckedCreateWithoutReportsInput>
  }

  export type ReviewUrbanExplorerCreateWithoutReportsInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserUrbanExplorerCreateNestedOneWithoutReviewUrbanExplorerInput
    place: PlaceUrbanExplorerCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUrbanExplorerUncheckedCreateWithoutReportsInput = {
    id?: string
    placeId: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type ReviewUrbanExplorerCreateOrConnectWithoutReportsInput = {
    where: ReviewUrbanExplorerWhereUniqueInput
    create: XOR<ReviewUrbanExplorerCreateWithoutReportsInput, ReviewUrbanExplorerUncheckedCreateWithoutReportsInput>
  }

  export type UserUrbanExplorerUpsertWithoutReportUrbanExplorerInput = {
    update: XOR<UserUrbanExplorerUpdateWithoutReportUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutReportUrbanExplorerInput>
    create: XOR<UserUrbanExplorerCreateWithoutReportUrbanExplorerInput, UserUrbanExplorerUncheckedCreateWithoutReportUrbanExplorerInput>
    where?: UserUrbanExplorerWhereInput
  }

  export type UserUrbanExplorerUpdateToOneWithWhereWithoutReportUrbanExplorerInput = {
    where?: UserUrbanExplorerWhereInput
    data: XOR<UserUrbanExplorerUpdateWithoutReportUrbanExplorerInput, UserUrbanExplorerUncheckedUpdateWithoutReportUrbanExplorerInput>
  }

  export type UserUrbanExplorerUpdateWithoutReportUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUpdateManyWithoutUserNestedInput
  }

  export type UserUrbanExplorerUncheckedUpdateWithoutReportUrbanExplorerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PlaceUrbanExplorer?: PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerNestedInput
    ReviewUrbanExplorer?: ReviewUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    LikeUrbanExplorer?: LikeUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
    BookmarkUrbanExplorer?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaceUrbanExplorerUpsertWithoutReportsInput = {
    update: XOR<PlaceUrbanExplorerUpdateWithoutReportsInput, PlaceUrbanExplorerUncheckedUpdateWithoutReportsInput>
    create: XOR<PlaceUrbanExplorerCreateWithoutReportsInput, PlaceUrbanExplorerUncheckedCreateWithoutReportsInput>
    where?: PlaceUrbanExplorerWhereInput
  }

  export type PlaceUrbanExplorerUpdateToOneWithWhereWithoutReportsInput = {
    where?: PlaceUrbanExplorerWhereInput
    data: XOR<PlaceUrbanExplorerUpdateWithoutReportsInput, PlaceUrbanExplorerUncheckedUpdateWithoutReportsInput>
  }

  export type PlaceUrbanExplorerUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUrbanExplorerUpdateOneRequiredWithoutPlaceUrbanExplorerNestedInput
    reviews?: ReviewUrbanExplorerUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type ReviewUrbanExplorerUpsertWithoutReportsInput = {
    update: XOR<ReviewUrbanExplorerUpdateWithoutReportsInput, ReviewUrbanExplorerUncheckedUpdateWithoutReportsInput>
    create: XOR<ReviewUrbanExplorerCreateWithoutReportsInput, ReviewUrbanExplorerUncheckedCreateWithoutReportsInput>
    where?: ReviewUrbanExplorerWhereInput
  }

  export type ReviewUrbanExplorerUpdateToOneWithWhereWithoutReportsInput = {
    where?: ReviewUrbanExplorerWhereInput
    data: XOR<ReviewUrbanExplorerUpdateWithoutReportsInput, ReviewUrbanExplorerUncheckedUpdateWithoutReportsInput>
  }

  export type ReviewUrbanExplorerUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutReviewUrbanExplorerNestedInput
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUrbanExplorerUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieFoodCreateWithoutUserInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
    locations?: FoodieLocationCreateNestedManyWithoutFoodInput
    reviews?: FoodieReviewCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
    locations?: FoodieLocationUncheckedCreateNestedManyWithoutFoodInput
    reviews?: FoodieReviewUncheckedCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodCreateOrConnectWithoutUserInput = {
    where: FoodieFoodWhereUniqueInput
    create: XOR<FoodieFoodCreateWithoutUserInput, FoodieFoodUncheckedCreateWithoutUserInput>
  }

  export type FoodieFoodCreateManyUserInputEnvelope = {
    data: FoodieFoodCreateManyUserInput | FoodieFoodCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FoodieLocationCreateWithoutUserInput = {
    id?: string
    locationName: string
    address: string
    createdAt?: Date | string
    food: FoodieFoodCreateNestedOneWithoutLocationsInput
  }

  export type FoodieLocationUncheckedCreateWithoutUserInput = {
    id?: string
    foodId: string
    locationName: string
    address: string
    createdAt?: Date | string
  }

  export type FoodieLocationCreateOrConnectWithoutUserInput = {
    where: FoodieLocationWhereUniqueInput
    create: XOR<FoodieLocationCreateWithoutUserInput, FoodieLocationUncheckedCreateWithoutUserInput>
  }

  export type FoodieLocationCreateManyUserInputEnvelope = {
    data: FoodieLocationCreateManyUserInput | FoodieLocationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FoodieReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
    food: FoodieFoodCreateNestedOneWithoutReviewsInput
  }

  export type FoodieReviewUncheckedCreateWithoutUserInput = {
    id?: string
    foodId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieReviewCreateOrConnectWithoutUserInput = {
    where: FoodieReviewWhereUniqueInput
    create: XOR<FoodieReviewCreateWithoutUserInput, FoodieReviewUncheckedCreateWithoutUserInput>
  }

  export type FoodieReviewCreateManyUserInputEnvelope = {
    data: FoodieReviewCreateManyUserInput | FoodieReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FoodieLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    food: FoodieFoodCreateNestedOneWithoutLikesInput
  }

  export type FoodieLikeUncheckedCreateWithoutUserInput = {
    id?: string
    foodId: string
    createdAt?: Date | string
  }

  export type FoodieLikeCreateOrConnectWithoutUserInput = {
    where: FoodieLikeWhereUniqueInput
    create: XOR<FoodieLikeCreateWithoutUserInput, FoodieLikeUncheckedCreateWithoutUserInput>
  }

  export type FoodieLikeCreateManyUserInputEnvelope = {
    data: FoodieLikeCreateManyUserInput | FoodieLikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FoodieFoodUpsertWithWhereUniqueWithoutUserInput = {
    where: FoodieFoodWhereUniqueInput
    update: XOR<FoodieFoodUpdateWithoutUserInput, FoodieFoodUncheckedUpdateWithoutUserInput>
    create: XOR<FoodieFoodCreateWithoutUserInput, FoodieFoodUncheckedCreateWithoutUserInput>
  }

  export type FoodieFoodUpdateWithWhereUniqueWithoutUserInput = {
    where: FoodieFoodWhereUniqueInput
    data: XOR<FoodieFoodUpdateWithoutUserInput, FoodieFoodUncheckedUpdateWithoutUserInput>
  }

  export type FoodieFoodUpdateManyWithWhereWithoutUserInput = {
    where: FoodieFoodScalarWhereInput
    data: XOR<FoodieFoodUpdateManyMutationInput, FoodieFoodUncheckedUpdateManyWithoutUserInput>
  }

  export type FoodieFoodScalarWhereInput = {
    AND?: FoodieFoodScalarWhereInput | FoodieFoodScalarWhereInput[]
    OR?: FoodieFoodScalarWhereInput[]
    NOT?: FoodieFoodScalarWhereInput | FoodieFoodScalarWhereInput[]
    id?: StringFilter<"FoodieFood"> | string
    name?: StringFilter<"FoodieFood"> | string
    cuisine?: StringFilter<"FoodieFood"> | string
    origin?: StringFilter<"FoodieFood"> | string
    description?: StringFilter<"FoodieFood"> | string
    submittedBy?: StringFilter<"FoodieFood"> | string
    validated?: BoolFilter<"FoodieFood"> | boolean
    createdAt?: DateTimeFilter<"FoodieFood"> | Date | string
  }

  export type FoodieLocationUpsertWithWhereUniqueWithoutUserInput = {
    where: FoodieLocationWhereUniqueInput
    update: XOR<FoodieLocationUpdateWithoutUserInput, FoodieLocationUncheckedUpdateWithoutUserInput>
    create: XOR<FoodieLocationCreateWithoutUserInput, FoodieLocationUncheckedCreateWithoutUserInput>
  }

  export type FoodieLocationUpdateWithWhereUniqueWithoutUserInput = {
    where: FoodieLocationWhereUniqueInput
    data: XOR<FoodieLocationUpdateWithoutUserInput, FoodieLocationUncheckedUpdateWithoutUserInput>
  }

  export type FoodieLocationUpdateManyWithWhereWithoutUserInput = {
    where: FoodieLocationScalarWhereInput
    data: XOR<FoodieLocationUpdateManyMutationInput, FoodieLocationUncheckedUpdateManyWithoutUserInput>
  }

  export type FoodieLocationScalarWhereInput = {
    AND?: FoodieLocationScalarWhereInput | FoodieLocationScalarWhereInput[]
    OR?: FoodieLocationScalarWhereInput[]
    NOT?: FoodieLocationScalarWhereInput | FoodieLocationScalarWhereInput[]
    id?: StringFilter<"FoodieLocation"> | string
    foodId?: StringFilter<"FoodieLocation"> | string
    locationName?: StringFilter<"FoodieLocation"> | string
    address?: StringFilter<"FoodieLocation"> | string
    submittedBy?: StringFilter<"FoodieLocation"> | string
    createdAt?: DateTimeFilter<"FoodieLocation"> | Date | string
  }

  export type FoodieReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: FoodieReviewWhereUniqueInput
    update: XOR<FoodieReviewUpdateWithoutUserInput, FoodieReviewUncheckedUpdateWithoutUserInput>
    create: XOR<FoodieReviewCreateWithoutUserInput, FoodieReviewUncheckedCreateWithoutUserInput>
  }

  export type FoodieReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: FoodieReviewWhereUniqueInput
    data: XOR<FoodieReviewUpdateWithoutUserInput, FoodieReviewUncheckedUpdateWithoutUserInput>
  }

  export type FoodieReviewUpdateManyWithWhereWithoutUserInput = {
    where: FoodieReviewScalarWhereInput
    data: XOR<FoodieReviewUpdateManyMutationInput, FoodieReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type FoodieReviewScalarWhereInput = {
    AND?: FoodieReviewScalarWhereInput | FoodieReviewScalarWhereInput[]
    OR?: FoodieReviewScalarWhereInput[]
    NOT?: FoodieReviewScalarWhereInput | FoodieReviewScalarWhereInput[]
    id?: StringFilter<"FoodieReview"> | string
    foodId?: StringFilter<"FoodieReview"> | string
    userId?: StringFilter<"FoodieReview"> | string
    rating?: IntFilter<"FoodieReview"> | number
    comment?: StringFilter<"FoodieReview"> | string
    validated?: BoolFilter<"FoodieReview"> | boolean
    createdAt?: DateTimeFilter<"FoodieReview"> | Date | string
  }

  export type FoodieLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: FoodieLikeWhereUniqueInput
    update: XOR<FoodieLikeUpdateWithoutUserInput, FoodieLikeUncheckedUpdateWithoutUserInput>
    create: XOR<FoodieLikeCreateWithoutUserInput, FoodieLikeUncheckedCreateWithoutUserInput>
  }

  export type FoodieLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: FoodieLikeWhereUniqueInput
    data: XOR<FoodieLikeUpdateWithoutUserInput, FoodieLikeUncheckedUpdateWithoutUserInput>
  }

  export type FoodieLikeUpdateManyWithWhereWithoutUserInput = {
    where: FoodieLikeScalarWhereInput
    data: XOR<FoodieLikeUpdateManyMutationInput, FoodieLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type FoodieLikeScalarWhereInput = {
    AND?: FoodieLikeScalarWhereInput | FoodieLikeScalarWhereInput[]
    OR?: FoodieLikeScalarWhereInput[]
    NOT?: FoodieLikeScalarWhereInput | FoodieLikeScalarWhereInput[]
    id?: StringFilter<"FoodieLike"> | string
    foodId?: StringFilter<"FoodieLike"> | string
    userId?: StringFilter<"FoodieLike"> | string
    createdAt?: DateTimeFilter<"FoodieLike"> | Date | string
  }

  export type UserFoodieCreateWithoutFoodieFoodInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieLocation?: FoodieLocationCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeCreateNestedManyWithoutUserInput
  }

  export type UserFoodieUncheckedCreateWithoutFoodieFoodInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieLocation?: FoodieLocationUncheckedCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewUncheckedCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFoodieCreateOrConnectWithoutFoodieFoodInput = {
    where: UserFoodieWhereUniqueInput
    create: XOR<UserFoodieCreateWithoutFoodieFoodInput, UserFoodieUncheckedCreateWithoutFoodieFoodInput>
  }

  export type FoodieLocationCreateWithoutFoodInput = {
    id?: string
    locationName: string
    address: string
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieLocationInput
  }

  export type FoodieLocationUncheckedCreateWithoutFoodInput = {
    id?: string
    locationName: string
    address: string
    submittedBy: string
    createdAt?: Date | string
  }

  export type FoodieLocationCreateOrConnectWithoutFoodInput = {
    where: FoodieLocationWhereUniqueInput
    create: XOR<FoodieLocationCreateWithoutFoodInput, FoodieLocationUncheckedCreateWithoutFoodInput>
  }

  export type FoodieLocationCreateManyFoodInputEnvelope = {
    data: FoodieLocationCreateManyFoodInput | FoodieLocationCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodieReviewCreateWithoutFoodInput = {
    id?: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieReviewInput
  }

  export type FoodieReviewUncheckedCreateWithoutFoodInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieReviewCreateOrConnectWithoutFoodInput = {
    where: FoodieReviewWhereUniqueInput
    create: XOR<FoodieReviewCreateWithoutFoodInput, FoodieReviewUncheckedCreateWithoutFoodInput>
  }

  export type FoodieReviewCreateManyFoodInputEnvelope = {
    data: FoodieReviewCreateManyFoodInput | FoodieReviewCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type FoodieLikeCreateWithoutFoodInput = {
    id?: string
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieLikeInput
  }

  export type FoodieLikeUncheckedCreateWithoutFoodInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FoodieLikeCreateOrConnectWithoutFoodInput = {
    where: FoodieLikeWhereUniqueInput
    create: XOR<FoodieLikeCreateWithoutFoodInput, FoodieLikeUncheckedCreateWithoutFoodInput>
  }

  export type FoodieLikeCreateManyFoodInputEnvelope = {
    data: FoodieLikeCreateManyFoodInput | FoodieLikeCreateManyFoodInput[]
    skipDuplicates?: boolean
  }

  export type UserFoodieUpsertWithoutFoodieFoodInput = {
    update: XOR<UserFoodieUpdateWithoutFoodieFoodInput, UserFoodieUncheckedUpdateWithoutFoodieFoodInput>
    create: XOR<UserFoodieCreateWithoutFoodieFoodInput, UserFoodieUncheckedCreateWithoutFoodieFoodInput>
    where?: UserFoodieWhereInput
  }

  export type UserFoodieUpdateToOneWithWhereWithoutFoodieFoodInput = {
    where?: UserFoodieWhereInput
    data: XOR<UserFoodieUpdateWithoutFoodieFoodInput, UserFoodieUncheckedUpdateWithoutFoodieFoodInput>
  }

  export type UserFoodieUpdateWithoutFoodieFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieLocation?: FoodieLocationUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUpdateManyWithoutUserNestedInput
  }

  export type UserFoodieUncheckedUpdateWithoutFoodieFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieLocation?: FoodieLocationUncheckedUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUncheckedUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoodieLocationUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodieLocationWhereUniqueInput
    update: XOR<FoodieLocationUpdateWithoutFoodInput, FoodieLocationUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodieLocationCreateWithoutFoodInput, FoodieLocationUncheckedCreateWithoutFoodInput>
  }

  export type FoodieLocationUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodieLocationWhereUniqueInput
    data: XOR<FoodieLocationUpdateWithoutFoodInput, FoodieLocationUncheckedUpdateWithoutFoodInput>
  }

  export type FoodieLocationUpdateManyWithWhereWithoutFoodInput = {
    where: FoodieLocationScalarWhereInput
    data: XOR<FoodieLocationUpdateManyMutationInput, FoodieLocationUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodieReviewUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodieReviewWhereUniqueInput
    update: XOR<FoodieReviewUpdateWithoutFoodInput, FoodieReviewUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodieReviewCreateWithoutFoodInput, FoodieReviewUncheckedCreateWithoutFoodInput>
  }

  export type FoodieReviewUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodieReviewWhereUniqueInput
    data: XOR<FoodieReviewUpdateWithoutFoodInput, FoodieReviewUncheckedUpdateWithoutFoodInput>
  }

  export type FoodieReviewUpdateManyWithWhereWithoutFoodInput = {
    where: FoodieReviewScalarWhereInput
    data: XOR<FoodieReviewUpdateManyMutationInput, FoodieReviewUncheckedUpdateManyWithoutFoodInput>
  }

  export type FoodieLikeUpsertWithWhereUniqueWithoutFoodInput = {
    where: FoodieLikeWhereUniqueInput
    update: XOR<FoodieLikeUpdateWithoutFoodInput, FoodieLikeUncheckedUpdateWithoutFoodInput>
    create: XOR<FoodieLikeCreateWithoutFoodInput, FoodieLikeUncheckedCreateWithoutFoodInput>
  }

  export type FoodieLikeUpdateWithWhereUniqueWithoutFoodInput = {
    where: FoodieLikeWhereUniqueInput
    data: XOR<FoodieLikeUpdateWithoutFoodInput, FoodieLikeUncheckedUpdateWithoutFoodInput>
  }

  export type FoodieLikeUpdateManyWithWhereWithoutFoodInput = {
    where: FoodieLikeScalarWhereInput
    data: XOR<FoodieLikeUpdateManyMutationInput, FoodieLikeUncheckedUpdateManyWithoutFoodInput>
  }

  export type UserFoodieCreateWithoutFoodieLocationInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeCreateNestedManyWithoutUserInput
  }

  export type UserFoodieUncheckedCreateWithoutFoodieLocationInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodUncheckedCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewUncheckedCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFoodieCreateOrConnectWithoutFoodieLocationInput = {
    where: UserFoodieWhereUniqueInput
    create: XOR<UserFoodieCreateWithoutFoodieLocationInput, UserFoodieUncheckedCreateWithoutFoodieLocationInput>
  }

  export type FoodieFoodCreateWithoutLocationsInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieFoodInput
    reviews?: FoodieReviewCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    submittedBy: string
    validated?: boolean
    createdAt?: Date | string
    reviews?: FoodieReviewUncheckedCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodCreateOrConnectWithoutLocationsInput = {
    where: FoodieFoodWhereUniqueInput
    create: XOR<FoodieFoodCreateWithoutLocationsInput, FoodieFoodUncheckedCreateWithoutLocationsInput>
  }

  export type UserFoodieUpsertWithoutFoodieLocationInput = {
    update: XOR<UserFoodieUpdateWithoutFoodieLocationInput, UserFoodieUncheckedUpdateWithoutFoodieLocationInput>
    create: XOR<UserFoodieCreateWithoutFoodieLocationInput, UserFoodieUncheckedCreateWithoutFoodieLocationInput>
    where?: UserFoodieWhereInput
  }

  export type UserFoodieUpdateToOneWithWhereWithoutFoodieLocationInput = {
    where?: UserFoodieWhereInput
    data: XOR<UserFoodieUpdateWithoutFoodieLocationInput, UserFoodieUncheckedUpdateWithoutFoodieLocationInput>
  }

  export type UserFoodieUpdateWithoutFoodieLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUpdateManyWithoutUserNestedInput
  }

  export type UserFoodieUncheckedUpdateWithoutFoodieLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUncheckedUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUncheckedUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoodieFoodUpsertWithoutLocationsInput = {
    update: XOR<FoodieFoodUpdateWithoutLocationsInput, FoodieFoodUncheckedUpdateWithoutLocationsInput>
    create: XOR<FoodieFoodCreateWithoutLocationsInput, FoodieFoodUncheckedCreateWithoutLocationsInput>
    where?: FoodieFoodWhereInput
  }

  export type FoodieFoodUpdateToOneWithWhereWithoutLocationsInput = {
    where?: FoodieFoodWhereInput
    data: XOR<FoodieFoodUpdateWithoutLocationsInput, FoodieFoodUncheckedUpdateWithoutLocationsInput>
  }

  export type FoodieFoodUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieFoodNestedInput
    reviews?: FoodieReviewUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: FoodieReviewUncheckedUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type UserFoodieCreateWithoutFoodieReviewInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodCreateNestedManyWithoutUserInput
    FoodieLocation?: FoodieLocationCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeCreateNestedManyWithoutUserInput
  }

  export type UserFoodieUncheckedCreateWithoutFoodieReviewInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodUncheckedCreateNestedManyWithoutUserInput
    FoodieLocation?: FoodieLocationUncheckedCreateNestedManyWithoutUserInput
    FoodieLike?: FoodieLikeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFoodieCreateOrConnectWithoutFoodieReviewInput = {
    where: UserFoodieWhereUniqueInput
    create: XOR<UserFoodieCreateWithoutFoodieReviewInput, UserFoodieUncheckedCreateWithoutFoodieReviewInput>
  }

  export type FoodieFoodCreateWithoutReviewsInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieFoodInput
    locations?: FoodieLocationCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    submittedBy: string
    validated?: boolean
    createdAt?: Date | string
    locations?: FoodieLocationUncheckedCreateNestedManyWithoutFoodInput
    likes?: FoodieLikeUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodCreateOrConnectWithoutReviewsInput = {
    where: FoodieFoodWhereUniqueInput
    create: XOR<FoodieFoodCreateWithoutReviewsInput, FoodieFoodUncheckedCreateWithoutReviewsInput>
  }

  export type UserFoodieUpsertWithoutFoodieReviewInput = {
    update: XOR<UserFoodieUpdateWithoutFoodieReviewInput, UserFoodieUncheckedUpdateWithoutFoodieReviewInput>
    create: XOR<UserFoodieCreateWithoutFoodieReviewInput, UserFoodieUncheckedCreateWithoutFoodieReviewInput>
    where?: UserFoodieWhereInput
  }

  export type UserFoodieUpdateToOneWithWhereWithoutFoodieReviewInput = {
    where?: UserFoodieWhereInput
    data: XOR<UserFoodieUpdateWithoutFoodieReviewInput, UserFoodieUncheckedUpdateWithoutFoodieReviewInput>
  }

  export type UserFoodieUpdateWithoutFoodieReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUpdateManyWithoutUserNestedInput
    FoodieLocation?: FoodieLocationUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUpdateManyWithoutUserNestedInput
  }

  export type UserFoodieUncheckedUpdateWithoutFoodieReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUncheckedUpdateManyWithoutUserNestedInput
    FoodieLocation?: FoodieLocationUncheckedUpdateManyWithoutUserNestedInput
    FoodieLike?: FoodieLikeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoodieFoodUpsertWithoutReviewsInput = {
    update: XOR<FoodieFoodUpdateWithoutReviewsInput, FoodieFoodUncheckedUpdateWithoutReviewsInput>
    create: XOR<FoodieFoodCreateWithoutReviewsInput, FoodieFoodUncheckedCreateWithoutReviewsInput>
    where?: FoodieFoodWhereInput
  }

  export type FoodieFoodUpdateToOneWithWhereWithoutReviewsInput = {
    where?: FoodieFoodWhereInput
    data: XOR<FoodieFoodUpdateWithoutReviewsInput, FoodieFoodUncheckedUpdateWithoutReviewsInput>
  }

  export type FoodieFoodUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieFoodNestedInput
    locations?: FoodieLocationUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: FoodieLocationUncheckedUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type UserFoodieCreateWithoutFoodieLikeInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodCreateNestedManyWithoutUserInput
    FoodieLocation?: FoodieLocationCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewCreateNestedManyWithoutUserInput
  }

  export type UserFoodieUncheckedCreateWithoutFoodieLikeInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    FoodieFood?: FoodieFoodUncheckedCreateNestedManyWithoutUserInput
    FoodieLocation?: FoodieLocationUncheckedCreateNestedManyWithoutUserInput
    FoodieReview?: FoodieReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFoodieCreateOrConnectWithoutFoodieLikeInput = {
    where: UserFoodieWhereUniqueInput
    create: XOR<UserFoodieCreateWithoutFoodieLikeInput, UserFoodieUncheckedCreateWithoutFoodieLikeInput>
  }

  export type FoodieFoodCreateWithoutLikesInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
    user: UserFoodieCreateNestedOneWithoutFoodieFoodInput
    locations?: FoodieLocationCreateNestedManyWithoutFoodInput
    reviews?: FoodieReviewCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodUncheckedCreateWithoutLikesInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    submittedBy: string
    validated?: boolean
    createdAt?: Date | string
    locations?: FoodieLocationUncheckedCreateNestedManyWithoutFoodInput
    reviews?: FoodieReviewUncheckedCreateNestedManyWithoutFoodInput
  }

  export type FoodieFoodCreateOrConnectWithoutLikesInput = {
    where: FoodieFoodWhereUniqueInput
    create: XOR<FoodieFoodCreateWithoutLikesInput, FoodieFoodUncheckedCreateWithoutLikesInput>
  }

  export type UserFoodieUpsertWithoutFoodieLikeInput = {
    update: XOR<UserFoodieUpdateWithoutFoodieLikeInput, UserFoodieUncheckedUpdateWithoutFoodieLikeInput>
    create: XOR<UserFoodieCreateWithoutFoodieLikeInput, UserFoodieUncheckedCreateWithoutFoodieLikeInput>
    where?: UserFoodieWhereInput
  }

  export type UserFoodieUpdateToOneWithWhereWithoutFoodieLikeInput = {
    where?: UserFoodieWhereInput
    data: XOR<UserFoodieUpdateWithoutFoodieLikeInput, UserFoodieUncheckedUpdateWithoutFoodieLikeInput>
  }

  export type UserFoodieUpdateWithoutFoodieLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUpdateManyWithoutUserNestedInput
    FoodieLocation?: FoodieLocationUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUpdateManyWithoutUserNestedInput
  }

  export type UserFoodieUncheckedUpdateWithoutFoodieLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FoodieFood?: FoodieFoodUncheckedUpdateManyWithoutUserNestedInput
    FoodieLocation?: FoodieLocationUncheckedUpdateManyWithoutUserNestedInput
    FoodieReview?: FoodieReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoodieFoodUpsertWithoutLikesInput = {
    update: XOR<FoodieFoodUpdateWithoutLikesInput, FoodieFoodUncheckedUpdateWithoutLikesInput>
    create: XOR<FoodieFoodCreateWithoutLikesInput, FoodieFoodUncheckedCreateWithoutLikesInput>
    where?: FoodieFoodWhereInput
  }

  export type FoodieFoodUpdateToOneWithWhereWithoutLikesInput = {
    where?: FoodieFoodWhereInput
    data: XOR<FoodieFoodUpdateWithoutLikesInput, FoodieFoodUncheckedUpdateWithoutLikesInput>
  }

  export type FoodieFoodUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieFoodNestedInput
    locations?: FoodieLocationUpdateManyWithoutFoodNestedInput
    reviews?: FoodieReviewUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: FoodieLocationUncheckedUpdateManyWithoutFoodNestedInput
    reviews?: FoodieReviewUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type PetPetLoverCreateWithoutUserInput = {
    id?: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    vaccinations?: VaccinationPetLoverCreateNestedManyWithoutPetInput
    appointments?: AppointmentPetLoverCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverUncheckedCreateWithoutUserInput = {
    id?: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    vaccinations?: VaccinationPetLoverUncheckedCreateNestedManyWithoutPetInput
    appointments?: AppointmentPetLoverUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverCreateOrConnectWithoutUserInput = {
    where: PetPetLoverWhereUniqueInput
    create: XOR<PetPetLoverCreateWithoutUserInput, PetPetLoverUncheckedCreateWithoutUserInput>
  }

  export type PetPetLoverCreateManyUserInputEnvelope = {
    data: PetPetLoverCreateManyUserInput | PetPetLoverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentPetLoverCreateWithoutUserInput = {
    id?: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
    pet: PetPetLoverCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentPetLoverUncheckedCreateWithoutUserInput = {
    id?: string
    petId: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
  }

  export type AppointmentPetLoverCreateOrConnectWithoutUserInput = {
    where: AppointmentPetLoverWhereUniqueInput
    create: XOR<AppointmentPetLoverCreateWithoutUserInput, AppointmentPetLoverUncheckedCreateWithoutUserInput>
  }

  export type AppointmentPetLoverCreateManyUserInputEnvelope = {
    data: AppointmentPetLoverCreateManyUserInput | AppointmentPetLoverCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PetPetLoverUpsertWithWhereUniqueWithoutUserInput = {
    where: PetPetLoverWhereUniqueInput
    update: XOR<PetPetLoverUpdateWithoutUserInput, PetPetLoverUncheckedUpdateWithoutUserInput>
    create: XOR<PetPetLoverCreateWithoutUserInput, PetPetLoverUncheckedCreateWithoutUserInput>
  }

  export type PetPetLoverUpdateWithWhereUniqueWithoutUserInput = {
    where: PetPetLoverWhereUniqueInput
    data: XOR<PetPetLoverUpdateWithoutUserInput, PetPetLoverUncheckedUpdateWithoutUserInput>
  }

  export type PetPetLoverUpdateManyWithWhereWithoutUserInput = {
    where: PetPetLoverScalarWhereInput
    data: XOR<PetPetLoverUpdateManyMutationInput, PetPetLoverUncheckedUpdateManyWithoutUserInput>
  }

  export type PetPetLoverScalarWhereInput = {
    AND?: PetPetLoverScalarWhereInput | PetPetLoverScalarWhereInput[]
    OR?: PetPetLoverScalarWhereInput[]
    NOT?: PetPetLoverScalarWhereInput | PetPetLoverScalarWhereInput[]
    id?: StringFilter<"PetPetLover"> | string
    userId?: StringFilter<"PetPetLover"> | string
    petName?: StringFilter<"PetPetLover"> | string
    species?: StringFilter<"PetPetLover"> | string
    breed?: StringFilter<"PetPetLover"> | string
    age?: IntFilter<"PetPetLover"> | number
    medicalHistory?: StringNullableFilter<"PetPetLover"> | string | null
    createdAt?: DateTimeFilter<"PetPetLover"> | Date | string
  }

  export type AppointmentPetLoverUpsertWithWhereUniqueWithoutUserInput = {
    where: AppointmentPetLoverWhereUniqueInput
    update: XOR<AppointmentPetLoverUpdateWithoutUserInput, AppointmentPetLoverUncheckedUpdateWithoutUserInput>
    create: XOR<AppointmentPetLoverCreateWithoutUserInput, AppointmentPetLoverUncheckedCreateWithoutUserInput>
  }

  export type AppointmentPetLoverUpdateWithWhereUniqueWithoutUserInput = {
    where: AppointmentPetLoverWhereUniqueInput
    data: XOR<AppointmentPetLoverUpdateWithoutUserInput, AppointmentPetLoverUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentPetLoverUpdateManyWithWhereWithoutUserInput = {
    where: AppointmentPetLoverScalarWhereInput
    data: XOR<AppointmentPetLoverUpdateManyMutationInput, AppointmentPetLoverUncheckedUpdateManyWithoutUserInput>
  }

  export type AppointmentPetLoverScalarWhereInput = {
    AND?: AppointmentPetLoverScalarWhereInput | AppointmentPetLoverScalarWhereInput[]
    OR?: AppointmentPetLoverScalarWhereInput[]
    NOT?: AppointmentPetLoverScalarWhereInput | AppointmentPetLoverScalarWhereInput[]
    id?: StringFilter<"AppointmentPetLover"> | string
    userId?: StringFilter<"AppointmentPetLover"> | string
    petId?: StringFilter<"AppointmentPetLover"> | string
    appointmentType?: StringFilter<"AppointmentPetLover"> | string
    dateTime?: DateTimeFilter<"AppointmentPetLover"> | Date | string
    location?: StringFilter<"AppointmentPetLover"> | string
    createdAt?: DateTimeFilter<"AppointmentPetLover"> | Date | string
  }

  export type UserPetLoverCreateWithoutPetPetLoverInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    AppointmentPetLover?: AppointmentPetLoverCreateNestedManyWithoutUserInput
  }

  export type UserPetLoverUncheckedCreateWithoutPetPetLoverInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    AppointmentPetLover?: AppointmentPetLoverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserPetLoverCreateOrConnectWithoutPetPetLoverInput = {
    where: UserPetLoverWhereUniqueInput
    create: XOR<UserPetLoverCreateWithoutPetPetLoverInput, UserPetLoverUncheckedCreateWithoutPetPetLoverInput>
  }

  export type VaccinationPetLoverCreateWithoutPetInput = {
    id?: string
    vaccineName: string
    dateAdministered: Date | string
    nextDueDate?: Date | string | null
    createdAt?: Date | string
  }

  export type VaccinationPetLoverUncheckedCreateWithoutPetInput = {
    id?: string
    vaccineName: string
    dateAdministered: Date | string
    nextDueDate?: Date | string | null
    createdAt?: Date | string
  }

  export type VaccinationPetLoverCreateOrConnectWithoutPetInput = {
    where: VaccinationPetLoverWhereUniqueInput
    create: XOR<VaccinationPetLoverCreateWithoutPetInput, VaccinationPetLoverUncheckedCreateWithoutPetInput>
  }

  export type VaccinationPetLoverCreateManyPetInputEnvelope = {
    data: VaccinationPetLoverCreateManyPetInput | VaccinationPetLoverCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentPetLoverCreateWithoutPetInput = {
    id?: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
    user: UserPetLoverCreateNestedOneWithoutAppointmentPetLoverInput
  }

  export type AppointmentPetLoverUncheckedCreateWithoutPetInput = {
    id?: string
    userId: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
  }

  export type AppointmentPetLoverCreateOrConnectWithoutPetInput = {
    where: AppointmentPetLoverWhereUniqueInput
    create: XOR<AppointmentPetLoverCreateWithoutPetInput, AppointmentPetLoverUncheckedCreateWithoutPetInput>
  }

  export type AppointmentPetLoverCreateManyPetInputEnvelope = {
    data: AppointmentPetLoverCreateManyPetInput | AppointmentPetLoverCreateManyPetInput[]
    skipDuplicates?: boolean
  }

  export type UserPetLoverUpsertWithoutPetPetLoverInput = {
    update: XOR<UserPetLoverUpdateWithoutPetPetLoverInput, UserPetLoverUncheckedUpdateWithoutPetPetLoverInput>
    create: XOR<UserPetLoverCreateWithoutPetPetLoverInput, UserPetLoverUncheckedCreateWithoutPetPetLoverInput>
    where?: UserPetLoverWhereInput
  }

  export type UserPetLoverUpdateToOneWithWhereWithoutPetPetLoverInput = {
    where?: UserPetLoverWhereInput
    data: XOR<UserPetLoverUpdateWithoutPetPetLoverInput, UserPetLoverUncheckedUpdateWithoutPetPetLoverInput>
  }

  export type UserPetLoverUpdateWithoutPetPetLoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AppointmentPetLover?: AppointmentPetLoverUpdateManyWithoutUserNestedInput
  }

  export type UserPetLoverUncheckedUpdateWithoutPetPetLoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AppointmentPetLover?: AppointmentPetLoverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VaccinationPetLoverUpsertWithWhereUniqueWithoutPetInput = {
    where: VaccinationPetLoverWhereUniqueInput
    update: XOR<VaccinationPetLoverUpdateWithoutPetInput, VaccinationPetLoverUncheckedUpdateWithoutPetInput>
    create: XOR<VaccinationPetLoverCreateWithoutPetInput, VaccinationPetLoverUncheckedCreateWithoutPetInput>
  }

  export type VaccinationPetLoverUpdateWithWhereUniqueWithoutPetInput = {
    where: VaccinationPetLoverWhereUniqueInput
    data: XOR<VaccinationPetLoverUpdateWithoutPetInput, VaccinationPetLoverUncheckedUpdateWithoutPetInput>
  }

  export type VaccinationPetLoverUpdateManyWithWhereWithoutPetInput = {
    where: VaccinationPetLoverScalarWhereInput
    data: XOR<VaccinationPetLoverUpdateManyMutationInput, VaccinationPetLoverUncheckedUpdateManyWithoutPetInput>
  }

  export type VaccinationPetLoverScalarWhereInput = {
    AND?: VaccinationPetLoverScalarWhereInput | VaccinationPetLoverScalarWhereInput[]
    OR?: VaccinationPetLoverScalarWhereInput[]
    NOT?: VaccinationPetLoverScalarWhereInput | VaccinationPetLoverScalarWhereInput[]
    id?: StringFilter<"VaccinationPetLover"> | string
    petId?: StringFilter<"VaccinationPetLover"> | string
    vaccineName?: StringFilter<"VaccinationPetLover"> | string
    dateAdministered?: DateTimeFilter<"VaccinationPetLover"> | Date | string
    nextDueDate?: DateTimeNullableFilter<"VaccinationPetLover"> | Date | string | null
    createdAt?: DateTimeFilter<"VaccinationPetLover"> | Date | string
  }

  export type AppointmentPetLoverUpsertWithWhereUniqueWithoutPetInput = {
    where: AppointmentPetLoverWhereUniqueInput
    update: XOR<AppointmentPetLoverUpdateWithoutPetInput, AppointmentPetLoverUncheckedUpdateWithoutPetInput>
    create: XOR<AppointmentPetLoverCreateWithoutPetInput, AppointmentPetLoverUncheckedCreateWithoutPetInput>
  }

  export type AppointmentPetLoverUpdateWithWhereUniqueWithoutPetInput = {
    where: AppointmentPetLoverWhereUniqueInput
    data: XOR<AppointmentPetLoverUpdateWithoutPetInput, AppointmentPetLoverUncheckedUpdateWithoutPetInput>
  }

  export type AppointmentPetLoverUpdateManyWithWhereWithoutPetInput = {
    where: AppointmentPetLoverScalarWhereInput
    data: XOR<AppointmentPetLoverUpdateManyMutationInput, AppointmentPetLoverUncheckedUpdateManyWithoutPetInput>
  }

  export type UserPetLoverCreateWithoutAppointmentPetLoverInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PetPetLover?: PetPetLoverCreateNestedManyWithoutUserInput
  }

  export type UserPetLoverUncheckedCreateWithoutAppointmentPetLoverInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    PetPetLover?: PetPetLoverUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserPetLoverCreateOrConnectWithoutAppointmentPetLoverInput = {
    where: UserPetLoverWhereUniqueInput
    create: XOR<UserPetLoverCreateWithoutAppointmentPetLoverInput, UserPetLoverUncheckedCreateWithoutAppointmentPetLoverInput>
  }

  export type PetPetLoverCreateWithoutAppointmentsInput = {
    id?: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    user: UserPetLoverCreateNestedOneWithoutPetPetLoverInput
    vaccinations?: VaccinationPetLoverCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    userId: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    vaccinations?: VaccinationPetLoverUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverCreateOrConnectWithoutAppointmentsInput = {
    where: PetPetLoverWhereUniqueInput
    create: XOR<PetPetLoverCreateWithoutAppointmentsInput, PetPetLoverUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserPetLoverUpsertWithoutAppointmentPetLoverInput = {
    update: XOR<UserPetLoverUpdateWithoutAppointmentPetLoverInput, UserPetLoverUncheckedUpdateWithoutAppointmentPetLoverInput>
    create: XOR<UserPetLoverCreateWithoutAppointmentPetLoverInput, UserPetLoverUncheckedCreateWithoutAppointmentPetLoverInput>
    where?: UserPetLoverWhereInput
  }

  export type UserPetLoverUpdateToOneWithWhereWithoutAppointmentPetLoverInput = {
    where?: UserPetLoverWhereInput
    data: XOR<UserPetLoverUpdateWithoutAppointmentPetLoverInput, UserPetLoverUncheckedUpdateWithoutAppointmentPetLoverInput>
  }

  export type UserPetLoverUpdateWithoutAppointmentPetLoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PetPetLover?: PetPetLoverUpdateManyWithoutUserNestedInput
  }

  export type UserPetLoverUncheckedUpdateWithoutAppointmentPetLoverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PetPetLover?: PetPetLoverUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PetPetLoverUpsertWithoutAppointmentsInput = {
    update: XOR<PetPetLoverUpdateWithoutAppointmentsInput, PetPetLoverUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PetPetLoverCreateWithoutAppointmentsInput, PetPetLoverUncheckedCreateWithoutAppointmentsInput>
    where?: PetPetLoverWhereInput
  }

  export type PetPetLoverUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PetPetLoverWhereInput
    data: XOR<PetPetLoverUpdateWithoutAppointmentsInput, PetPetLoverUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PetPetLoverUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserPetLoverUpdateOneRequiredWithoutPetPetLoverNestedInput
    vaccinations?: VaccinationPetLoverUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationPetLoverUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverCreateWithoutVaccinationsInput = {
    id?: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    user: UserPetLoverCreateNestedOneWithoutPetPetLoverInput
    appointments?: AppointmentPetLoverCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverUncheckedCreateWithoutVaccinationsInput = {
    id?: string
    userId: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
    appointments?: AppointmentPetLoverUncheckedCreateNestedManyWithoutPetInput
  }

  export type PetPetLoverCreateOrConnectWithoutVaccinationsInput = {
    where: PetPetLoverWhereUniqueInput
    create: XOR<PetPetLoverCreateWithoutVaccinationsInput, PetPetLoverUncheckedCreateWithoutVaccinationsInput>
  }

  export type PetPetLoverUpsertWithoutVaccinationsInput = {
    update: XOR<PetPetLoverUpdateWithoutVaccinationsInput, PetPetLoverUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<PetPetLoverCreateWithoutVaccinationsInput, PetPetLoverUncheckedCreateWithoutVaccinationsInput>
    where?: PetPetLoverWhereInput
  }

  export type PetPetLoverUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: PetPetLoverWhereInput
    data: XOR<PetPetLoverUpdateWithoutVaccinationsInput, PetPetLoverUncheckedUpdateWithoutVaccinationsInput>
  }

  export type PetPetLoverUpdateWithoutVaccinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserPetLoverUpdateOneRequiredWithoutPetPetLoverNestedInput
    appointments?: AppointmentPetLoverUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverUncheckedUpdateWithoutVaccinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentPetLoverUncheckedUpdateManyWithoutPetNestedInput
  }

  export type ElderlyCareCompanionAppointmentCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
    medicationLogs?: ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutMedicationInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
    medicationLogs?: ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type ElderlyCareCompanionAppointmentCreateOrConnectWithoutUserInput = {
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
    create: XOR<ElderlyCareCompanionAppointmentCreateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput>
  }

  export type ElderlyCareCompanionAppointmentCreateManyUserInputEnvelope = {
    data: ElderlyCareCompanionAppointmentCreateManyUserInput | ElderlyCareCompanionAppointmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ElderlyCareCompanionRecordCreateWithoutUserInput = {
    id?: string
    recordType: string
    details: string
    date: Date | string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput = {
    id?: string
    recordType: string
    details: string
    date: Date | string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionRecordCreateOrConnectWithoutUserInput = {
    where: ElderlyCareCompanionRecordWhereUniqueInput
    create: XOR<ElderlyCareCompanionRecordCreateWithoutUserInput, ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput>
  }

  export type ElderlyCareCompanionRecordCreateManyUserInputEnvelope = {
    data: ElderlyCareCompanionRecordCreateManyUserInput | ElderlyCareCompanionRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput = {
    id?: string
    status: string
    dateTime?: Date | string
    medication: ElderlyCareCompanionAppointmentCreateNestedOneWithoutMedicationLogsInput
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput = {
    id?: string
    medicationId: string
    status: string
    dateTime?: Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutUserInput = {
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    create: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput>
  }

  export type ElderlyCareCompanionMedicationTrackingCreateManyUserInputEnvelope = {
    data: ElderlyCareCompanionMedicationTrackingCreateManyUserInput | ElderlyCareCompanionMedicationTrackingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ElderlyCareCompanionAppointmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
    update: XOR<ElderlyCareCompanionAppointmentUpdateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedUpdateWithoutUserInput>
    create: XOR<ElderlyCareCompanionAppointmentCreateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutUserInput>
  }

  export type ElderlyCareCompanionAppointmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
    data: XOR<ElderlyCareCompanionAppointmentUpdateWithoutUserInput, ElderlyCareCompanionAppointmentUncheckedUpdateWithoutUserInput>
  }

  export type ElderlyCareCompanionAppointmentUpdateManyWithWhereWithoutUserInput = {
    where: ElderlyCareCompanionAppointmentScalarWhereInput
    data: XOR<ElderlyCareCompanionAppointmentUpdateManyMutationInput, ElderlyCareCompanionAppointmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ElderlyCareCompanionAppointmentScalarWhereInput = {
    AND?: ElderlyCareCompanionAppointmentScalarWhereInput | ElderlyCareCompanionAppointmentScalarWhereInput[]
    OR?: ElderlyCareCompanionAppointmentScalarWhereInput[]
    NOT?: ElderlyCareCompanionAppointmentScalarWhereInput | ElderlyCareCompanionAppointmentScalarWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    userId?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    type?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    title?: StringFilter<"ElderlyCareCompanionAppointment"> | string
    dateTime?: DateTimeFilter<"ElderlyCareCompanionAppointment"> | Date | string
    location?: StringNullableFilter<"ElderlyCareCompanionAppointment"> | string | null
    medicationDetails?: StringNullableFilter<"ElderlyCareCompanionAppointment"> | string | null
    createdAt?: DateTimeFilter<"ElderlyCareCompanionAppointment"> | Date | string
  }

  export type ElderlyCareCompanionRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: ElderlyCareCompanionRecordWhereUniqueInput
    update: XOR<ElderlyCareCompanionRecordUpdateWithoutUserInput, ElderlyCareCompanionRecordUncheckedUpdateWithoutUserInput>
    create: XOR<ElderlyCareCompanionRecordCreateWithoutUserInput, ElderlyCareCompanionRecordUncheckedCreateWithoutUserInput>
  }

  export type ElderlyCareCompanionRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: ElderlyCareCompanionRecordWhereUniqueInput
    data: XOR<ElderlyCareCompanionRecordUpdateWithoutUserInput, ElderlyCareCompanionRecordUncheckedUpdateWithoutUserInput>
  }

  export type ElderlyCareCompanionRecordUpdateManyWithWhereWithoutUserInput = {
    where: ElderlyCareCompanionRecordScalarWhereInput
    data: XOR<ElderlyCareCompanionRecordUpdateManyMutationInput, ElderlyCareCompanionRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type ElderlyCareCompanionRecordScalarWhereInput = {
    AND?: ElderlyCareCompanionRecordScalarWhereInput | ElderlyCareCompanionRecordScalarWhereInput[]
    OR?: ElderlyCareCompanionRecordScalarWhereInput[]
    NOT?: ElderlyCareCompanionRecordScalarWhereInput | ElderlyCareCompanionRecordScalarWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionRecord"> | string
    userId?: StringFilter<"ElderlyCareCompanionRecord"> | string
    recordType?: StringFilter<"ElderlyCareCompanionRecord"> | string
    details?: StringFilter<"ElderlyCareCompanionRecord"> | string
    date?: DateTimeFilter<"ElderlyCareCompanionRecord"> | Date | string
    createdAt?: DateTimeFilter<"ElderlyCareCompanionRecord"> | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutUserInput = {
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    update: XOR<ElderlyCareCompanionMedicationTrackingUpdateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateWithoutUserInput>
    create: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutUserInput>
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutUserInput = {
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateWithoutUserInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateWithoutUserInput>
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutUserInput = {
    where: ElderlyCareCompanionMedicationTrackingScalarWhereInput
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateManyMutationInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutUserInput>
  }

  export type ElderlyCareCompanionMedicationTrackingScalarWhereInput = {
    AND?: ElderlyCareCompanionMedicationTrackingScalarWhereInput | ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
    OR?: ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
    NOT?: ElderlyCareCompanionMedicationTrackingScalarWhereInput | ElderlyCareCompanionMedicationTrackingScalarWhereInput[]
    id?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    userId?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    medicationId?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    status?: StringFilter<"ElderlyCareCompanionMedicationTracking"> | string
    dateTime?: DateTimeFilter<"ElderlyCareCompanionMedicationTracking"> | Date | string
  }

  export type UserElderlyCareCompanionCreateWithoutElderlyCareCompanionAppointmentInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordCreateNestedManyWithoutUserInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionAppointmentInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUncheckedCreateNestedManyWithoutUserInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionAppointmentInput = {
    where: UserElderlyCareCompanionWhereUniqueInput
    create: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionAppointmentInput>
  }

  export type ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput = {
    id?: string
    status: string
    dateTime?: Date | string
    user: UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionMedicationTrackingInput
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput = {
    id?: string
    userId: string
    status: string
    dateTime?: Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingCreateOrConnectWithoutMedicationInput = {
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    create: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput>
  }

  export type ElderlyCareCompanionMedicationTrackingCreateManyMedicationInputEnvelope = {
    data: ElderlyCareCompanionMedicationTrackingCreateManyMedicationInput | ElderlyCareCompanionMedicationTrackingCreateManyMedicationInput[]
    skipDuplicates?: boolean
  }

  export type UserElderlyCareCompanionUpsertWithoutElderlyCareCompanionAppointmentInput = {
    update: XOR<UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionAppointmentInput>
    create: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionAppointmentInput>
    where?: UserElderlyCareCompanionWhereInput
  }

  export type UserElderlyCareCompanionUpdateToOneWithWhereWithoutElderlyCareCompanionAppointmentInput = {
    where?: UserElderlyCareCompanionWhereInput
    data: XOR<UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionAppointmentInput, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionAppointmentInput>
  }

  export type UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUpdateManyWithoutUserNestedInput
  }

  export type UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUncheckedUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ElderlyCareCompanionMedicationTrackingUpsertWithWhereUniqueWithoutMedicationInput = {
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    update: XOR<ElderlyCareCompanionMedicationTrackingUpdateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateWithoutMedicationInput>
    create: XOR<ElderlyCareCompanionMedicationTrackingCreateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedCreateWithoutMedicationInput>
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateWithWhereUniqueWithoutMedicationInput = {
    where: ElderlyCareCompanionMedicationTrackingWhereUniqueInput
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateWithoutMedicationInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateWithoutMedicationInput>
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateManyWithWhereWithoutMedicationInput = {
    where: ElderlyCareCompanionMedicationTrackingScalarWhereInput
    data: XOR<ElderlyCareCompanionMedicationTrackingUpdateManyMutationInput, ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutMedicationInput>
  }

  export type UserElderlyCareCompanionCreateWithoutElderlyCareCompanionRecordInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentCreateNestedManyWithoutUserInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionRecordInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUncheckedCreateNestedManyWithoutUserInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionRecordInput = {
    where: UserElderlyCareCompanionWhereUniqueInput
    create: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionRecordInput>
  }

  export type UserElderlyCareCompanionUpsertWithoutElderlyCareCompanionRecordInput = {
    update: XOR<UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionRecordInput>
    create: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionRecordInput>
    where?: UserElderlyCareCompanionWhereInput
  }

  export type UserElderlyCareCompanionUpdateToOneWithWhereWithoutElderlyCareCompanionRecordInput = {
    where?: UserElderlyCareCompanionWhereInput
    data: XOR<UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionRecordInput, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionRecordInput>
  }

  export type UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUpdateManyWithoutUserNestedInput
  }

  export type UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUncheckedUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionMedicationTracking?: ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserElderlyCareCompanionCreateWithoutElderlyCareCompanionMedicationTrackingInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentCreateNestedManyWithoutUserInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionMedicationTrackingInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUncheckedCreateNestedManyWithoutUserInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserElderlyCareCompanionCreateOrConnectWithoutElderlyCareCompanionMedicationTrackingInput = {
    where: UserElderlyCareCompanionWhereUniqueInput
    create: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionMedicationTrackingInput>
  }

  export type ElderlyCareCompanionAppointmentCreateWithoutMedicationLogsInput = {
    id?: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
    user: UserElderlyCareCompanionCreateNestedOneWithoutElderlyCareCompanionAppointmentInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedCreateWithoutMedicationLogsInput = {
    id?: string
    userId: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionAppointmentCreateOrConnectWithoutMedicationLogsInput = {
    where: ElderlyCareCompanionAppointmentWhereUniqueInput
    create: XOR<ElderlyCareCompanionAppointmentCreateWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutMedicationLogsInput>
  }

  export type UserElderlyCareCompanionUpsertWithoutElderlyCareCompanionMedicationTrackingInput = {
    update: XOR<UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionMedicationTrackingInput>
    create: XOR<UserElderlyCareCompanionCreateWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUncheckedCreateWithoutElderlyCareCompanionMedicationTrackingInput>
    where?: UserElderlyCareCompanionWhereInput
  }

  export type UserElderlyCareCompanionUpdateToOneWithWhereWithoutElderlyCareCompanionMedicationTrackingInput = {
    where?: UserElderlyCareCompanionWhereInput
    data: XOR<UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionMedicationTrackingInput, UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionMedicationTrackingInput>
  }

  export type UserElderlyCareCompanionUpdateWithoutElderlyCareCompanionMedicationTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUpdateManyWithoutUserNestedInput
  }

  export type UserElderlyCareCompanionUncheckedUpdateWithoutElderlyCareCompanionMedicationTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ElderlyCareCompanionAppointment?: ElderlyCareCompanionAppointmentUncheckedUpdateManyWithoutUserNestedInput
    ElderlyCareCompanionRecord?: ElderlyCareCompanionRecordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ElderlyCareCompanionAppointmentUpsertWithoutMedicationLogsInput = {
    update: XOR<ElderlyCareCompanionAppointmentUpdateWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUncheckedUpdateWithoutMedicationLogsInput>
    create: XOR<ElderlyCareCompanionAppointmentCreateWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUncheckedCreateWithoutMedicationLogsInput>
    where?: ElderlyCareCompanionAppointmentWhereInput
  }

  export type ElderlyCareCompanionAppointmentUpdateToOneWithWhereWithoutMedicationLogsInput = {
    where?: ElderlyCareCompanionAppointmentWhereInput
    data: XOR<ElderlyCareCompanionAppointmentUpdateWithoutMedicationLogsInput, ElderlyCareCompanionAppointmentUncheckedUpdateWithoutMedicationLogsInput>
  }

  export type ElderlyCareCompanionAppointmentUpdateWithoutMedicationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionAppointmentNestedInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedUpdateWithoutMedicationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformEduSeekerCreateWithoutSubmitterInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewEduSeekerCreateNestedManyWithoutPlatformInput
  }

  export type PlatformEduSeekerUncheckedCreateWithoutSubmitterInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    createdAt?: Date | string
    validated?: boolean
    reviews?: ReviewEduSeekerUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformEduSeekerCreateOrConnectWithoutSubmitterInput = {
    where: PlatformEduSeekerWhereUniqueInput
    create: XOR<PlatformEduSeekerCreateWithoutSubmitterInput, PlatformEduSeekerUncheckedCreateWithoutSubmitterInput>
  }

  export type PlatformEduSeekerCreateManySubmitterInputEnvelope = {
    data: PlatformEduSeekerCreateManySubmitterInput | PlatformEduSeekerCreateManySubmitterInput[]
    skipDuplicates?: boolean
  }

  export type ReviewEduSeekerCreateWithoutUserInput = {
    id?: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
    platform: PlatformEduSeekerCreateNestedOneWithoutReviewsInput
  }

  export type ReviewEduSeekerUncheckedCreateWithoutUserInput = {
    id?: string
    platformId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type ReviewEduSeekerCreateOrConnectWithoutUserInput = {
    where: ReviewEduSeekerWhereUniqueInput
    create: XOR<ReviewEduSeekerCreateWithoutUserInput, ReviewEduSeekerUncheckedCreateWithoutUserInput>
  }

  export type ReviewEduSeekerCreateManyUserInputEnvelope = {
    data: ReviewEduSeekerCreateManyUserInput | ReviewEduSeekerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlatformEduSeekerUpsertWithWhereUniqueWithoutSubmitterInput = {
    where: PlatformEduSeekerWhereUniqueInput
    update: XOR<PlatformEduSeekerUpdateWithoutSubmitterInput, PlatformEduSeekerUncheckedUpdateWithoutSubmitterInput>
    create: XOR<PlatformEduSeekerCreateWithoutSubmitterInput, PlatformEduSeekerUncheckedCreateWithoutSubmitterInput>
  }

  export type PlatformEduSeekerUpdateWithWhereUniqueWithoutSubmitterInput = {
    where: PlatformEduSeekerWhereUniqueInput
    data: XOR<PlatformEduSeekerUpdateWithoutSubmitterInput, PlatformEduSeekerUncheckedUpdateWithoutSubmitterInput>
  }

  export type PlatformEduSeekerUpdateManyWithWhereWithoutSubmitterInput = {
    where: PlatformEduSeekerScalarWhereInput
    data: XOR<PlatformEduSeekerUpdateManyMutationInput, PlatformEduSeekerUncheckedUpdateManyWithoutSubmitterInput>
  }

  export type PlatformEduSeekerScalarWhereInput = {
    AND?: PlatformEduSeekerScalarWhereInput | PlatformEduSeekerScalarWhereInput[]
    OR?: PlatformEduSeekerScalarWhereInput[]
    NOT?: PlatformEduSeekerScalarWhereInput | PlatformEduSeekerScalarWhereInput[]
    id?: StringFilter<"PlatformEduSeeker"> | string
    name?: StringFilter<"PlatformEduSeeker"> | string
    description?: StringFilter<"PlatformEduSeeker"> | string
    category?: StringFilter<"PlatformEduSeeker"> | string
    url?: StringFilter<"PlatformEduSeeker"> | string
    submittedBy?: StringFilter<"PlatformEduSeeker"> | string
    createdAt?: DateTimeFilter<"PlatformEduSeeker"> | Date | string
    validated?: BoolFilter<"PlatformEduSeeker"> | boolean
  }

  export type ReviewEduSeekerUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewEduSeekerWhereUniqueInput
    update: XOR<ReviewEduSeekerUpdateWithoutUserInput, ReviewEduSeekerUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewEduSeekerCreateWithoutUserInput, ReviewEduSeekerUncheckedCreateWithoutUserInput>
  }

  export type ReviewEduSeekerUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewEduSeekerWhereUniqueInput
    data: XOR<ReviewEduSeekerUpdateWithoutUserInput, ReviewEduSeekerUncheckedUpdateWithoutUserInput>
  }

  export type ReviewEduSeekerUpdateManyWithWhereWithoutUserInput = {
    where: ReviewEduSeekerScalarWhereInput
    data: XOR<ReviewEduSeekerUpdateManyMutationInput, ReviewEduSeekerUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewEduSeekerScalarWhereInput = {
    AND?: ReviewEduSeekerScalarWhereInput | ReviewEduSeekerScalarWhereInput[]
    OR?: ReviewEduSeekerScalarWhereInput[]
    NOT?: ReviewEduSeekerScalarWhereInput | ReviewEduSeekerScalarWhereInput[]
    id?: StringFilter<"ReviewEduSeeker"> | string
    platformId?: StringFilter<"ReviewEduSeeker"> | string
    userId?: StringFilter<"ReviewEduSeeker"> | string
    rating?: IntFilter<"ReviewEduSeeker"> | number
    comment?: StringFilter<"ReviewEduSeeker"> | string
    validated?: BoolFilter<"ReviewEduSeeker"> | boolean
    createdAt?: DateTimeFilter<"ReviewEduSeeker"> | Date | string
  }

  export type UserEduSeekerCreateWithoutPlatformsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    reviews?: ReviewEduSeekerCreateNestedManyWithoutUserInput
  }

  export type UserEduSeekerUncheckedCreateWithoutPlatformsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    reviews?: ReviewEduSeekerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserEduSeekerCreateOrConnectWithoutPlatformsInput = {
    where: UserEduSeekerWhereUniqueInput
    create: XOR<UserEduSeekerCreateWithoutPlatformsInput, UserEduSeekerUncheckedCreateWithoutPlatformsInput>
  }

  export type ReviewEduSeekerCreateWithoutPlatformInput = {
    id?: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
    user: UserEduSeekerCreateNestedOneWithoutReviewsInput
  }

  export type ReviewEduSeekerUncheckedCreateWithoutPlatformInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type ReviewEduSeekerCreateOrConnectWithoutPlatformInput = {
    where: ReviewEduSeekerWhereUniqueInput
    create: XOR<ReviewEduSeekerCreateWithoutPlatformInput, ReviewEduSeekerUncheckedCreateWithoutPlatformInput>
  }

  export type ReviewEduSeekerCreateManyPlatformInputEnvelope = {
    data: ReviewEduSeekerCreateManyPlatformInput | ReviewEduSeekerCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type UserEduSeekerUpsertWithoutPlatformsInput = {
    update: XOR<UserEduSeekerUpdateWithoutPlatformsInput, UserEduSeekerUncheckedUpdateWithoutPlatformsInput>
    create: XOR<UserEduSeekerCreateWithoutPlatformsInput, UserEduSeekerUncheckedCreateWithoutPlatformsInput>
    where?: UserEduSeekerWhereInput
  }

  export type UserEduSeekerUpdateToOneWithWhereWithoutPlatformsInput = {
    where?: UserEduSeekerWhereInput
    data: XOR<UserEduSeekerUpdateWithoutPlatformsInput, UserEduSeekerUncheckedUpdateWithoutPlatformsInput>
  }

  export type UserEduSeekerUpdateWithoutPlatformsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewEduSeekerUpdateManyWithoutUserNestedInput
  }

  export type UserEduSeekerUncheckedUpdateWithoutPlatformsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewEduSeekerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewEduSeekerUpsertWithWhereUniqueWithoutPlatformInput = {
    where: ReviewEduSeekerWhereUniqueInput
    update: XOR<ReviewEduSeekerUpdateWithoutPlatformInput, ReviewEduSeekerUncheckedUpdateWithoutPlatformInput>
    create: XOR<ReviewEduSeekerCreateWithoutPlatformInput, ReviewEduSeekerUncheckedCreateWithoutPlatformInput>
  }

  export type ReviewEduSeekerUpdateWithWhereUniqueWithoutPlatformInput = {
    where: ReviewEduSeekerWhereUniqueInput
    data: XOR<ReviewEduSeekerUpdateWithoutPlatformInput, ReviewEduSeekerUncheckedUpdateWithoutPlatformInput>
  }

  export type ReviewEduSeekerUpdateManyWithWhereWithoutPlatformInput = {
    where: ReviewEduSeekerScalarWhereInput
    data: XOR<ReviewEduSeekerUpdateManyMutationInput, ReviewEduSeekerUncheckedUpdateManyWithoutPlatformInput>
  }

  export type PlatformEduSeekerCreateWithoutReviewsInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    createdAt?: Date | string
    validated?: boolean
    submitter: UserEduSeekerCreateNestedOneWithoutPlatformsInput
  }

  export type PlatformEduSeekerUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    submittedBy: string
    createdAt?: Date | string
    validated?: boolean
  }

  export type PlatformEduSeekerCreateOrConnectWithoutReviewsInput = {
    where: PlatformEduSeekerWhereUniqueInput
    create: XOR<PlatformEduSeekerCreateWithoutReviewsInput, PlatformEduSeekerUncheckedCreateWithoutReviewsInput>
  }

  export type UserEduSeekerCreateWithoutReviewsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    platforms?: PlatformEduSeekerCreateNestedManyWithoutSubmitterInput
  }

  export type UserEduSeekerUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    platforms?: PlatformEduSeekerUncheckedCreateNestedManyWithoutSubmitterInput
  }

  export type UserEduSeekerCreateOrConnectWithoutReviewsInput = {
    where: UserEduSeekerWhereUniqueInput
    create: XOR<UserEduSeekerCreateWithoutReviewsInput, UserEduSeekerUncheckedCreateWithoutReviewsInput>
  }

  export type PlatformEduSeekerUpsertWithoutReviewsInput = {
    update: XOR<PlatformEduSeekerUpdateWithoutReviewsInput, PlatformEduSeekerUncheckedUpdateWithoutReviewsInput>
    create: XOR<PlatformEduSeekerCreateWithoutReviewsInput, PlatformEduSeekerUncheckedCreateWithoutReviewsInput>
    where?: PlatformEduSeekerWhereInput
  }

  export type PlatformEduSeekerUpdateToOneWithWhereWithoutReviewsInput = {
    where?: PlatformEduSeekerWhereInput
    data: XOR<PlatformEduSeekerUpdateWithoutReviewsInput, PlatformEduSeekerUncheckedUpdateWithoutReviewsInput>
  }

  export type PlatformEduSeekerUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    submitter?: UserEduSeekerUpdateOneRequiredWithoutPlatformsNestedInput
  }

  export type PlatformEduSeekerUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserEduSeekerUpsertWithoutReviewsInput = {
    update: XOR<UserEduSeekerUpdateWithoutReviewsInput, UserEduSeekerUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserEduSeekerCreateWithoutReviewsInput, UserEduSeekerUncheckedCreateWithoutReviewsInput>
    where?: UserEduSeekerWhereInput
  }

  export type UserEduSeekerUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserEduSeekerWhereInput
    data: XOR<UserEduSeekerUpdateWithoutReviewsInput, UserEduSeekerUncheckedUpdateWithoutReviewsInput>
  }

  export type UserEduSeekerUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platforms?: PlatformEduSeekerUpdateManyWithoutSubmitterNestedInput
  }

  export type UserEduSeekerUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platforms?: PlatformEduSeekerUncheckedUpdateManyWithoutSubmitterNestedInput
  }

  export type TransactionFinanceManagerCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    category?: string | null
    source?: string | null
    date: Date | string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFinanceManagerUncheckedCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    category?: string | null
    source?: string | null
    date: Date | string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFinanceManagerCreateOrConnectWithoutUserInput = {
    where: TransactionFinanceManagerWhereUniqueInput
    create: XOR<TransactionFinanceManagerCreateWithoutUserInput, TransactionFinanceManagerUncheckedCreateWithoutUserInput>
  }

  export type TransactionFinanceManagerCreateManyUserInputEnvelope = {
    data: TransactionFinanceManagerCreateManyUserInput | TransactionFinanceManagerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GoalFinanceManagerCreateWithoutUserInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    deadline: Date | string
    description: string
    createdAt?: Date | string
  }

  export type GoalFinanceManagerUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    deadline: Date | string
    description: string
    createdAt?: Date | string
  }

  export type GoalFinanceManagerCreateOrConnectWithoutUserInput = {
    where: GoalFinanceManagerWhereUniqueInput
    create: XOR<GoalFinanceManagerCreateWithoutUserInput, GoalFinanceManagerUncheckedCreateWithoutUserInput>
  }

  export type GoalFinanceManagerCreateManyUserInputEnvelope = {
    data: GoalFinanceManagerCreateManyUserInput | GoalFinanceManagerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionFinanceManagerUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionFinanceManagerWhereUniqueInput
    update: XOR<TransactionFinanceManagerUpdateWithoutUserInput, TransactionFinanceManagerUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionFinanceManagerCreateWithoutUserInput, TransactionFinanceManagerUncheckedCreateWithoutUserInput>
  }

  export type TransactionFinanceManagerUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionFinanceManagerWhereUniqueInput
    data: XOR<TransactionFinanceManagerUpdateWithoutUserInput, TransactionFinanceManagerUncheckedUpdateWithoutUserInput>
  }

  export type TransactionFinanceManagerUpdateManyWithWhereWithoutUserInput = {
    where: TransactionFinanceManagerScalarWhereInput
    data: XOR<TransactionFinanceManagerUpdateManyMutationInput, TransactionFinanceManagerUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionFinanceManagerScalarWhereInput = {
    AND?: TransactionFinanceManagerScalarWhereInput | TransactionFinanceManagerScalarWhereInput[]
    OR?: TransactionFinanceManagerScalarWhereInput[]
    NOT?: TransactionFinanceManagerScalarWhereInput | TransactionFinanceManagerScalarWhereInput[]
    id?: StringFilter<"TransactionFinanceManager"> | string
    userId?: StringFilter<"TransactionFinanceManager"> | string
    amount?: DecimalFilter<"TransactionFinanceManager"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"TransactionFinanceManager"> | string
    category?: StringNullableFilter<"TransactionFinanceManager"> | string | null
    source?: StringNullableFilter<"TransactionFinanceManager"> | string | null
    date?: DateTimeFilter<"TransactionFinanceManager"> | Date | string
    description?: StringFilter<"TransactionFinanceManager"> | string
    createdAt?: DateTimeFilter<"TransactionFinanceManager"> | Date | string
  }

  export type GoalFinanceManagerUpsertWithWhereUniqueWithoutUserInput = {
    where: GoalFinanceManagerWhereUniqueInput
    update: XOR<GoalFinanceManagerUpdateWithoutUserInput, GoalFinanceManagerUncheckedUpdateWithoutUserInput>
    create: XOR<GoalFinanceManagerCreateWithoutUserInput, GoalFinanceManagerUncheckedCreateWithoutUserInput>
  }

  export type GoalFinanceManagerUpdateWithWhereUniqueWithoutUserInput = {
    where: GoalFinanceManagerWhereUniqueInput
    data: XOR<GoalFinanceManagerUpdateWithoutUserInput, GoalFinanceManagerUncheckedUpdateWithoutUserInput>
  }

  export type GoalFinanceManagerUpdateManyWithWhereWithoutUserInput = {
    where: GoalFinanceManagerScalarWhereInput
    data: XOR<GoalFinanceManagerUpdateManyMutationInput, GoalFinanceManagerUncheckedUpdateManyWithoutUserInput>
  }

  export type GoalFinanceManagerScalarWhereInput = {
    AND?: GoalFinanceManagerScalarWhereInput | GoalFinanceManagerScalarWhereInput[]
    OR?: GoalFinanceManagerScalarWhereInput[]
    NOT?: GoalFinanceManagerScalarWhereInput | GoalFinanceManagerScalarWhereInput[]
    id?: StringFilter<"GoalFinanceManager"> | string
    userId?: StringFilter<"GoalFinanceManager"> | string
    title?: StringFilter<"GoalFinanceManager"> | string
    targetAmount?: DecimalFilter<"GoalFinanceManager"> | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFilter<"GoalFinanceManager"> | Date | string
    description?: StringFilter<"GoalFinanceManager"> | string
    createdAt?: DateTimeFilter<"GoalFinanceManager"> | Date | string
  }

  export type UserFinanceManagerCreateWithoutTransactionsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    goals?: GoalFinanceManagerCreateNestedManyWithoutUserInput
  }

  export type UserFinanceManagerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    goals?: GoalFinanceManagerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFinanceManagerCreateOrConnectWithoutTransactionsInput = {
    where: UserFinanceManagerWhereUniqueInput
    create: XOR<UserFinanceManagerCreateWithoutTransactionsInput, UserFinanceManagerUncheckedCreateWithoutTransactionsInput>
  }

  export type UserFinanceManagerUpsertWithoutTransactionsInput = {
    update: XOR<UserFinanceManagerUpdateWithoutTransactionsInput, UserFinanceManagerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserFinanceManagerCreateWithoutTransactionsInput, UserFinanceManagerUncheckedCreateWithoutTransactionsInput>
    where?: UserFinanceManagerWhereInput
  }

  export type UserFinanceManagerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserFinanceManagerWhereInput
    data: XOR<UserFinanceManagerUpdateWithoutTransactionsInput, UserFinanceManagerUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserFinanceManagerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: GoalFinanceManagerUpdateManyWithoutUserNestedInput
  }

  export type UserFinanceManagerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goals?: GoalFinanceManagerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFinanceManagerCreateWithoutGoalsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    transactions?: TransactionFinanceManagerCreateNestedManyWithoutUserInput
  }

  export type UserFinanceManagerUncheckedCreateWithoutGoalsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    transactions?: TransactionFinanceManagerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserFinanceManagerCreateOrConnectWithoutGoalsInput = {
    where: UserFinanceManagerWhereUniqueInput
    create: XOR<UserFinanceManagerCreateWithoutGoalsInput, UserFinanceManagerUncheckedCreateWithoutGoalsInput>
  }

  export type UserFinanceManagerUpsertWithoutGoalsInput = {
    update: XOR<UserFinanceManagerUpdateWithoutGoalsInput, UserFinanceManagerUncheckedUpdateWithoutGoalsInput>
    create: XOR<UserFinanceManagerCreateWithoutGoalsInput, UserFinanceManagerUncheckedCreateWithoutGoalsInput>
    where?: UserFinanceManagerWhereInput
  }

  export type UserFinanceManagerUpdateToOneWithWhereWithoutGoalsInput = {
    where?: UserFinanceManagerWhereInput
    data: XOR<UserFinanceManagerUpdateWithoutGoalsInput, UserFinanceManagerUncheckedUpdateWithoutGoalsInput>
  }

  export type UserFinanceManagerUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionFinanceManagerUpdateManyWithoutUserNestedInput
  }

  export type UserFinanceManagerUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionFinanceManagerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JournalMentalWellnessCreateWithoutUserInput = {
    id?: string
    mood: string
    entryText: string
    tags?: JournalMentalWellnessCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type JournalMentalWellnessUncheckedCreateWithoutUserInput = {
    id?: string
    mood: string
    entryText: string
    tags?: JournalMentalWellnessCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type JournalMentalWellnessCreateOrConnectWithoutUserInput = {
    where: JournalMentalWellnessWhereUniqueInput
    create: XOR<JournalMentalWellnessCreateWithoutUserInput, JournalMentalWellnessUncheckedCreateWithoutUserInput>
  }

  export type JournalMentalWellnessCreateManyUserInputEnvelope = {
    data: JournalMentalWellnessCreateManyUserInput | JournalMentalWellnessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentMentalWellnessCreateWithoutUserInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    result: string
    createdAt?: Date | string
  }

  export type AssessmentMentalWellnessUncheckedCreateWithoutUserInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    result: string
    createdAt?: Date | string
  }

  export type AssessmentMentalWellnessCreateOrConnectWithoutUserInput = {
    where: AssessmentMentalWellnessWhereUniqueInput
    create: XOR<AssessmentMentalWellnessCreateWithoutUserInput, AssessmentMentalWellnessUncheckedCreateWithoutUserInput>
  }

  export type AssessmentMentalWellnessCreateManyUserInputEnvelope = {
    data: AssessmentMentalWellnessCreateManyUserInput | AssessmentMentalWellnessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MeditationFeedbackCreateWithoutUserInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    meditation: MeditationCreateNestedOneWithoutFeedbacksInput
  }

  export type MeditationFeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    meditationId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type MeditationFeedbackCreateOrConnectWithoutUserInput = {
    where: MeditationFeedbackWhereUniqueInput
    create: XOR<MeditationFeedbackCreateWithoutUserInput, MeditationFeedbackUncheckedCreateWithoutUserInput>
  }

  export type MeditationFeedbackCreateManyUserInputEnvelope = {
    data: MeditationFeedbackCreateManyUserInput | MeditationFeedbackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JournalMentalWellnessUpsertWithWhereUniqueWithoutUserInput = {
    where: JournalMentalWellnessWhereUniqueInput
    update: XOR<JournalMentalWellnessUpdateWithoutUserInput, JournalMentalWellnessUncheckedUpdateWithoutUserInput>
    create: XOR<JournalMentalWellnessCreateWithoutUserInput, JournalMentalWellnessUncheckedCreateWithoutUserInput>
  }

  export type JournalMentalWellnessUpdateWithWhereUniqueWithoutUserInput = {
    where: JournalMentalWellnessWhereUniqueInput
    data: XOR<JournalMentalWellnessUpdateWithoutUserInput, JournalMentalWellnessUncheckedUpdateWithoutUserInput>
  }

  export type JournalMentalWellnessUpdateManyWithWhereWithoutUserInput = {
    where: JournalMentalWellnessScalarWhereInput
    data: XOR<JournalMentalWellnessUpdateManyMutationInput, JournalMentalWellnessUncheckedUpdateManyWithoutUserInput>
  }

  export type JournalMentalWellnessScalarWhereInput = {
    AND?: JournalMentalWellnessScalarWhereInput | JournalMentalWellnessScalarWhereInput[]
    OR?: JournalMentalWellnessScalarWhereInput[]
    NOT?: JournalMentalWellnessScalarWhereInput | JournalMentalWellnessScalarWhereInput[]
    id?: StringFilter<"JournalMentalWellness"> | string
    userId?: StringFilter<"JournalMentalWellness"> | string
    mood?: StringFilter<"JournalMentalWellness"> | string
    entryText?: StringFilter<"JournalMentalWellness"> | string
    tags?: StringNullableListFilter<"JournalMentalWellness">
    createdAt?: DateTimeFilter<"JournalMentalWellness"> | Date | string
  }

  export type AssessmentMentalWellnessUpsertWithWhereUniqueWithoutUserInput = {
    where: AssessmentMentalWellnessWhereUniqueInput
    update: XOR<AssessmentMentalWellnessUpdateWithoutUserInput, AssessmentMentalWellnessUncheckedUpdateWithoutUserInput>
    create: XOR<AssessmentMentalWellnessCreateWithoutUserInput, AssessmentMentalWellnessUncheckedCreateWithoutUserInput>
  }

  export type AssessmentMentalWellnessUpdateWithWhereUniqueWithoutUserInput = {
    where: AssessmentMentalWellnessWhereUniqueInput
    data: XOR<AssessmentMentalWellnessUpdateWithoutUserInput, AssessmentMentalWellnessUncheckedUpdateWithoutUserInput>
  }

  export type AssessmentMentalWellnessUpdateManyWithWhereWithoutUserInput = {
    where: AssessmentMentalWellnessScalarWhereInput
    data: XOR<AssessmentMentalWellnessUpdateManyMutationInput, AssessmentMentalWellnessUncheckedUpdateManyWithoutUserInput>
  }

  export type AssessmentMentalWellnessScalarWhereInput = {
    AND?: AssessmentMentalWellnessScalarWhereInput | AssessmentMentalWellnessScalarWhereInput[]
    OR?: AssessmentMentalWellnessScalarWhereInput[]
    NOT?: AssessmentMentalWellnessScalarWhereInput | AssessmentMentalWellnessScalarWhereInput[]
    id?: StringFilter<"AssessmentMentalWellness"> | string
    userId?: StringFilter<"AssessmentMentalWellness"> | string
    responses?: JsonFilter<"AssessmentMentalWellness">
    result?: StringFilter<"AssessmentMentalWellness"> | string
    createdAt?: DateTimeFilter<"AssessmentMentalWellness"> | Date | string
  }

  export type MeditationFeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: MeditationFeedbackWhereUniqueInput
    update: XOR<MeditationFeedbackUpdateWithoutUserInput, MeditationFeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<MeditationFeedbackCreateWithoutUserInput, MeditationFeedbackUncheckedCreateWithoutUserInput>
  }

  export type MeditationFeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: MeditationFeedbackWhereUniqueInput
    data: XOR<MeditationFeedbackUpdateWithoutUserInput, MeditationFeedbackUncheckedUpdateWithoutUserInput>
  }

  export type MeditationFeedbackUpdateManyWithWhereWithoutUserInput = {
    where: MeditationFeedbackScalarWhereInput
    data: XOR<MeditationFeedbackUpdateManyMutationInput, MeditationFeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type MeditationFeedbackScalarWhereInput = {
    AND?: MeditationFeedbackScalarWhereInput | MeditationFeedbackScalarWhereInput[]
    OR?: MeditationFeedbackScalarWhereInput[]
    NOT?: MeditationFeedbackScalarWhereInput | MeditationFeedbackScalarWhereInput[]
    id?: StringFilter<"MeditationFeedback"> | string
    meditationId?: StringFilter<"MeditationFeedback"> | string
    userId?: StringFilter<"MeditationFeedback"> | string
    rating?: IntFilter<"MeditationFeedback"> | number
    comment?: StringFilter<"MeditationFeedback"> | string
    createdAt?: DateTimeFilter<"MeditationFeedback"> | Date | string
  }

  export type UserMentalWellnessCreateWithoutJournalsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    assessments?: AssessmentMentalWellnessCreateNestedManyWithoutUserInput
    feedbacks?: MeditationFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessUncheckedCreateWithoutJournalsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    assessments?: AssessmentMentalWellnessUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: MeditationFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessCreateOrConnectWithoutJournalsInput = {
    where: UserMentalWellnessWhereUniqueInput
    create: XOR<UserMentalWellnessCreateWithoutJournalsInput, UserMentalWellnessUncheckedCreateWithoutJournalsInput>
  }

  export type UserMentalWellnessUpsertWithoutJournalsInput = {
    update: XOR<UserMentalWellnessUpdateWithoutJournalsInput, UserMentalWellnessUncheckedUpdateWithoutJournalsInput>
    create: XOR<UserMentalWellnessCreateWithoutJournalsInput, UserMentalWellnessUncheckedCreateWithoutJournalsInput>
    where?: UserMentalWellnessWhereInput
  }

  export type UserMentalWellnessUpdateToOneWithWhereWithoutJournalsInput = {
    where?: UserMentalWellnessWhereInput
    data: XOR<UserMentalWellnessUpdateWithoutJournalsInput, UserMentalWellnessUncheckedUpdateWithoutJournalsInput>
  }

  export type UserMentalWellnessUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessments?: AssessmentMentalWellnessUpdateManyWithoutUserNestedInput
    feedbacks?: MeditationFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserMentalWellnessUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assessments?: AssessmentMentalWellnessUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: MeditationFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserMentalWellnessCreateWithoutAssessmentsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    journals?: JournalMentalWellnessCreateNestedManyWithoutUserInput
    feedbacks?: MeditationFeedbackCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessUncheckedCreateWithoutAssessmentsInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    journals?: JournalMentalWellnessUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: MeditationFeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessCreateOrConnectWithoutAssessmentsInput = {
    where: UserMentalWellnessWhereUniqueInput
    create: XOR<UserMentalWellnessCreateWithoutAssessmentsInput, UserMentalWellnessUncheckedCreateWithoutAssessmentsInput>
  }

  export type UserMentalWellnessUpsertWithoutAssessmentsInput = {
    update: XOR<UserMentalWellnessUpdateWithoutAssessmentsInput, UserMentalWellnessUncheckedUpdateWithoutAssessmentsInput>
    create: XOR<UserMentalWellnessCreateWithoutAssessmentsInput, UserMentalWellnessUncheckedCreateWithoutAssessmentsInput>
    where?: UserMentalWellnessWhereInput
  }

  export type UserMentalWellnessUpdateToOneWithWhereWithoutAssessmentsInput = {
    where?: UserMentalWellnessWhereInput
    data: XOR<UserMentalWellnessUpdateWithoutAssessmentsInput, UserMentalWellnessUncheckedUpdateWithoutAssessmentsInput>
  }

  export type UserMentalWellnessUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: JournalMentalWellnessUpdateManyWithoutUserNestedInput
    feedbacks?: MeditationFeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserMentalWellnessUncheckedUpdateWithoutAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: JournalMentalWellnessUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: MeditationFeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MeditationFeedbackCreateWithoutMeditationInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    user: UserMentalWellnessCreateNestedOneWithoutFeedbacksInput
  }

  export type MeditationFeedbackUncheckedCreateWithoutMeditationInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type MeditationFeedbackCreateOrConnectWithoutMeditationInput = {
    where: MeditationFeedbackWhereUniqueInput
    create: XOR<MeditationFeedbackCreateWithoutMeditationInput, MeditationFeedbackUncheckedCreateWithoutMeditationInput>
  }

  export type MeditationFeedbackCreateManyMeditationInputEnvelope = {
    data: MeditationFeedbackCreateManyMeditationInput | MeditationFeedbackCreateManyMeditationInput[]
    skipDuplicates?: boolean
  }

  export type MeditationFeedbackUpsertWithWhereUniqueWithoutMeditationInput = {
    where: MeditationFeedbackWhereUniqueInput
    update: XOR<MeditationFeedbackUpdateWithoutMeditationInput, MeditationFeedbackUncheckedUpdateWithoutMeditationInput>
    create: XOR<MeditationFeedbackCreateWithoutMeditationInput, MeditationFeedbackUncheckedCreateWithoutMeditationInput>
  }

  export type MeditationFeedbackUpdateWithWhereUniqueWithoutMeditationInput = {
    where: MeditationFeedbackWhereUniqueInput
    data: XOR<MeditationFeedbackUpdateWithoutMeditationInput, MeditationFeedbackUncheckedUpdateWithoutMeditationInput>
  }

  export type MeditationFeedbackUpdateManyWithWhereWithoutMeditationInput = {
    where: MeditationFeedbackScalarWhereInput
    data: XOR<MeditationFeedbackUpdateManyMutationInput, MeditationFeedbackUncheckedUpdateManyWithoutMeditationInput>
  }

  export type UserMentalWellnessCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    journals?: JournalMentalWellnessCreateNestedManyWithoutUserInput
    assessments?: AssessmentMentalWellnessCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    name: string
    password: string
    createdAt?: Date | string
    journals?: JournalMentalWellnessUncheckedCreateNestedManyWithoutUserInput
    assessments?: AssessmentMentalWellnessUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserMentalWellnessCreateOrConnectWithoutFeedbacksInput = {
    where: UserMentalWellnessWhereUniqueInput
    create: XOR<UserMentalWellnessCreateWithoutFeedbacksInput, UserMentalWellnessUncheckedCreateWithoutFeedbacksInput>
  }

  export type MeditationCreateWithoutFeedbacksInput = {
    id?: string
    title: string
    description: string
    audioUrl: string
    createdAt?: Date | string
  }

  export type MeditationUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    title: string
    description: string
    audioUrl: string
    createdAt?: Date | string
  }

  export type MeditationCreateOrConnectWithoutFeedbacksInput = {
    where: MeditationWhereUniqueInput
    create: XOR<MeditationCreateWithoutFeedbacksInput, MeditationUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserMentalWellnessUpsertWithoutFeedbacksInput = {
    update: XOR<UserMentalWellnessUpdateWithoutFeedbacksInput, UserMentalWellnessUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserMentalWellnessCreateWithoutFeedbacksInput, UserMentalWellnessUncheckedCreateWithoutFeedbacksInput>
    where?: UserMentalWellnessWhereInput
  }

  export type UserMentalWellnessUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserMentalWellnessWhereInput
    data: XOR<UserMentalWellnessUpdateWithoutFeedbacksInput, UserMentalWellnessUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserMentalWellnessUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: JournalMentalWellnessUpdateManyWithoutUserNestedInput
    assessments?: AssessmentMentalWellnessUpdateManyWithoutUserNestedInput
  }

  export type UserMentalWellnessUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journals?: JournalMentalWellnessUncheckedUpdateManyWithoutUserNestedInput
    assessments?: AssessmentMentalWellnessUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MeditationUpsertWithoutFeedbacksInput = {
    update: XOR<MeditationUpdateWithoutFeedbacksInput, MeditationUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<MeditationCreateWithoutFeedbacksInput, MeditationUncheckedCreateWithoutFeedbacksInput>
    where?: MeditationWhereInput
  }

  export type MeditationUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: MeditationWhereInput
    data: XOR<MeditationUpdateWithoutFeedbacksInput, MeditationUncheckedUpdateWithoutFeedbacksInput>
  }

  export type MeditationUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostDIYHomesCreateManyUserInput = {
    id?: string
    title: string
    content: string
    category: string
    createdAt?: Date | string
  }

  export type ReviewDIYHomesCreateManyUserInput = {
    id?: string
    postId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type LikeDIYHomesCreateManyUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type BookmarkDIYHomesCreateManyUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesCreateManyUserInput = {
    id?: string
    postId?: string | null
    reviewId?: string | null
    reason: string
    createdAt?: Date | string
  }

  export type PostDIYHomesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewDIYHomesUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    bookmarks?: BookmarkDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Like?: LikeDIYHomesUncheckedUpdateManyWithoutPostNestedInput
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostDIYHomesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewDIYHomesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostDIYHomesUpdateOneRequiredWithoutReviewsNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutReviewNestedInput
  }

  export type ReviewDIYHomesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewDIYHomesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostDIYHomesUpdateOneRequiredWithoutLikeNestedInput
  }

  export type LikeDIYHomesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostDIYHomesUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkDIYHomesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostDIYHomesUpdateOneWithoutReportNestedInput
    review?: ReviewDIYHomesUpdateOneWithoutReportNestedInput
  }

  export type ReportDIYHomesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewDIYHomesCreateManyPostInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type BookmarkDIYHomesCreateManyPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeDIYHomesCreateManyPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesCreateManyPostInput = {
    id?: string
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewDIYHomesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutReviewDIYHomesNestedInput
    Report?: ReportDIYHomesUpdateManyWithoutReviewNestedInput
  }

  export type ReviewDIYHomesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Report?: ReportDIYHomesUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewDIYHomesUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutBookmarkDIYHomesNestedInput
  }

  export type BookmarkDIYHomesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkDIYHomesUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutLikeDIYHomesNestedInput
  }

  export type LikeDIYHomesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeDIYHomesUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutReportDIYHomesNestedInput
    review?: ReviewDIYHomesUpdateOneWithoutReportNestedInput
  }

  export type ReportDIYHomesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesCreateManyReviewInput = {
    id?: string
    postId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportDIYHomesUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserDIYHomesUpdateOneRequiredWithoutReportDIYHomesNestedInput
    post?: PostDIYHomesUpdateOneWithoutReportNestedInput
  }

  export type ReportDIYHomesUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDIYHomesUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUrbanExplorerCreateManyOwnerInput = {
    id?: string
    name: string
    category: string
    location: string
    description: string
    createdAt?: Date | string
    validated?: boolean
  }

  export type ReviewUrbanExplorerCreateManyUserInput = {
    id?: string
    placeId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type LikeUrbanExplorerCreateManyUserInput = {
    id?: string
    placeId: string
    createdAt?: Date | string
  }

  export type BookmarkUrbanExplorerCreateManyUserInput = {
    id?: string
    placeId: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerCreateManyUserInput = {
    id?: string
    placeId?: string | null
    reviewId?: string | null
    reason: string
    createdAt?: Date | string
  }

  export type PlaceUrbanExplorerUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUrbanExplorerUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    bookmarks?: BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    likes?: LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUrbanExplorerUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUrbanExplorerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutReviewsNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUrbanExplorerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUrbanExplorerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUrbanExplorerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUrbanExplorerUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUrbanExplorerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUrbanExplorerUpdateOneWithoutReportsNestedInput
    review?: ReviewUrbanExplorerUpdateOneWithoutReportsNestedInput
  }

  export type ReportUrbanExplorerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUrbanExplorerCreateManyPlaceInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type BookmarkUrbanExplorerCreateManyPlaceInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeUrbanExplorerCreateManyPlaceInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerCreateManyPlaceInput = {
    id?: string
    reviewId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReviewUrbanExplorerUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutReviewUrbanExplorerNestedInput
    reports?: ReportUrbanExplorerUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUrbanExplorerUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUrbanExplorerUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUrbanExplorerUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutBookmarkUrbanExplorerNestedInput
  }

  export type BookmarkUrbanExplorerUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUrbanExplorerUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutLikeUrbanExplorerNestedInput
  }

  export type LikeUrbanExplorerUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUrbanExplorerUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutReportUrbanExplorerNestedInput
    review?: ReviewUrbanExplorerUpdateOneWithoutReportsNestedInput
  }

  export type ReportUrbanExplorerUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerCreateManyReviewInput = {
    id?: string
    placeId?: string | null
    userId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUrbanExplorerUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUrbanExplorerUpdateOneRequiredWithoutReportUrbanExplorerNestedInput
    place?: PlaceUrbanExplorerUpdateOneWithoutReportsNestedInput
  }

  export type ReportUrbanExplorerUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUrbanExplorerUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieFoodCreateManyUserInput = {
    id?: string
    name: string
    cuisine: string
    origin: string
    description: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieLocationCreateManyUserInput = {
    id?: string
    foodId: string
    locationName: string
    address: string
    createdAt?: Date | string
  }

  export type FoodieReviewCreateManyUserInput = {
    id?: string
    foodId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieLikeCreateManyUserInput = {
    id?: string
    foodId: string
    createdAt?: Date | string
  }

  export type FoodieFoodUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: FoodieLocationUpdateManyWithoutFoodNestedInput
    reviews?: FoodieReviewUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: FoodieLocationUncheckedUpdateManyWithoutFoodNestedInput
    reviews?: FoodieReviewUncheckedUpdateManyWithoutFoodNestedInput
    likes?: FoodieLikeUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type FoodieFoodUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cuisine?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    food?: FoodieFoodUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type FoodieLocationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    food?: FoodieFoodUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type FoodieReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    food?: FoodieFoodUpdateOneRequiredWithoutLikesNestedInput
  }

  export type FoodieLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    foodId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationCreateManyFoodInput = {
    id?: string
    locationName: string
    address: string
    submittedBy: string
    createdAt?: Date | string
  }

  export type FoodieReviewCreateManyFoodInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type FoodieLikeCreateManyFoodInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FoodieLocationUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieLocationNestedInput
  }

  export type FoodieLocationUncheckedUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLocationUncheckedUpdateManyWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieReviewNestedInput
  }

  export type FoodieReviewUncheckedUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieReviewUncheckedUpdateManyWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserFoodieUpdateOneRequiredWithoutFoodieLikeNestedInput
  }

  export type FoodieLikeUncheckedUpdateWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodieLikeUncheckedUpdateManyWithoutFoodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PetPetLoverCreateManyUserInput = {
    id?: string
    petName: string
    species: string
    breed: string
    age: number
    medicalHistory?: string | null
    createdAt?: Date | string
  }

  export type AppointmentPetLoverCreateManyUserInput = {
    id?: string
    petId: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
  }

  export type PetPetLoverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationPetLoverUpdateManyWithoutPetNestedInput
    appointments?: AppointmentPetLoverUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationPetLoverUncheckedUpdateManyWithoutPetNestedInput
    appointments?: AppointmentPetLoverUncheckedUpdateManyWithoutPetNestedInput
  }

  export type PetPetLoverUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petName?: StringFieldUpdateOperationsInput | string
    species?: StringFieldUpdateOperationsInput | string
    breed?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: PetPetLoverUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentPetLoverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    petId?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationPetLoverCreateManyPetInput = {
    id?: string
    vaccineName: string
    dateAdministered: Date | string
    nextDueDate?: Date | string | null
    createdAt?: Date | string
  }

  export type AppointmentPetLoverCreateManyPetInput = {
    id?: string
    userId: string
    appointmentType: string
    dateTime: Date | string
    location: string
    createdAt?: Date | string
  }

  export type VaccinationPetLoverUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationPetLoverUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationPetLoverUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dateAdministered?: DateTimeFieldUpdateOperationsInput | Date | string
    nextDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserPetLoverUpdateOneRequiredWithoutAppointmentPetLoverNestedInput
  }

  export type AppointmentPetLoverUncheckedUpdateWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentPetLoverUncheckedUpdateManyWithoutPetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    appointmentType?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionAppointmentCreateManyUserInput = {
    id?: string
    type: string
    title: string
    dateTime: Date | string
    location?: string | null
    medicationDetails?: string | null
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionRecordCreateManyUserInput = {
    id?: string
    recordType: string
    details: string
    date: Date | string
    createdAt?: Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingCreateManyUserInput = {
    id?: string
    medicationId: string
    status: string
    dateTime?: Date | string
  }

  export type ElderlyCareCompanionAppointmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationLogs?: ElderlyCareCompanionMedicationTrackingUpdateManyWithoutMedicationNestedInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationLogs?: ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type ElderlyCareCompanionAppointmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    medicationDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: ElderlyCareCompanionAppointmentUpdateOneRequiredWithoutMedicationLogsNestedInput
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingCreateManyMedicationInput = {
    id?: string
    userId: string
    status: string
    dateTime?: Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserElderlyCareCompanionUpdateOneRequiredWithoutElderlyCareCompanionMedicationTrackingNestedInput
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElderlyCareCompanionMedicationTrackingUncheckedUpdateManyWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformEduSeekerCreateManySubmitterInput = {
    id?: string
    name: string
    description: string
    category: string
    url: string
    createdAt?: Date | string
    validated?: boolean
  }

  export type ReviewEduSeekerCreateManyUserInput = {
    id?: string
    platformId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type PlatformEduSeekerUpdateWithoutSubmitterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewEduSeekerUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformEduSeekerUncheckedUpdateWithoutSubmitterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewEduSeekerUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformEduSeekerUncheckedUpdateManyWithoutSubmitterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewEduSeekerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformEduSeekerUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewEduSeekerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewEduSeekerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewEduSeekerCreateManyPlatformInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    validated?: boolean
    createdAt?: Date | string
  }

  export type ReviewEduSeekerUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserEduSeekerUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewEduSeekerUncheckedUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewEduSeekerUncheckedUpdateManyWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    validated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFinanceManagerCreateManyUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    type: string
    category?: string | null
    source?: string | null
    date: Date | string
    description: string
    createdAt?: Date | string
  }

  export type GoalFinanceManagerCreateManyUserInput = {
    id?: string
    title: string
    targetAmount: Decimal | DecimalJsLike | number | string
    deadline: Date | string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFinanceManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFinanceManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFinanceManagerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalFinanceManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalFinanceManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalFinanceManagerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalMentalWellnessCreateManyUserInput = {
    id?: string
    mood: string
    entryText: string
    tags?: JournalMentalWellnessCreatetagsInput | string[]
    createdAt?: Date | string
  }

  export type AssessmentMentalWellnessCreateManyUserInput = {
    id?: string
    responses: JsonNullValueInput | InputJsonValue
    result: string
    createdAt?: Date | string
  }

  export type MeditationFeedbackCreateManyUserInput = {
    id?: string
    meditationId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type JournalMentalWellnessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalMentalWellnessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalMentalWellnessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mood?: StringFieldUpdateOperationsInput | string
    entryText?: StringFieldUpdateOperationsInput | string
    tags?: JournalMentalWellnessUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentMentalWellnessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentMentalWellnessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentMentalWellnessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responses?: JsonNullValueInput | InputJsonValue
    result?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meditation?: MeditationUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type MeditationFeedbackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meditationId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meditationId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackCreateManyMeditationInput = {
    id?: string
    userId: string
    rating: number
    comment: string
    createdAt?: Date | string
  }

  export type MeditationFeedbackUpdateWithoutMeditationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserMentalWellnessUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type MeditationFeedbackUncheckedUpdateWithoutMeditationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeditationFeedbackUncheckedUpdateManyWithoutMeditationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}